//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: RE_RSZ.bt
//   Authors: alphaZomega w/ help from Darkness and Praydog
//   Version: 0.51
//   Purpose: Parsing RE Engine RSZ data
//  Category: RE Engine
// File Mask: *.user.2;*.pfb.*;*.scn.*;*.rcol.*;*.bhvt.*;*.motfsm2.*;*.fsmv2.*
//  ID Bytes: 
//   History: September 27, 2021
//------------------------------------------------
//              Option:                                                           //Effect:
local string    RSZVersion      <hidden=false>       = "DMC5";                    //change between RE2, RE3, RE8 or DMC5
local int       Nesting         <hidden=true>        = TRUE;                      //Attempt to nest class instances inside eachother
local int       ShowAlignment   <hidden=true>        = FALSE;                     //Show metadata for each variable
local int       ShowChildRSZs   <hidden=true>        = FALSE;                     //Show all RSZs one after another, non-nested. Disabling hides nested RSZHeaders
local int       UseSpacers      <hidden=true>        = TRUE;                      //Show blank rows between some structs
local int       AutoDetectGame  <hidden=true>        = TRUE;                      //Automatically detect RSZVersion based on the name + ext of the file being viewed
local int       ReadBHVTHeader  <hidden=true>        = FALSE;                     //Testing methods to read BHVT header w/ UVAR (also in Motfsm and fsmv2)
local int       HideRawData     <hidden=true>        = FALSE;                     //Hides RawData struct
local int       PrintClasses    <hidden=true>        = FALSE;                     //

//Path to Noesis.exe
local wstring NoesisPath <hidden=true> =            "C:\\Program Files (x86)\\Noesis\\Noesis.exe";

//Game							                    //Extracted Path
local wstring DMC5Path <hidden=true> =              "D:\\modmanager\\REtool\\DMC_chunk_000\\natives\\x64\\";
local wstring RE2Path <hidden=true> =               "D:\\modmanager\\REtool\\RE2_chunk_000\\natives\\x64\\";
local wstring RE3Path <hidden=true> =               "D:\\modmanager\\REtool\\RE3_chunk_000\\natives\\stm\\";
local wstring RE8Path <hidden=true> =               "D:\\modmanager\\REtool\\RE8_chunk_000\\natives\\stm\\";


//RSZ Parser By Darkness:
#link "RSZParser.dll"
ubyte   IsInitialized();
void    ParseJson(string jsonPath);
string  GetRSZClassName(uint32 classHash);
uint32  GetFieldCount(uint32 classHash);
uint32  GetFieldAlignment(uint32 classHash, uint32 fieldIndex);
ubyte   GetFieldArrayState(uint32 classHash, uint32 fieldIndex);
string  GetFieldName(uint32 classHash, uint32 fieldIndex);
string  GetFieldTypeName(uint32 classHash, uint32 fieldIndex);
string  GetFieldOrgTypeName(uint32 classHash, uint32 fieldIndex);
uint32  GetFieldSize(uint32 classHash, uint32 fieldIndex);
uint64  GetFieldType(uint32 classHash, uint32 fieldIndex);
ubyte   IsFieldNative(uint32 classHash, uint32 fieldIndex);
#endlink

//Local variables:
local int i <hidden=true>, j <hidden=true>, k <hidden=true>, m <hidden=true>, n <hidden=true>, o <hidden=true>, h <hidden=true>, 
            matchSize <hidden=true>, lastGameObject <hidden=true>, uniqueHashes[5000] <hidden=true>, hashesLen <hidden=true>, noRetry <hidden=true>;
local int RSZOffset <hidden=true> = FindFirst("RSZ",1,0,0,0.0,1,0,0,24);
local int level <hidden=true>;
local int finished <hidden=true>;
local int broken <hidden=true>;


if (ShowAlignment) {
    local int varLen <hidden=false>;
    local uint maxVars <hidden=true> = ((FileSize()-RSZOffset)/4); 
    if (maxVars > 1000000) maxVars = 1000000;
    local uint offs[maxVars] <hidden=false>, aligns[maxVars] <hidden=false>, sizes[maxVars] <hidden=false>; //synced
} else {
    local int varLen <hidden=true>;
}

local wstring extractedDir <hidden=true>;
local wstring Local_Directory  <hidden=true> = FileNameGetPath(GetFileName(), true);
local uint findValue <hidden=true> = find(Local_Directory, "natives");
Local_Directory = StrDel( Local_Directory, findValue, sizeof(Local_Directory) - findValue) + "natives\\";
local wstring lower <hidden=true> = Lower(Local_Directory);

if (AutoDetectGame) {
    local string xFmt <hidden=true> = "x64\\";
    if (find(lower, "dmc") != -1 || find(lower, "evil may") != -1) {
	    RSZVersion = "DMC5";
	    extractedDir = DMC5Path;

    } else if (find(lower, "re2") != -1 || find(lower, "evil 2") != -1) {
	    RSZVersion = "RE2";
	    extractedDir = RE2Path;

    } else if (find(lower, "re3") != -1 || find(lower, "evil 3") != -1) {
	    RSZVersion = "RE3";
	    extractedDir = Lower(RE3Path);
	    xFmt = "stm\\";

    } else if (find(lower, "re8") != -1 || find(lower, "evil 8") != -1 || find(lower, "illage") != -1) {
	    RSZVersion = "RE8";
	    extractedDir = Lower(RE8Path);
	    xFmt = "stm\\";
    } 
	Local_Directory += xFmt;

} else if (RSZVersion == "DMC5" || RSZVersion == "RE2" || RSZVersion == "RE7") {
    Local_Directory += "x64\\";
} else {
    Local_Directory += "stm\\";
}
Local_Directory = Lower(Local_Directory);
local string JsonPath<hidden=true> = Lower(FileNameGetPath(GetTemplateFileName()) + "RSZ" + RSZVersion + ".json"); 
ParseJson(JsonPath);

//===========================
//Create your own enums here:
//They will be added inside the struct for any variable with the name detected by findS()
void enums(){
    if (findS(fieldName, "DamageType") != -1) {
        FSkip(-sizeof(data));
        enum { 
            None = -1,
            Minimum = 0,
            NormalS = 1,
            NormalL = 2,
            NormalLL = 3,
            Down = 4,
            DownBound = 5,
            Slam = 6,
            SlamBound = 7,
            Upper = 8,
            HyperUpper = 9,
            HyperUpperAir = 10,
            Blown = 11,
            Collapse = 12,
            RollingUpper = 13,
            CheckSpin = 14,
            Spin = 15,
            DiagonalBlown = 16,
            WindS = 17,
            WindL = 18,
            SnatchRelase = 19,
            StraightBlown = 20,
            Tremor = 21,
            Inhale = 22,
            MotionContinue = 23,
            Explosion = 24
        } DamageType;
    }
}

//============================
//Special functions & structs:
LittleEndian();
if (AutoDetectGame)
    AutoDetectVersion();

void AutoDetectVersion() {
    local string hashName;
    local uint checkedVersions, instanceCount, objectCount, hash, zz, varsChecked;
    local string origVersion = RSZVersion, origExtractedDir = extractedDir, origXFmt = xFmt, origLocal_Directory = Local_Directory, origJsonPath = JsonPath;
    FSeek(RSZOffset);
    while (FTell() < FileSize()-4 && ReadUInt() == 5919570) {
        instanceCount = ReadUInt(FTell() + 12), objectCount = ReadUInt(FTell() + 8);
        if (instanceCount) FSkip(48 + 4*objectCount + 8);
        for (zz=1; zz<instanceCount; zz++) {
            if (varsChecked > 100) break;
            hash = ReadUInt();
            hashName = ReadHashName(hash);
            checkedVersions = 0;
            if (hash != 0 && checkedVersions < 4 && hashName == "Unknown Class!") {
                while (checkedVersions < 4 && hashName == "Unknown Class!") {
                    switch (checkedVersions) {
                        case 0: RSZVersion = "DMC5"; extractedDir = DMC5Path; xFmt = "x64\\";  break;
                        case 1: RSZVersion = "RE2"; extractedDir = DMC5Path; xFmt = "x64\\"; break;
                        case 2: RSZVersion = "RE3"; extractedDir = DMC5Path; xFmt = "stm\\"; break;
                        default: RSZVersion = "RE8"; extractedDir = DMC5Path; xFmt = "stm\\"; break;
                    }
                    Local_Directory = lower + xFmt; JsonPath = Lower(FileNameGetPath(GetTemplateFileName()) + "RSZ" + RSZVersion + ".json");
                    ParseJson(JsonPath);
                    hashName = ReadHashName(hash);
                    checkedVersions++;
                }
                if (checkedVersions == 3 && hashName == "Unknown Class!") {
                    RSZVersion = origVersion; extractedDir = origExtractedDir; xFmt = origXFmt; Local_Directory = origLocal_Directory; JsonPath = origJsonPath;
                } else {
                    Printf("RSZVersion auto detected to %s\n", RSZVersion);
                    break;
                }
            }
            varsChecked++;
            FSkip(8);
        }
        if (varsChecked > 100) break;
        while (FTell() < FileSize()-4 && ReadUInt() != 5919570) FSkip(1);
    }
    FSeek(0);
}

void PrintRSZClass(string className) {
    local int z;
    local string dataType;
    local string secondDataType;
    local string output = className; 
    local uint index = findS(output, "\\."); 
    while (index != -1) {
		output = StrDel(output, index, sizeof(output) - index + 1) + "_" + SubStr(output, index + 1, -1);
		index = findS(output, "\\.");
    }
    local string newClassName = output;

    SPrintf(output, "public class %s : MonoBehaviour\n{\n    public string FieldName;\n", output);
    
    for (z = 0; z < GetFieldCount(hash); z++) {
        dataType = Lower(GetFieldTypeName(hash, z));
        if (dataType == "userdata" || dataType == "object") //|| dataType == "userdata"
            dataType = "int";
        else if (dataType == "data") {
            if (GetFieldSize(hash, z) == 1)
                dataType = "bool";
            else 
                dataType = "float";
        }
        if (GetFieldArrayState(hash,z))
            dataType += "[]";
        SPrintf(output, "%s    public %s %s;\n", output, dataType, GetFieldName(hash, z));
    }
    SPrintf(output, "%s\n    public %s()\n    {\n        FieldName = SCNImporter.RSZ.name;\n", output, newClassName);
    for (z = 0; z < GetFieldCount(hash); z++) {
        dataType = Lower(GetFieldTypeName(hash, z));
        if (dataType == "string") {
            SPrintf(output, "%s        %s = SCNImporter.RSZ.Fields[%d].String;\n", output, GetFieldName(hash, z), z);
        } else {
            
            if (dataType == "bool" || GetFieldSize(hash, z) == 1) { //if (dataType == "data") 
                dataType = "Boolean";
            } else if (dataType == "int" || dataType == "uint" || dataType == "object" || dataType == "userdata" || dataType == "uint64" || dataType == "int64")
                dataType = "Int32";
            else
                dataType = "Single";
            
            if (GetFieldArrayState(hash, z) == 1) {
                secondDataType = dataType;
                if (dataType == "Single")
                    secondDataType = "float";
                if (dataType == "Boolean")
                    secondDataType = "bool";
                if (dataType == "Int32")
                    secondDataType = "int";
                SPrintf(output, "%s        %s = new %s[Convert.ToInt32(SCNImporter.RSZ.Fields[%d].count)];\n", output, GetFieldName(hash, z), secondDataType, z);
                SPrintf(output, "%s        for(int j=0; j<Convert.ToInt32(SCNImporter.RSZ.Fields[%d].count); j++)\n", output, z);
                SPrintf(output, "%s            %s[j] = Convert.To%s(SCNImporter.RSZ.Fields[%d].count);\n", output, GetFieldName(hash, z), dataType, z);
            } else 
                SPrintf(output, "%s        %s = Convert.To%s(SCNImporter.RSZ.Fields[%d].data[0]);\n", output, GetFieldName(hash, z), dataType, z);
        }
    }
    SPrintf(output, "%s    }\n\n    void Start()\n    {\n    }\n    void Update()\n    {\n    }\n}\n", output);
    Printf("%s\n", output);
    
}


void align(uint alignment) { 
    while (FTell() % alignment != 0 && FTell() <= FileSize()) 
    FSkip(1); 
}

int detectedFloat(uint64 offset) {
    if (offset+4 <= FileSize()) {
        local float flt = ReadFloat(offset);
        return (ReadUByte(offset+3) < 255 && (Abs(flt) > 0.0000001 && Abs(flt) < 10000000) || ReadInt(offset) == 0); 
    } return false;
}

int detectedString(uint64 offset) { 
    return offset+6 <= FileSize() && (ReadByte(offset) != 0 && ReadByte(offset + 1) == 0 && ReadByte(offset + 2) != 0 && ReadByte(offset + 3) == 0 && ReadByte(offset + 4) != 0 && ReadByte(offset + 5) == 0);
}

int find(wstring str, wstring term) { return (RegExSearch(str, term, matchSize, 0)); }

int findS(string str, string term) { return (RegExSearch(str, term, matchSize, 0)); }

wstring Lower(wstring s1) { local string s = s1, s2 = s; for (k=0; k < sizeof(s); k++) s2[k] = ToLower(s[k]); return s2; }

wstring Upper(wstring s1) { local string s = s1, s2 = s; for (k=0; k < sizeof(s); k++) s2[k] = ToUpper(s[k]); return s2; }

uint detectedBools(uint tell) {
    local uint nonBoolTotal;
    for (o=0; o<4; o++)
        if (ReadUByte(tell + o) > 1)
            nonBoolTotal++;
    if (nonBoolTotal == 0)
        return true;
    return false;
}

void FileOpener(wstring path) { 
    if (FileExists(NoesisPath) && (find(path, ".mesh.") != -1 || find(path, ".tex.") != -1))
        Exec(NoesisPath, path, 0);
    local wstring tmpNm = GetTemplateFileNameW();
	FileOpen(path, TRUE, "hex", 1); 
    FileSelect(FindOpenFileW(path));
	if (GetTemplateFileNameW() == "")
		RunTemplate(tmpNm, 0);
}

typedef byte BLANK <name=readBLANK, read=readBLANK, write="">;

    string readBLANK(BLANK &ref) { return " ";}

    string ReadErrorNotice(BLANK &b) { return "[Read Error Adjustment]"; }

    string ReadUserDataNotice(BLANK &b) { return "[Embedded UserDatas]"; }

    string ReadMainDataNotice(BLANK &b) { return "[Main Data]"; }

void checkUseSpacers() {
    if (UseSpacers) {
        FSkip(-1); 
        BLANK blank;
    }
}

typedef enum <uint32> {
	ukn_error = 0,
	ukn_type,
	not_init,
	class_not_found,
	out_of_range,
	Undefined_tid,
	Object_tid,
	Action_tid,
	Struct_tid,
	NativeObject_tid,
	Resource_tid,
	UserData_tid,
	Bool_tid,
	C8_tid,
	C16_tid,
	S8_tid,
	U8_tid,
	S16_tid,
	U16_tid,
	S32_tid,
	U32_tid,
	S64_tid,
	U64_tid,
	F32_tid,
	F64_tid,
	String_tid,
	MBString_tid,
	Enum_tid,
	Uint2_tid,
	Uint3_tid,
	Uint4_tid,
	Int2_tid,
	Int3_tid,
	Int4_tid,
	Float2_tid,
	Float3_tid,
	Float4_tid,
	Float3x3_tid,
	Float3x4_tid,
	Float4x3_tid,
	Float4x4_tid,
	Half2_tid,
	Half4_tid,
	Mat3_tid,
	Mat4_tid,
	Vec2_tid,
	Vec3_tid,
	Vec4_tid,
	VecU4_tid,
	Quaternion_tid,
	Guid_tid,
	Color_tid,
	DateTime_tid,
	AABB_tid,
	Capsule_tid,
	TaperedCapsule_tid,
	Cone_tid,
	Line_tid,
	LineSegment_tid,
	OBB_tid,
	Plane_tid,
	PlaneXZ_tid,
	Point_tid,
	Range_tid,
	RangeI_tid,
	Ray_tid,
	RayY_tid,
	Segment_tid,
	Size_tid,
	Sphere_tid,
	Triangle_tid,
	Cylinder_tid,
	Ellipsoid_tid,
	Area_tid,
	Torus_tid,
	Rect_tid,
	Rect3D_tid,
	Frustum_tid,
	KeyFrame_tid,
	Uri_tid,
	GameObjectRef_tid,
	RuntimeType_tid,
	Sfix_tid,
	Sfix2_tid,
	Sfix3_tid,
	Sfix4_tid,
	Position_tid,
	F16_tid,
	End_tid,
	Data_tid
} TypeIDs;

typedef struct VARDATA(uint algn) {
    local ubyte alignment = algn;
    local uint offset = FTell();//getAlignedOffset(FTell(), algn);
    local uint varSz = offset; //placeholder
    local ubyte padding = offset - FTell();
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());
    
    /*if (offset > FTell()) {
        while (FTell() != offset) {
            if (!broken && ReadByte(FTell()) != 0) { //check if padding is really padding
                SetForeColor(cNone);
                ubyte blank <hidden=true>;//, fgcolor=cRed>;
            } else FSkip(1);
        }
        FSeek(offset);
    }*/
    
    if (!finished) {
        local uint varIdx = varLen;
        varLen++;
        if (ShowAlignment && offs[varIdx] == 0) {
            if ( varIdx != 0 && offs[varIdx-1] >= offset) { //new vars at the same offset overwrite old ones
                varLen--;
                varIdx--;
            } else {
                offs[varIdx] = offset;
                aligns[varIdx] = alignment;
                sizes[varIdx] = -1;
            }
        }
    }
    if (!FEof())
        ubyte varStart <hidden=true>;
    else Printf("End of File\n");
};

uint getAlignedOffset(uint tell, uint alignment) {
    local uint offset = tell;
    switch (alignment) {
        case 2:  offset = tell + (tell % 2); break;  //2-byte
        case 4:  offset = (tell + 3) & 0xFFFFFFFFFFFFFFFC; break;  //4-byte
        case 8:  offset = (tell + 7) & 0xFFFFFFFFFFFFFFF8; break;  //8-byte
        case 16: offset = (tell + 15) & 0xFFFFFFFFFFFFFFF0; break; //16-byte
        default: break;
    }
    return offset;
}

//re-aligns variables, given the index of the first variable after the change (varIdx), the offset at the end of the change (tell), and the amount of bytes lost/gained (sizeChange):
void fixAlignment(uint varIdx, uint tell, uint sizeChange) {
    local int diff;
    local int oldPadding;
    
    //apply original size difference to all offsets after the change:
    for (m=varIdx+1; m<varLen; m++) 
        offs[m] += sizeChange;
    
    //remove all old padding from after the change:
    for (m=varLen-3; m>varIdx; m--) {
        oldPadding = offs[m+1] - (offs[m] + sizes[m]);
        
        if (oldPadding > 0) {
            //Printf("%u deleting %i bytes from %u\n", m, oldPadding, offs[m+1] - oldPadding);
            DeleteBytes(offs[m+1] - oldPadding, oldPadding);
        }
        for (o=varLen-1; o>m; o--) 
            offs[o] -= oldPadding;
    }
    
    //remove old padding from struct directly following the change:
    oldPadding = offs[varIdx+1] - tell;
    if (oldPadding > 0) {
        DeleteBytes(tell, oldPadding);
        for (o=varIdx+1; o<varLen; o++) 
            offs[o] -= oldPadding;
    }
    
    //add new padding for each variable based on its type:
    for (m=varIdx+1; m<varLen; m++) {
        offs[m] += diff;
        while (aligns[m] && offs[m] % aligns[m] != 0) {
            InsertBytes(offs[m], 1, 0);
            offs[m] += 1;
            diff += 1;
        }
    }
    MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
}

void setSize() {
    if (exists(Alignment.varStart)) {
        Alignment.varSz = FTell() - startof(Alignment.varStart);
        if (ShowAlignment && !finished && sizes[Alignment.varIdx] == -1) 
            sizes[Alignment.varIdx] = Alignment.varSz;
    }
}

void setAlignment(uint algn) {
    if (ShowAlignment)
        struct VARDATA Alignment(algn) <name="Alignment">;
    else
        struct VARDATA Alignment(algn) <name="Alignment", hidden=true>;
    FSkip(-1);
}

int getLevel(uint offset) {
    local int L = 0;
    for (L=0; L<level; L++)
        if (offset >= startof(RSZFile[L].Data) && offset < startof(RSZFile[L].Data) + sizeof(RSZFile[L].Data))
            break;
    return L;
}

typedef struct {
    uchar uuid[16] <open=suppress>;
    if (finished && exists(GameObjectInfos.Guid)) {
        local ushort lvl <hidden=true> = level; if (exists(parentof(this).lvl)) lvl = parentof(this).lvl;
        for (o=0; o<Header.infoCount; o++)
            if (GameObjectInfos[o].Guid.uuid == uuid) {
                local string GameObjectRef <open=suppress>;
                if (exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id]].var[0].data))
                    SPrintf(GameObjectRef, "via.GameObject[%u] -- %s", RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id], RSZFile[lvl].Data.RawData.RSZ[ObjectTable[GameObjectInfos[o].id.id]].var[0].data);
                else if (exists(RSZFile[lvl]))
                    SPrintf(GameObjectRef, "%s[%u]", RSZFile[lvl].InstanceInfos.instanceInfo[ RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id] ].typeId.HashName, RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id]);
                break;
            }
    }
} rGUID <read=ReadrGUID, write=WriterGuid, comment=ReadrGUIDComment>;

    string TranslateGUID (uchar uuid[]) {
        local char s[37];
        SPrintf(s, 
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
            uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7],
            uuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]
        );
        return s;
    }

    string ReadrGUID (rGUID &g) {
        local string Guid = TranslateGUID(g.uuid);
        return Guid;
    }

    string ReadrGUIDComment(rGUID &g) { if (exists(g.GameObjectRef)) return g.GameObjectRef; return ""; }

    void WriterGuid (rGUID &g, string s) {
        local string out;
        local byte ii, offset, var;
        for (ii=0; ii<16; ii++) {
            if (ii==4 || ii== 6 || ii==8 || ii==10) 
                offset++;
            SScanf(SubStr(s, ii*2 + offset, 2), "%x", var);
            WriteByte(startof(g) + ii, var);
        }
    }

//functions for opening files:
string getRE2ext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".tex": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769669";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": case ".fbxskel": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1808312334";
		case ".fsmv2": case ".bhvt": case ".motfsm2": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".lprb": return ".3";
		case ".mmtr": return ".1808160001";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

string getRE3ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".12";
		case ".pfb": return ".17";
		case ".mdf2": return ".13";
		case ".tex": return ".190820018";
		case ".rcol": case ".jmap": return ".11";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1902042334";
		case ".fsmv2": case ".bhvt": case ".tml": case ".clip": return ".34";
		case ".motfsm2": return ".36";
		case ".scn": return ".20";
		case ".mov": return ".1";
		case ".chain": return ".24";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".99";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".78";
		case ".gui": return ".340020";
		case ".rmesh": return ".17008";
		case ".rtex": return ".4";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".14";
		case ".msg": return ".15";
		default: return "";
	}
}

string getRE8ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".16";
		case ".pfb": return ".17";
		case ".mdf2": return ".19";
		case ".tex": return ".30";
		case ".rcol": return ".18";
		case ".jmap": return ".17";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".2101050001";
		case ".bhvt": case ".tml": return ".34";
		case ".fsmv2": case ".clip": return ".40";
		case ".motfsm2": return ".42";
		case ".scn": return ".20";
		case ".mov": case ".finf": return ".1";
		case ".chain": return ".39";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".486";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".458";
		case ".gui": return ".400023";
		case ".rmesh": return ".17008";
		case ".rtex": return ".5";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".17";
		case ".msg": return ".15";
		case ".gpuc": return ".62";
		default: return "";
	}
}

string getDMCext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769672";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": return ".2";
		case ".wel": case ".tex":  return ".11";
		case ".mesh": return ".1808282334";
		case ".fsmv2": case ".bhvt": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".fbxskel": case ".lprb": return ".3";
		case ".motfsm2": return ".31";
		case ".mmtr": return ".1808168797";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

//convert a filepath string to Windows format:
string MakeBackslashes (wstring path) {
	local wstring localPath <hidden=true> = path;
	if (find(path, "@") != -1)
		localPath = StrDel(localPath, 0, 1);
	local uint index = find(localPath, "/");

	while (index != -1) {
		localPath = StrDel(localPath, index, sizeof(localPath) - index + 1) + "\\" + SubStr(localPath, index + 1, -1);
		index = find(localPath, "/");
	} return localPath;
}

void ReadRSZPath(wstring data) {
	local wstring localPath <hidden=true> = data;
	if (RSZVersion == "DMC5") {
		localPath = MakeBackslashes(localPath) + getDMCext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE3") {
		localPath = MakeBackslashes(localPath) + getRE3ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE2") {
		localPath = MakeBackslashes(localPath) + getRE2ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE8") {
		localPath = MakeBackslashes(localPath) + getRE8ext(FileNameGetExtension(localPath));
	}
	if (exists(fullPath)) { 
	    fullPath = Local_Directory + localPath;
	    if (Local_Directory != extractedDir && FileExists(Local_Directory + localPath)) {
		    local uint existsInMod <hidden=false> = 1;
		    fullPath = Local_Directory + localPath;
	    }
	    if (extractedDir != "" && FileExists((extractedDir + localPath))) {
		    if (exists(existsInMod)) {
			    local uint existsInPak <hidden=false> = 1;
		    } else { 
			    local uint existsInPak <hidden=true> = 1; 
			    fullPath = extractedDir + localPath;
		    }
	    }
	    if (fullPath != "" && FileExists(fullPath)) {
		    FSkip(-1);
		    ubyte OpenFile <name="OpenFile", write=WriteOpenFile, read=ReadOpenFile, open=false>;
	    }
    }
}

    string ReadOpenFile (ubyte &in) { return "Input here to open File"; }
    
    void WriteOpenFile(ubyte &in, wstring s) { FileOpener(parentof(in).fullPath); }

int detectedGuid(uint tell) {
    local int zerosCount;
    for (o=0; o<16; o++) 
        zerosCount += (ReadUByte(FTell()+o) == 0);
    return zerosCount;
}

int detectedObject(uint tell) {
    local int test = ReadInt(tell);
    if (detectedString(tell))
        setAsBroken();
    if (tell+4 <= FileSize() && test < idx && test > 0 && (test > idx - 100 || exists(userDataPath)))
        return true;
    return false;
}

void redetectObject() {
    if (!finished && broken ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4) {
            if (detectedObject(FTell())) {
                SetForeColor(cAqua);
                Printf("Redetected object from %u to %u\n",  pos, FTell()); 
                break;
            } else FSkip(4);
        }
    }
}

void setAsBroken() {
    FSkip(-1);
    broken = true;
    SetForeColor(cNone);
    ubyte blank <hidden=true, bgcolor=cRed>;
}

void redetectFloat() {
    if (broken && FTell() + 4 <= FileSize() && (broken && !finished)) { 
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && detectedFloat(FTell()))
            FSkip(4);
        
        if (FTell() != pos && FTell() < pos + 16) {
            broken = FALSE;
            SetForeColor(cAqua);
            Printf("Redetected float from %u to %u\n",  pos, FTell()); 
        } else FSeek(pos);
    }
    if (!detectedFloat(FTell()) && ReadFloat(FTell()) != 0) {
        broken = TRUE;
        SetForeColor(cNone);
    }
}

void redetectGuid() {
    if (FTell() + 16 <= FileSize() && !finished && (detectedGuid(FTell()) >= 4)) { // && broken
        local int pos = FTell();
        //if (broken) 
        //    FSkip(-12);
        while(FTell() <= FileSize() - 16) {
            if (detectedGuid(FTell()) == 16 || (detectedGuid(FTell()) < 4 && (detectedGuid(FTell()) <= detectedGuid(FTell() + 8)))) {
                if (pos != FTell()) {
                    broken = FALSE;
                    SetForeColor(cAqua);
                    Printf("Redetected GUID from %u to %u\n",  pos, FTell()); 
                }
                break;
            } else FSkip(8);
        }
    }
}

int isValidString(uint tell) {
    local int alignedOffs = getAlignedOffset(tell, 4);
    if (alignedOffs + 4 >= FileSize())
        return false;
    local uint size = ReadUInt(alignedOffs);
    if (sizeof(ReadWString(alignedOffs+4)) == 0)
        return false;
    local wstring String = ReadWString(alignedOffs+4);
    return (alignedOffs+8 <= FileSize() && ReadUInt64(alignedOffs) == 1 || size == 0 || (size == sizeof(String)/2 && ReadUByte(alignedOffs+7 != 0)) );
}

void redetectStringBehind() {
    local int pos = FTell();
    if (detectedString(FTell())) {
        while (detectedString(FTell()) && ReadUInt(FTell()-4) != sizeof(ReadWString(FTell())) / 2) 
            FSkip(-2);
        FSkip(-4);
        if (pos == FTell() || !isValidString(FTell()) || (sizeof( ReadWString(FTell()+4)) + FTell() <= pos) ) {
            //Printf("Aborting string redetection from %u to %u\n",  pos, FTell()); 
            FSeek(pos);
            setAsBroken();
        } else if (FTell() < pos) {
            SetForeColor(cAqua);
            broken = FALSE;
            Printf("Redetected string from %u back to %u\n",  pos, FTell()); 
        }
    } 
}

void redetectString() {
    if (!broken && !isValidString(FTell()+4)) 
        return;
    if  (FTell() + 4 <= FileSize() && ( !finished && (broken || !isValidString(FTell()) ) ) ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && FTell() - 24 < pos) {
            if (((detectedString(FTell()) && isValidString(FTell()-4)))) {
                FSkip(-4);
                break;
            } else uint skip <hidden=true>; //fgcolor=cRed,
        }
        if (FTell() - pos > 16 && broken) {
            FSeek(pos); //abort
        } else if (FTell() - pos > 8 && !broken) {
            FSeek(pos); //abort
        } else {
            SetForeColor(cAqua);
            broken = FALSE;
            Printf("Redetected string from %u to %u\n",  pos, FTell()); 
        }
    }
}

void ForceWriteString(uint tell, uint maxSize, wstring str) {
    OverwriteBytes(tell, maxSize, 0); 
    if (str != " " && str != "")
        WriteWString(tell, str); 
}

typedef ubyte Bool <read=ReadBOOL, write=WriteBOOL>;

    wstring ReadBOOL(Bool &b) {
        if (b)
            return "True";
        return "False";
    }
    
    void WriteBOOL(Bool &b, wstring s) {
        if (find(Lower(s), "true") != -1 || Atoi(s) >= 1)
            b = 1;
        else b = 0;
    }
    
    /*void WriteCount(uint &count, wstring s) { //changes lists
        if (!broken && Atoi(s) >= 0) { 
            local int newCount = Atoi(s);
            local int itemDiff = newCount - count.data;
            local int diff = count.itemSz * itemDiff;
            
            if (exists(parentof(count).item)) {
                if (!exists(parentof(count).item[0].isString) || itemDiff < 0)
                    diff = parentof(count).item[0].Alignment.varSz * itemDiff; 
                if (diff > 0) {
                    InsertBytes(parentof(count).item[count.data-1].Alignment.offset + parentof(count).item[count.data-1].Alignment.varSz, diff, 0);
                    fixAlignment(parentof(count).item[count.data-1].Alignment.varIdx, diff + parentof(count).item[count.data-1].Alignment.offset + parentof(count).item[count.data-1].Alignment.varSz, diff);
                } else if (diff < 0 && newCount >= 0) {
                    if (exists(parentof(count).item[0].isString))
                        diff = (parentof(count).item[newCount].Alignment.offset) - (parentof(count).item[count.data-1].Alignment.offset + parentof(count).item[count.data-1].Alignment.varSz);
                    DeleteBytes(parentof(count).item[newCount].Alignment.offset, Abs(diff));
                    if (newCount)
                        fixAlignment(parentof(count).item[newCount].Alignment.varIdx, parentof(count).item[newCount].Alignment.offset, diff);
                    else
                        fixAlignment(count.Alignment.varIdx + count.data, count.Alignment.offset + 4, diff);
                }
            } else if (diff > 0) {
                InsertBytes(count.Alignment.offset+4, diff, 0);
                fixAlignment(count.Alignment.varIdx, count.Alignment.offset + diff + 4, diff);
            }
            count.data = newCount;
        }
    }*/

//main typedef for RSZ chunks:
typedef struct Variable(uint32 classHash, ubyte fieldIndex) {
    local uint32 classHash <hidden=true> = classHash;
    local ubyte fieldIndex <hidden=true> = fieldIndex;
    local string fieldName <hidden=true> = GetFieldName(classHash, fieldIndex);
    local string fieldDataType <hidden=true> = GetFieldTypeName(classHash, fieldIndex);
    local TypeIDs fieldType <hidden=true> = GetFieldType(classHash, fieldIndex);
    local ushort elementSize <hidden=true> = GetFieldSize(classHash, fieldIndex);
    local ubyte align <hidden=true> = GetFieldAlignment(classHash, fieldIndex);
    local ubyte isList <hidden=true> = GetFieldArrayState(classHash, fieldIndex);
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());

    if ((isList) && !exists(parentof(this).Count)) {
		setAlignment(4);
        if (FTell()+4 <= FileSize()) {
            //if (!ShowChildRSZs)
            //    uint Count <hidden=true>;
            //else 
                uint Count;
		    setSize();
            if (Count > -1 && Count < FileSize() && elementSize > 0 && Count * elementSize <= FileSize() - FTell() && !detectedString(FTell())) {
                local uint c <hidden=true>, alignedOffs <hidden=true>;
                for (c=0; c<Count; c++) {
                    alignedOffs = getAlignedOffset(FTell(), align);
                    if (alignedOffs+elementSize <= FileSize()) { // && (fieldType != Object_tid || (ReadInt(FTell()) < idx && ReadInt(FTell()) > 0 )
                        FSeek(getAlignedOffset(FTell(), align));
                        //if (!broken)
                        //    SetForeColor(cGreen);
			            struct RSZVariable var(classHash, fieldIndex);
                        //SetForeColor(cNone);
                    } else {
                        setAsBroken();
                        break;    
                    }
                }
            } else setAsBroken();
        }
	} else {
        setAlignment(align);
		switch (fieldType) {
			case Bool_tid:
				if (FTell()+1 <= FileSize())
				    Bool data;
				break;
			case Color_tid:
                if (FTell()+4 <= FileSize())
				    ubyte data <name="ubyte R">, data <name="ubyte G">, data <name="ubyte B">, data <name="ubyte A">;
				break;
			case F32_tid:
				fieldDataType = "Float";
				if (FTell()+4 <= FileSize())
				    float data;
				break;
			case F64_tid:
				fieldDataType = "Double";
				if (FTell()+8 <= FileSize())
				    double data;
				break;
            case PlaneXZ_tid:
				if (FTell()+8 <= FileSize())
				    float data <name="float x">, data <name="float z">;
				break;
			case Float2_tid:
			case Point_tid:
            case Segment_tid:
				if (FTell()+8 <= FileSize())
				    float data <name="float x">, data <name="float y">;
				break;
			case Float3_tid:
				if (FTell()+12 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				break;
			case Quaternion_tid:
			case Float4_tid:
				if (FTell()+16 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				break;
			case GameObjectRef_tid:
            case Guid_tid:
            case Uri_tid:
				if (FTell()+16 <= FileSize())
				    rGUID data;
                break;
            case OBB_tid:
            case AABB_tid:
            case Capsule_tid:
            case LineSegment_tid:
			case Mat4_tid:
				if (FTell()+32 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                    if (fieldType == Capsule_tid) {
                        if (FTell()+4 <= FileSize())
				            float data <name="float r">;
                    } else if (fieldType != AABB_tid) {
					    if (FTell()+32 <= FileSize()) {
				            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
					        float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (fieldType == OBB_tid && FTell()+16 <= FileSize())
                                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        } 
                    }
                }
				break;
			case UserData_tid:
            case Object_tid:
                if (FTell()+4 <= FileSize())
                    //if (!ShowChildRSZs)
                    //    int ObjectIndex <hidden=true>;
                    //else
			            int ObjectIndex;
                if (fieldType == UserData_tid && exists(ObjectIndex) && ObjectIndex > -1) {
                    if ((RSZVersion == "DMC5" || RSZVersion == "RE2") && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx) 
                    && exists(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].dataOffs)) {
                        FSeek(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].dataOffs);
                        struct RSZMagic UserData <open=true, size=52>;
                        FSeek(startof(ObjectIndex)+4);
                        checkUseSpacers();
                        break;
                    } else if (exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx)) {
                        FSkip(-1);
                        struct StringRead path ( (startof(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx])+8), startof(RSZFile[lvl].RSZHeader), 0);
                        break;
                    } 
                } else if (fieldType == Object_tid &&  exists(ObjectIndex) &&ObjectIndex > -1 && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) {
					FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])); 
					struct RSZInstance RSZ <open=true, size=SizeRSZInstance>;
					FSeek(startof(ObjectIndex)+4);
                    checkUseSpacers();
				}
				break;
			case Range_tid:
                if (FTell()+8 <= FileSize())
				    float data <name="float R">, data <name="float S">;
				break;
			case RangeI_tid:
                if (FTell()+8 <= FileSize())
				    int data <name="int R">, data <name="int S">;
				break;
			case RuntimeType_tid:
                if (FTell()+4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size <= FileSize())
					    char data[size];
                }
				break;
			case S16_tid:
                if (FTell()+2 <= FileSize())
				    short data;
				break;
			case S32_tid:
				fieldDataType = "Int";
				if (FTell()+4 <= FileSize())
				    int data;
				break;
			case S64_tid:
				fieldDataType = "Int64";
				if (FTell()+8 <= FileSize())
				    int64 data;
				break;
			case S8_tid:
				fieldDataType = "Byte";
				if (FTell()+1 <= FileSize())
				    byte data;
				break;
			case Size_tid:
				fieldDataType = "Size";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U16_tid:
				fieldDataType = "UShort";
				if (FTell()+2 <= FileSize())
				    ushort data;
				break;
			case U32_tid:
				fieldDataType = "UInt";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U64_tid:
				fieldDataType = "UInt64";
				if (FTell()+8 <= FileSize())
				    uint64 data;
				break;
			case U8_tid:
				fieldDataType = "UByte";
				if (FTell()+1 <= FileSize())
				    ubyte data;
				break;
			case Vec2_tid:
				if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">;
				    float data <hidden=true>, data <hidden=true>; //FSkip(8);
                }
				break;
			case Vec3_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				    float data <hidden=true>; //FSkip(4);
                }
				break;
			case Vec4_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                }
				break;
			case Int2_tid:
                if (FTell()+8 <= FileSize())
				    int32 data <name="int x">, data <name="int y">;
                break;
            case Int3_tid:
                if (FTell()+12 <= FileSize())
				    int32 data <name="int x">, data <name="int y">, data <name="int z">;
                break;  
            case Uint3_tid:
                if (FTell()+12 <= FileSize())
				    uint32 data <name="uint x">, data <name="uint y">, data <name="uint z">;
                break;
            case Data_tid:
            case ukn_type: 
                if (find((wstring)fieldDataType, "tring") == -1) { //if NOT a string:
                    if (elementSize == 1 ) { 
                        fieldDataType = "Byte";
                        if (FTell()+1 <= FileSize())
				            byte data;
                    } else if (elementSize == 2) {
                        fieldDataType = "Int16";
                        if (FTell()+2 <= FileSize())
				            short data;
                    } else if (elementSize == 4) {
                        fieldDataType = "Data";
                        if (FTell()+4 <= FileSize())
                            if (ReadUInt(FTell()) != 0 && detectedFloat(FTell()) ) { //&& ReadUByte(FTell()+3) != 255
                                if (FTell()+4 <= FileSize()) {
				                    float data;
                                    FSkip(-4);
                                    int data_As_Int;
                                }
                            } else if (detectedObject(FTell())){
                                fieldDataType = "Data (Object?)";
                                if (FTell()+4 <= FileSize()) {
				                    int ObjectIndex <name="int data (ObjectIndex?)">;
					                if (exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) {
						                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]));
						                struct RSZInstance RSZ <open=true, size=SizeRSZInstance>;
						                FSeek(startof(ObjectIndex)+4);
						                FSkip(-1);
						                BLANK blank;
                                        //checkUseSpacers();
					                }
                                }
                            } else {
                                if (FTell()+4 <= FileSize()) {
				                    int data;
                                    FSkip(-4);
                                    float data_As_Float;
                                }
                            }
                    } else if (elementSize == 8) {
                        if (detectedFloat(FTell()) && detectedFloat(FTell()+4)) {
                            if (FTell()+8 <= FileSize())
				                float data <name="float x">, data <name="float y">;
                        } else {
                            fieldDataType = "Int64";
                            if (FTell()+8 <= FileSize())
				                int64 data;
                        }
                    } else if (elementSize == 16) {
                        if (align == 8) {
                            fieldDataType = "Guid";
                            //redetectGuid();
                            if (FTell()+16 <= FileSize())
				                rGUID Guid;
                        } else {
                            fieldDataType = "Vec4";
                            if (FTell()+16 <= FileSize())
				                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        }
                    } else if (elementSize == 64 || elementSize == 80) {
                        fieldDataType = "Mat4";
                        if (FTell()+4 <= FileSize()) {
                            float data <name="float x1">, data <name="float y1">, data <name="float z1">, data <name="float w1">;
                            float data <name="float x2">, data <name="float y2">, data <name="float z2">, data <name="float w2">;
                            float data <name="float x3">, data <name="float y3">, data <name="float z3">, data <name="float w3">;
                            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (elementSize == 80) {
                                fieldDataType = "OBB";
                                if (FTell()+16 <= FileSize())
				                    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            }
                        }
                    } else {
                        if (FTell()+elementSize <= FileSize())
				            ubyte data[elementSize];
                    }
                    break;
                } //if it IS a string, don't break and continue on:
            
			case Resource_tid:
			case String_tid:
                fieldType = String_tid;
				fieldDataType = "String";
                FSeek(getAlignedOffset(FTell(), 4));
                redetectStringBehind();
				FSeek(getAlignedOffset(FTell(), 4)); 
                if (isValidString(FTell()) && ReadUInt(FTell()) != 0)
                    broken=false;
                else redetectString();
                if (FTell() + 4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size * 2 <= FileSize() )
					    wchar_t data[size] <open=suppress>;
                    if (size > 0 && !exists(data) && !detectedFloat(FTell()-4)) 
                        setAsBroken();
                    local ubyte isString <hidden=true> = TRUE;
                    if (!isValidString(startof(size)) && (size > 128) || (broken && size > 64))
                        FSeek(startof(size)+1);
                } else FSeek(startof(this));
				break;
            
			default:
				Printf("%u Unknown type %s in class \"%s\" (Hash: 0x%08X) field number %d returned TypeID = \"%d\" ListFlag = \"%d\"\r\n", FTell(), EnumToString(fieldType), GetRSZClassName(classHash), classHash, fieldIndex, fieldType, isList);
                if (elementSize % 4 == 0)
                    float data[elementSize/4];
                else
                    ubyte data[elementSize];
				break;
		}
        
        enums();
        
        if (elementSize > 16)
            FSeek(startof(Alignment.varStart) + elementSize);
    }
    setSize();
    
    if (title == "") {
        if (exists(size) && exists(data) && size > 1) {
            title = (wstring)data;
        } else if (exists(this.UserData) && secondTitle == "") { //&& sizeof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].title) > sizeof(title)
            secondTitle = ReadRSZMagic(this.UserData);
        } else if (fieldIndex == 0 && secondTitle == "" && exists(ObjectIndex) && ObjectIndex > -1 && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]) && RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].title != "") {
            secondTitle = RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].title;
            //if (fieldIndex == 0)
            //    title = secondTitle;
        } else if (secondTitle == "" && exists(this.Guid) && ReadUInt64(startof(Guid)) != 0) {
            secondTitle = ReadrGUID(Guid);
        }
    }
    
    if (fieldDataType == "String" && exists(data) && find((wstring)data, "/") != -1 && FileNameGetExtension((wstring)data) != ".json") {
        local wstring fullPath <hidden=true>;
        ReadRSZPath((wstring)data);
    }
    if (FTell() <= startof(this)) {
        Printf("Empty struct %s\n", ReadRSZInstanceName(parentof(this))); 
        FSeek(startof(this));
    }
};

typedef Variable RSZVariable <optimize=false, name=ReadRSZVariableName, read=ReadRSZVariable, write=WriteRSZVariable, comment=ReadRSZVariableComment>;

    string ReadRSZVariableComment(RSZVariable &r) { if (exists(r.data.GameObjectRef)) return r.data.GameObjectRef; return ""; }
    
    string ReadRSZVariableName(RSZVariable &r) { 
        local string s; 
        if (r.isList) {
            if ((exists(r.var[0]) && exists(r.var[0].ObjectIndex) && r.var[0].ObjectIndex != 0) || exists(r.var[0].UserData) )
                SPrintf(s, "List (%s) *%s", r.fieldDataType, r.fieldName); // %s[%u] //, RSZFile[r.lvl].Data.RawData.RSZ[r.var[0].ObjectIndex].name, r.var[0].ObjectIndex
            else s = "List" + " (" + r.fieldDataType + ") " + r.fieldName;
        } else if (exists(r.ObjectIndex) && exists(parentof(r).fieldDataType) && parentof(r).fieldDataType == "List") {
            SPrintf(s, "%s[%u]", RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].name, r.ObjectIndex);
        } else if (r.fieldDataType != "") {
            if ((exists(r.RSZ) && r.ObjectIndex != 0) || exists(r.UserData) )
                s = r.fieldDataType + " *" + r.fieldName; 
            else if (r.fieldDataType + " " + r.fieldName == "Byte v0")
                s = "Byte v0 (isEnabled)";
            else s = r.fieldDataType + " " + r.fieldName;  
        } else s = r.fieldName; 
        return s;
    }
    
    void WriteRSZString(RSZVariable &r, wstring s) { 
        local int oldDataSz;
        if (exists(r.data)) 
            wstring oldData = r.data;
        else
            wstring oldData = "";
        
        if (exists(r.data)) {
            oldDataSz = sizeof(r.data);
            local int temp;
            if (exists(Header.resourceCount))
                for (o=0; o<Header.resourceCount; o++) {
                    if (exists(ResourceInfos.ResourceInfo[o].pathStr) && ResourceInfos.ResourceInfo[o].pathStr.String == oldData) {
                        while (ReadByte(startof(ResourceInfos.ResourceInfo[o].pathStr.String)+oldDataSz+temp) == 0)
                            temp++;
                        oldDataSz += temp;
                    } else if (exists(ResourceInfos.ResourceInfo[o].path) && ResourceInfos.ResourceInfo[o].path == oldData) {
                        while (ReadByte(startof(ResourceInfos.ResourceInfo[o].path)+oldDataSz+temp) == 0)
                            temp++;
                        oldDataSz += temp;
                    }
                } 
        }
        Printf("Sizeof(input)=%i, sizeof(oldData)=%i \n", sizeof(s)-2, oldDataSz);
        local int sizeToInsert = (sizeof(s)-2) - oldDataSz;
        
        if (sizeToInsert > 0) {
            if (exists(r.data))
                Printf("Size to Insert: %i\nr.data: %s\ns.data: %s\n", sizeToInsert, r.data, s);
            
            while (sizeToInsert % 16 != 0)
                sizeToInsert++;
            Printf("Size to Insert (padded): %i\n", sizeToInsert);
            if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
                local int ii, jj;
                while (exists(RSZFile[ii])) {
                    if (startof(r.size)+4 > startof(RSZFile[ii]) && startof(r.size)+4 < startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) && startof(RSZFile[r.lvl]) != startof(RSZFile[ii])) {
                        Printf("%i %i %i\n", startof(r.size)+4, startof(RSZFile[ii]), startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) );
                        RSZFile[ii].RSZHeader.dataOffset += sizeToInsert;
                    }
                    jj=0;
                    while (exists(RSZFile[ii].RSZUserDataInfos.userDataInfo[jj])) {
                        if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs + startof(RSZFile[ii]) > startof(r.size)+4)
                            RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs += sizeToInsert;
                        if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs + startof(RSZFile[ii]) > startof(r.size)+4)
                            RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs += sizeToInsert;
                        
                        jj++;
                    }
                    ii++;
                }
            }
            InsertBytes(startof(r.size)+4, sizeToInsert, 0); 
        } else 
            sizeToInsert = 0;
        
        ForceWriteString(startof(r.size)+4, sizeToInsert+oldDataSz, s); 
        r.size = (sizeToInsert+oldDataSz)/2;
        
        if (find(oldData, "/") != -1) { //sizeToInsert > 0 && 
            local byte resourceInfosIncreased = FALSE;
            local int changeOffs, h;
            for (h=0; h<Header.resourceCount; h++)
                if (ResourceInfos.ResourceInfo[h].pathStr.String == oldData) {
                    resourceInfosIncreased = TRUE;
                    break;
                }
            
            if (resourceInfosIncreased == TRUE && exists(Header.userdataCount)) { // if not PFB
                local int paddingBytes;
                while((RSZFile[r.lvl].RSZHeader.dataOffset + sizeToInsert + paddingBytes) % 16 != RSZFile[r.lvl].RSZHeader.dataOffset % 16)
                    paddingBytes++;
                
                for (h=0; h<Header.resourceCount; h++) {
                    if (ResourceInfos.ResourceInfo[h].pathStr.String == oldData) {
                        Printf("Found old ResourceInfo\n");
                        changeOffs = startof(ResourceInfos.ResourceInfo[h].pathStr.String);
                        //DeleteBytes(startof(ResourceInfos.ResourceInfo[h].pathStr.String), sizeof(ResourceInfos.ResourceInfo[h].pathStr.String));
                        if (sizeToInsert > 0) {
                            InsertBytes(startof(ResourceInfos.ResourceInfo[h].pathStr.String) + sizeof(ResourceInfos.ResourceInfo[h].pathStr.String), sizeToInsert);
                        }
                        ForceWriteString(startof(ResourceInfos.ResourceInfo[h].pathStr.String), oldDataSz, s);
                    }
                    if (changeOffs > 0 && changeOffs < startof(ResourceInfos.ResourceInfo[h].pathStr.String))
                        ResourceInfos.ResourceInfo[h].pathStr.strOffset += sizeToInsert;
                }
                if (changeOffs > 0 && sizeToInsert) {
                    for (h=0; h<Header.prefabCount; h++) 
                        PrefabInfos.PrefabInfo[h].id += sizeToInsert;
                }
                if (paddingBytes)
                    InsertBytes(RSZFile[r.lvl].RSZHeader.dataOffset + startof(RSZFile[r.lvl].RSZHeader), paddingBytes, 0);
                RSZFile[r.lvl].RSZHeader.dataOffset += paddingBytes;
            }
            
        }
        if (sizeToInsert > 0) {
            if (exists(resourceInfosIncreased) && resourceInfosIncreased == TRUE)
                Header.dataOffset += sizeToInsert;
            if (exists(userDataInfos)) {
                
                for (h=0; h<Header.userdataCount; h++)
                    userDataInfos.userDataInfo[h].pathOffset.strOffset += sizeToInsert;
                for (h=0; h<Header.prefabCount; h++)
                    PrefabInfos.PrefabInfo[h].id += sizeToInsert;
            }
            MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
        } 
    }

    wstring ReadRSZVariable(RSZVariable &r) {
        local string s;
        if (exists(r.UserData)) {
            return ReadRSZMagic(r.UserData);
        } else if (exists(r.var)) {
            if (exists(r.var.ObjectIndex) && exists(RSZFile[r.lvl].Data.RawData.RSZ[r.var[0].ObjectIndex])) {
                SPrintf(s, "%s[%u]", RSZFile[r.lvl].Data.RawData.RSZ[r.var[0].ObjectIndex].name, r.var[0].ObjectIndex);
                if (r.var[0].ObjectIndex != r.var.ObjectIndex)
                    SPrintf(s, "%s - [%u]", s, r.var.ObjectIndex);
            } else 
                return ReadRSZVariable(r.var[0]);
        } else if (exists(r.ObjectIndex) && r.ObjectIndex > -1 && exists(RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex])) {
            if (exists(RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].title) && RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].title != "")
                return RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].title;
        } else 
            switch (r.fieldType) {
                case Bool_tid:
                    if (exists(r.data))
                        s = ReadBOOL(r.data);
                    break;
		        case S16_tid:
		        case S32_tid:
		        case S64_tid:
		        case Size_tid:
		        case S8_tid:
		        case U16_tid:
		        case U32_tid:
		        case U64_tid:
                    if (exists(r.data))
                        SPrintf(s, "%Li", r.data);
                    break;
                case F32_tid:
                    if (exists(r.data))
                        SPrintf(s, "%f", r.data);
                    break;
		        case Resource_tid:
                case String_tid:
                    if (exists(r.data))
                        return r.data;
                    break;
                case Float2_tid:
                case Vec2_tid:
                case Point_tid:
                case Range_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                    break;
                case Vec3_tid:
                case Float3_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g]", r.data[0], r.data[1], r.data[2]);
                    break;
                case Vec4_tid:
                case Mat4_tid:
                case Float4_tid:
				case Quaternion_tid:
                case Int3_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                    break;
                case Guid_tid:
                case GameObjectRef_tid:
                case Uri_tid:
                    if (exists(r.data))
                        s = ReadrGUID(r.data);
                    break;
                case AABB_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g]  [%g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[4],  r.data[5],  r.data[6]);
                    break;
                case Mat4_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g %g]  [%g, %g, %g %g]  [%g, %g, %g %g]  [%g, %g, %g %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                    break;
                case ukn_type:
                case Data_tid:
                    if (exists(r.data) && r.elementSize == 1 ) { //|| r.fieldOrgTypeName == "Data1A1"
                        if (r.data == 1) {
                            s = "True";
                        } else if (r.data == 0) {
                            s = "False";
                        } else 
                            SPrintf(s, "%i", r.data);
                    } else if (exists(r.data) && r.elementSize == 4) {
                        if (exists(r.data_As_Int))
                            SPrintf(s, "%f", r.data);
                        else if (Abs(r.data) > 1000000) 
                            SPrintf(s, "%X", r.data);    
                        else 
                            SPrintf(s, "%i", r.data);
                    } else if (exists(r.data) && r.elementSize == 8) {
                        if (exists(r.data[1]) && (detectedFloat(FTell()) || detectedFloat(FTell()+4)))
                            SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                        else
                            SPrintf(s, "%Li", r.data);
                    } else if (r.elementSize == 16) {
                        if (exists(r.Guid))
                            s = ReadrGUID(r.Guid);
                        else if (exists(r.data[3]))
                            SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                    } else if (exists(r.data) && r.elementSize == 64) {
                        SPrintf(s, "[%g, %g, %g %g]  [%g, %g, %g %g]  [%g, %g, %g %g]  [%g, %g, %g %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], 
                            r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                    }
                    break;
                default:
                    break;
            }
        return s;
    }

    void WriteRSZVariable(RSZVariable &r, wstring s) {
        if (exists(r.fullPath) && r.fullPath != "" && sizeof(s) <= 6) {
            FileOpener(r.fullPath);
        } else {
            local int pos = startof(r.Alignment.varStart);
            switch (r.fieldType) {
                case Bool_tid:
                    WriteBOOL(r.data, s); break;
		        case S16_tid:
                    WriteShort(pos, Atoi(s)); break;
		        case Object_tid:
		        case UserData_tid:
                case Size_tid:
		        case S32_tid:
                    WriteInt(pos, Atoi(s)); break;
		        case S64_tid:
                    WriteInt64(pos, Atoi(s)); break;
		        case S8_tid:
                    WriteByte(pos, Atoi(s)); break;
		        case U16_tid:
                    WriteUShort(pos, Atoi(s)); break;
		        case U32_tid:
                    WriteUInt(pos, Atoi(s)); break;
		        case U64_tid:
                    WriteUInt64(pos, Atoi(s)); break;
                case F32_tid:
                    WriteFloat(pos, Atof(s)); break;
                case String_tid:
                case Resource_tid:
                    WriteRSZString(r, s);
                    break;
                case Vec2_tid:
                case Range_tid:
                case Float2_tid:
                case Point_tid:
                    WriteRSZArray(r, s, 2, 4);
                    break;
                case Vec3_tid:
                case Float3_tid:
                    WriteRSZArray(r, s, 3, 4);
                    break;
                case Vec4_tid:
                case Float4_tid:
                case Quaternion_tid:
                    WriteRSZArray(r, s, 4, 4);
                    break;
                case AABB_tid:
                    WriteRSZArray(r, s, 8, 4);
                    break;
                case Mat4_tid:
                    WriteRSZArray(r, s, 16, 4);
                    break;
                case Guid_tid:
                case GameObjectRef_tid:
                case Uri_tid:
                    WriterGuid(r.data, (string)s);
                    break;
                case Data_tid:
                case ukn_type:
                    s = Lower(s);
                    if (exists(r.data) && r.elementSize == 1) {
                        if (s == "true") {
                            r.data = 1;
                        } else if (s == "false") {
                            r.data = 0;
                        } else r.data = Atoi(s);
                    } else if (exists(r.ObjectIndex) || exists(r.data_As_Int) || exists(r.data_As_Float)) {
                        
                        if (exists(r.data_As_Int)) {
                            WriteFloat(startof(r.Alignment.varStart), Atof(s));
                        } else {
                            WriteInt(startof(r.Alignment.varStart), Atoi(s));
                        }
                    } else if (exists(r.size) || find((wstring)r.fieldDataType, "tring") != -1) {
        	            WriteRSZString(r, s);
                    } else if (r.fieldDataType == "Vec4") {
                        WriteRSZArray(r, s, 4, 4);
                    }
                    break;
                default:
                    break;
            }
        }
    }

    void WriteRSZArray(RSZVariable &r, wstring array, uint count, uint elementSize) {
        local uint q; 
        local float outArr[count];
        local string fmtString;
        if (array[0] == 91)
            fmtString += "[";
        if (find(array, ",") == -1) {
            for (q=0; q<count-1; q++)
                fmtString += "%g ";
            fmtString += "%g";
        } else {
            for (q=0; q<count-1; q++)
                fmtString += "%g,";
            fmtString += "%g";
        }
        if (count == 2)
            SScanf(array, fmtString, r.data[0], r.data[1]);
        else if (count == 3)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2]);
        else if (count == 4)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2], r.data[3]);
        else if (count == 8)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7]);
        else if (count == 16)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10],  r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
    }

typedef struct {
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else lvl = getLevel(FTell());
    local int idx <hidden=true> = i;
    
    if (!exists(parentof(parentof(this)).rawData) && idx >= RSZFile[lvl].RSZHeader.instanceCount)
        for (o=1;o<RSZFile[lvl].RSZHeader.instanceCount;o++)
            if (startof(RSZFile[lvl].Data.RawData.RSZ[o]) == startof(this)) 
                { idx = o; break; }
    if (exists(parentof(this).ObjectIndex) ) {
        idx = parentof(this).ObjectIndex;  
    } else if (exists(parentof(this).RSZIdx) )
        idx = parentof(this).RSZIdx;
    
    if (!IsInitialized() || (finished && idx && GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF) ) { //|| GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF
        //Printf("Not initialized at %u", FTell());
        if (!noRetry) {
            ParseJson(JsonPath);  Printf("\nParsing JSON %s\n", JsonPath);
            if (!IsInitialized() || (finished && idx && GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF) )
                noRetry = TRUE;
        }
    }
    
    local string name <hidden=true> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.HashName;
    local wstring title <hidden=true>; 
    local wstring secondTitle <hidden=true>;
    local uint hash <hidden=true, format=hex> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash;
    local ubyte isUserData <hidden=true>;

    if (exists(RSZFile[lvl].RSZUserDataInfos))
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].typeId.Hash == hash) 
                { isUserData = TRUE; break; }

    if (name == "Unknown Class!"){
        Printf("Hash %X not found in JSON!\n", hash);
        byte skip <hidden=true>;
    } else if (hash == 0xF767C93F) { //"via.physics.UserData"
        for (j=idx+1; j<RSZFile[lvl].RSZHeader.instanceCount; j++) {
            if (finished && RSZFile[lvl].InstanceInfos.instanceInfo[j].typeId.Hash == 0xF767C93F ) {
                local uint ObjectIndex <hidden=true> = j - 1;
                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]));
                if (!exists(parentof(parentof(this)).idx) || (parentof(parentof(this)).idx != j - 1)) {
                    struct RSZInstance RSZ <size=SizeRSZInstance>;
                    checkUseSpacers();
                }
                FSeek(startof(this));
                break;
            }
            if (j > 100)
                break;
        }
    } else if (idx && GetFieldCount(hash) == 0xFFFFFFFF) { 
        Printf("Class %u %s not detected in JSON!\n", hash, name);
        byte skip <hidden=true>;
    } else if (isUserData) {
        byte skipFileData <hidden=true>;
        local short userDataIdx <hidden=true> = -1;
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == RSZ.idx) { 
                userDataIdx = j;
                if (RSZVersion != "RE2" && RSZVersion != "DMC5") {
                    local wstring userDataPath <hidden=true> = RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String; 
                    local wstring fullPath <hidden=true>;
                    ReadRSZPath(userDataPath);
                    if (title == "")
                        title = userDataPath;
                }
                break; 
            }
    } else if (idx && !FEof()) {
        local int z <hidden=true>, FieldType <hidden=true>, IsList <hidden=true>;
        for (z = 0; z < GetFieldCount(hash); z++) {
            FieldType = (TypeIDs)GetFieldType(hash, z);
            IsList = GetFieldArrayState(hash, z);
            if (IsList)
                FSeek(getAlignedOffset(FTell(), 4));
            else
                FSeek(getAlignedOffset(FTell(), GetFieldAlignment(hash, z)));
            !broken ? SetForeColor(cGreen) : SetForeColor(cYellow);
            if (FTell() + 4 <= FileSize() && ReadUInt(FTell()) != 0 && FieldType == Object_tid || FieldType == UserData_tid || FieldType == ukn_type 
            || (FieldType == Data_tid && GetFieldSize(hash, z) == 4 && detectedObject(FTell() + (IsList * 4)))) {
                struct RSZVariable var(hash, z);
            } else {
                struct RSZVariable var(hash, z);
            }
            SetForeColor(cNone);
        }
    } 
    if (FEof())
        i = RSZHeader.instanceCount; 
  
    if (PrintClasses && idx) {
        local int foundHash = false, zz;
        for (zz=0; zz<hashesLen; zz++)
            if (uniqueHashes[zz] == hash)
                foundHash = true;
        if (foundHash == false) {
            PrintRSZClass(GetRSZClassName(hash));
            uniqueHashes[hashesLen] = hash;
            hashesLen++;
        }
    }
    
    if (title == "") 
        if (secondTitle != "")
            title = secondTitle;
        else if (exists(var[0]))
            title = ReadRSZVariable(var[0]);
    
    if (FTell() - startof(this)  == 0) { 
        ubyte skipFileData <hidden=true>;
    }
    if (FTell()==startof(this))
        Printf(name + "\n");
} Instance;

typedef Instance RSZInstance <name=ReadRSZInstanceName, read=ReadRSZInstance, write=WriteRSZInstance>;

    wstring ReadRSZInstanceName(RSZInstance &r) { 
        local ushort lvl <hidden=true>;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else lvl = getLevel(startof(r));
        local string s;
        
        if (exists(r.skip) || exists(parentof(r).ObjectIndex) && exists(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex].skip))
            s = "*";

        if (exists(parentof(r).ObjectIndex) && parentof(r).ObjectIndex >= 0 && parentof(r).ObjectIndex >= 0 && parentof(r).ObjectIndex <= (int)(sizeof(RSZFile[lvl].ObjectTable) / 4)) {
            lvl = parentof(r).lvl;
            SPrintf(s, "%s[%u] ", RSZFile[lvl].InstanceInfos.instanceInfo[parentof(r).ObjectIndex].typeId.HashName, parentof(r).ObjectIndex);
        } else if (exists(r.idx)) {
            if (exists(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx]))
                s += RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.HashName;
            else if (exists(r.name))
                s += r.name;
            if (!exists(parentof(r).rawData))
                SPrintf(s, "%s[%u] ", s, r.idx);
        } else if (exists(RSZFile[lvl].RSZHeader)) {
            for (o=1;o<RSZFile[lvl].RSZHeader.instanceCount;o++) {
                if (startof(RSZFile[lvl].Data.RawData.RSZ[o]) == startof(r) && !exists(RSZFile[lvl].Data.RawData.RSZ[o].skipFileData) ) {  //
                    SPrintf(s, "%s[%u] ", RSZFile[lvl].Data.RawData.RSZ[o].name, o);
                    break; 
                }
            }
        }
        return s;
    }

    int SizeRSZInstance(RSZInstance &r) { 
        local ushort lvl;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else 
            lvl = getLevel(startof(r));
        
        if (exists(parentof(r).ObjectIndex))
            return sizeof(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex]); 

        for (k=0; k<RSZFile[lvl].RSZHeader.instanceCount; k++)
            if (exists(RSZFile[lvl].Data.RawData.RSZ[k]) && startof(RSZFile[lvl].Data.RawData.RSZ[k]) == startof(r) 
            && (!exists(RSZFile[lvl].Data.RawData.RSZ[k+1]) || startof(RSZFile[lvl].Data.RawData.RSZ[k+1]) != startof(r)) ) //WTF
                if (sizeof(RSZFile[lvl].Data.RawData.RSZ[k]) != 0)
                    return sizeof(RSZFile[lvl].Data.RawData.RSZ[k]); 

        if (exists(parentof(r).tempN))
            return (sizeof(RSZFile[lvl].Data.RawData.RSZ[i]));
    
        return 1;
    }

    wstring ReadRSZInstance(RSZInstance &r) {
        local ushort lvl;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else lvl = getLevel(startof(r));
        if (exists(r.skip) || (exists(parentof(r).ObjectIndex) && exists(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex].skip))) {
            return ReadHash(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.Hash);
        } else if (exists(r.skipFileData)) {
            for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
                if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == r.idx)
                    return RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String;
        } else if (exists(r.title) ) {
            return r.title;
        } else if (exists(parentof(r).ObjectIndex) ) {
            return RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex].title;
        } else {
            for (o=1;o<RSZFile[lvl].RSZHeader.instanceCount;o++) 
                if (startof(RSZFile[lvl].Data.RawData.RSZ[o]) == startof(r) && !exists(RSZFile[lvl].Data.RawData.RSZ[o].skipFileData))
                    return RSZFile[lvl].Data.RawData.RSZ[o].title;
        } return "";
    }

    void WriteRSZInstance(RSZInstance &r, wstring s) { 
        if (exists(r.fullPath) && s == " ")
            FileOpener(r.title);
        else {
            local int w;
            local string oldVar = ReadRSZInstance(r);
            while(exists(r.var[w])) {
                if (ReadRSZVariable(r.var[w]) == oldVar) {
                    WriteRSZVariable(r.var[w], s);
                    r.title = ReadRSZVariable(r.var[w]);
                    break;   
                }
                w++;
            }
        }
    }

//================= 
//Other typedefs:

typedef struct(int64 atAddress, int64 addOffset, ubyte isAbsolute) {
    if (!isAbsolute) {
        if (atAddress > -1)
            FSeek(atAddress);
        uint64 strOffset;
        FSeek(strOffset + addOffset);
    } else 
        FSeek(atAddress + addOffset);
    wstring String <open=suppress>;
    if (find(String, "/") != -1 && FileNameGetExtension(String) != ".json") {
        local wstring fullPath <open=suppress, hidden=true>;
        ReadRSZPath(String);
    }
    if (exists(strOffset)) {
        if (atAddress == -1 || startof(this) == atAddress)
            FSeek(startof(strOffset)+8);
        else 
            FSeek(startof(this)+1);
    }
    
} StringRead <fgcolor=cNone, read=ReadStringRead, write=WriteStringRead>;

    wstring ReadStringRead(StringRead &st) { return st.String; }
    
    void WriteStringRead(StringRead &st, string s) { 
        if (s == " " && exists(st.fullPath) && st.fullPath != "")
            FileOpener(st.fullPath);
        else {
            char buffer[sizeof(st.String)];
            WriteBytes(buffer, startof(st.String), sizeof(st.String)); //write 0s
            st.String = s; 
        }
    }
    
    string PrefabName(StringRead &p) {
        if (exists(p.OpenFile))
            return "Prefab (Exists)";
        return "Prefab";
    }

typedef struct {
	uint32 Hash;
	local string HashName = ReadHashName(Hash);
} HASH <read=ReadHASH>;

    string ReadHASH (HASH &h) {
	    return ReadHash(h.Hash);
    }
    
    string ReadHash(uint32 &input) {
	    string s;
	    SPrintf(s, "%X", input);
	    return s;
    }
    
    string ReadHashName(uint32 &input) {
        if (!IsInitialized())
            ParseJson(JsonPath);
        return GetRSZClassName(input);
    }

    string ReadHASHWithName(HASH &h) {
        return ReadHash(h.Hash) + " -- " +  GetRSZClassName(h.Hash);
    }

typedef struct {
    wstring str;
} WSTRING <optimize=false, read=ReadWSTRING, write=WriteWSTRING>;
    wstring ReadWSTRING(WSTRING &input) { return input.str; }
    void WriteWSTRING(WSTRING &input, wstring s) {
        for (k = 0; k < sizeof(input.str)/2; k++)
            input.str[k] = 0;
        input.str = s;
    }

typedef struct {
    FSkip(16);
} SUBPROP4 <optimize=false>;

typedef struct {
    uint32 nameHash, type;
    switch (type) {
        case 6: uint32 value; break;
        case 7: int32 value; break;
        case 7: float value; break;
        case 20: uint64 hashOffs; break;
        default:
            local uint64 test <hidden=true> = ReadUInt64(FTell());
            if (test > 0 && test <= FileSize()-16 && test > FTell()) {
                uint64 hashOffs; 
            } else if (detectedFloat(FTell())) {
                float value;
            } else { uint value; }
            if (exists(value))
                local float hiddenValue <hidden=true> = value;
            break;
    }
    if (exists(hashOffs)) {
        FSeek(start + hashOffs);
        rGUID value;
    }
    FSeek(startof(nameHash) + 16);
} HASHPROP <read=ReadHASHPROP, optimize=false>;

    string ReadHASHPROP (HASHPROP &input) {
        string s = "";
        if (exists(input.hiddenValue))
            SPrintf(s, "%g", input.hiddenValue);
        return s;
    }

typedef struct {
    ushort propCount, B, C; //skipToNextLine();
    skipToNextLine();
    uint64 offs1, offs2;
    if (propCount > 0) {
        if (offs1 <= FileSize()) {
            FSeek(start + offs1);
            string name; //SUBPROP3 SubProp3;
        }
        if (offs2 <= FileSize()) {
            FSeek(start + offs2);
            if (ReadUShort(FTell()+2) != 0)
                HASHPROP Value;
            else
                SUBPROP4 SubProp4;
        }
    }
    FSeek(startof(this)+32);
} SUBPROP2 <optimize=false>;

typedef struct {
    uint64 nameOffset;
    uint64 dataOffset;
    local int pos <hidden=true> = FTell();
    FSeek(start + nameOffset);
    
    if (nameOffset > 0 && nameOffset <= FileSize())
        string name <open=suppress>;
    FSeek(start + dataOffset);
    
    if (dataOffset > 0 && dataOffset + start <= FileSize())
        HASHPROP Hashed_Value;

    if (exists(Hashed_Value.hiddenValue))
        local float hiddenValue <hidden=true> = Hashed_Value.hiddenValue;
    FSeek(pos);
    FSkip(16);
    
} NODE <name=ReadNODENAME, read=ReadNODE, optimize=false>;

    string ReadNODENAME (NODE &input) {
        if (exists(input.name))
            return input.name;
        return "";
    }

    string ReadNODE (NODE &input) {
        string s = "";
        if (exists(input.hiddenValue))
            SPrintf(s, "%g", input.hiddenValue);
        return s;
    }
typedef struct {
    uint32 ukn, ukn;
    uint16 uknShort, uknShort2;
    uint32 ukn2;
    if (uknShort)
        uint ukn3[4];
    
} OFFSET2_DATA;

typedef struct {
    uint64 nodesOffset;
    uint64 offset2;
    ushort propCount, B, C; //skipToNextLine();
    if (propCount > 0) {
        if (nodesOffset > 0) {
            FSeek(start + nodesOffset);
            if (ReadUInt(FTell()) <= FileSize())
                struct NODE Node[propCount];
            else 
                string name <open=suppress>;
        }
        if (offset2 > 0) {
            FSeek(start + offset2);
            OFFSET2_DATA Offset2_Data;
        }
    }
} PROP <read=ReadProp, optimize=false>;  
    
    string ReadProp (PROP &input) {
        if (exists(input.name))
            return input.name;
        return "";
    }


typedef struct {
    rGUID Guid;
    uint64 nameOffset;
    FSeek(start + nameOffset);
    wstring name <open=suppress>;
    FSeek(startof(nameOffset) + 8);
    uint64 floatOffset, uknOffset;
    uint type : 24;
    uint numBits : 8;
    uint nameHash;

    if (floatOffset > 0) { //!didSeek && 
        FSeek(start + floatOffset);
        
        if ((numBits / 32) <= 1) {
            float Value_As_Float;
            FSeek(startof(Value_As_Float));
            int Value_As_Int;
        } else {
            float Value_As_Float[(numBits / 32)];
            FSeek(startof(Value_As_Float[0]));
            int Value_As_Int[(numBits / 32)];
        }
    }
    if (uknOffset > 0) {
        FSeek(start + uknOffset);
        PROP VarData;           
    }
    FSeek(startof(nameHash) + 4);
} UVARIABLE <optimize=false, name=ReadUVariableName, read=ReadUVariable, write=WriteUVariable>;

    wstring ReadUVariableName(UVARIABLE &input) { if (exists(input.VarData)) return (input.name + "*"); return input.name; }

    void WriteUVariable(UVARIABLE &input, string s) { WriteUInt(startof(input.Value_As_Int), Atoi(s)); }

    wstring ReadUVariable(UVARIABLE &input) {
        string s = "";
        if (exists(input.Value_As_Float)) {
            if (detectedFloat(startof(input.Value_As_Float)))
                SPrintf(s, "%g", input.Value_As_Float[0]);
            else
                SPrintf(s, "%u", input.Value_As_Int[0]); 
        }
        return (s);
    }

typedef struct {
    
    if (exists(parentof(this).mNamePool))
        local int start <hidden=false> = startof(parentof(this));
    else 
        local int start = startof(this);
    
    struct {
        uint version;
        uint magic;
        uint64 stringsOffset;
        uint64 dataOffset;
        uint64 embedsInfoOffset;
        uint64 hashInfoOffset;
        uint64 ukn;
        uint UVARhash;
        ushort variableCount;
        ushort embedCount;
        //if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
        //    FSeek(getAlignedOffset(FTell(),16));
        //    uint64 uknOffs, uknOffs, uknOffs, uknOffs;
        //}
    } Header;

    if (Header.variableCount && Header.dataOffset+start > startof(this)) { 
        FSeek(start + Header.dataOffset);
        struct {
            for (j=0;j<Header.variableCount;j++) {
                struct UVARIABLE Var;
            }
        } Data;
    }
    if (Header.stringsOffset) { 
        FSeek(start + Header.stringsOffset);
        struct {
            if (Header.variableCount)
                WSTRING str[Header.variableCount] <open=suppress>;
            else while (detectedString(FTell()))
                WSTRING str <open=suppress>;
        } Strings;
    }
    if (Header.embedCount && Header.embedsInfoOffset) {
        FSeek(start + Header.embedsInfoOffset);
        uint64 embedOffsets[Header.embedCount];
        for (i=0; i<Header.embedCount; i++) {
            FSeek(start + embedOffsets[i]);
            struct UVAR UVAR_File;
            start = startof(parentof(this));
        }
    }
    
    if (Header.variableCount && Header.hashInfoOffset+start > startof(this)) {
        struct {
            FSeek(start + Header.hashInfoOffset);
            uint64 HashDataOffsets[4];
            FSeek(start + HashDataOffsets[0]);
            struct rGUID GUIDs[Header.variableCount];
            FSeek(start + HashDataOffsets[1]);
            uint dataHashMap[Header.variableCount];
            FSeek(start + HashDataOffsets[2]);
            uint nameHashes[Header.variableCount];
            FSeek(start + HashDataOffsets[3]);
            uint nameHashMap[Header.variableCount];
        } HashData;
    }

} UVAR <read=ReadUVAR>;

    wstring ReadUVAR (UVAR &input) {
        if (exists(input.Data.Var[0]))
            return input.Data.Var[0].name;
        return "";
    }

struct OBJECTID(int lv) {
    int id;
    local int level <hidden=true> = lv;
};

typedef OBJECTID ObjectId <read=ReadObjectIdTitle, write=WriteObjectId>;

    wstring ReadObjectIdName(ObjectId &o) {
        local string s;
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) && exists(RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]])) {
            s = RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]].typeId.HashName;
            if (s != "")
                SPrintf(s, "%s[%i]", s, RSZFile[o.level].ObjectTable[o.id]);
        }
        return s;
    }

    wstring ReadObjectId(ObjectId &o) {
        local string s;
        SPrintf(s, "%i", o.id);
        return s;
    }

    void WriteObjectId(ObjectId &o, string s) {
        o.id = Atoi(s);
    } 

    wstring ReadObjectIdTitle(ObjectId &o) {
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) 
        && exists(RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]])) {
            local string s = ReadObjectId(o) + " -- " + RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]].title;
            return s;
        }
        return "";
    }

struct fakeGameObject {
    FSeek(getAlignedOffset(FTell(), 4));
    uint size0;
    if (size0 && FTell()+size0*2 <= FileSize())
        wchar_t name[size0];
    FSeek(getAlignedOffset(FTell(), 4));
    uint size1;
    if (size1 && FTell()+size1*2 <= FileSize())
        wchar_t tag[size1];
    FSeek(getAlignedOffset(FTell()+2, 4));
    uint timeScale;
};


struct {
    local uint magic <hidden=true> = ReadUInt(FTell());
    if (ReadUShort(2) == 0)
        magic = ReadUInt(FTell()+4);
	
    if (magic == 4343376) {//50 46 42 00 PFB 
        uint signature;
	    int infoCount;
        int resourceCount;
        int grefInfoCount;
        
        if (RSZVersion != "DMC5" && RSZVersion != "RE2") {
            int userdataCount;
            int grefInfoTbl;
            int grefInfoTbl2;
            FSkip(4);
        }

	    uint64 resourceInfoTbl;
	    uint64 userdataInfoTbl;
	    uint64 dataOffset;
    }

    if (magic == 5395285) { //USR 
        uint signature;
        int resourceCount;
	    int infoCount;
        int userdataCount;
	    uint64 resourceInfoTbl;
	    uint64 userdataInfoTbl;
	    uint64 dataOffset;
    }
    
    if (magic == 1280262994) {//52 43 4F 4C RCOL
        uint signature;
        int numGroups;
        int numShapes;
        int numUserData;
        int numRequestSets;
        uint maxRequestSetId;
        if (RSZVersion == "RE8") {
            int numIgnoreTags;
            int numAutoGenerateJoints;
        }
        uint userDataSize;
        uint status;
        if (RSZVersion == "RE3") {
            uint64 uknA; 
            uint64 uknB; 
        }
        uint64 groupsPtrTbl;
        uint64 dataOffset <name="userDataStreamPtr">;
        uint64 requestSetTbl; 
        if (RSZVersion == "RE8") {
            uint64 ignoreTagTbl;
            uint64 autoGenerateJointDescTbl;
        }
    }
    if (magic == 5129043) { // 53 43 4E 00 SCN
        uint signature;
        int infoCount;
        int resourceCount;
        int folderCount;
        if (RSZVersion == "DMC5" && RSZVersion != "RE2") {
            int userdataCount;
            int prefabCount;
        } else {
            int prefabCount;
            int userdataCount;
        }

        uint64 folderInfoTbl;
        uint64 resourceInfoTbl;
        uint64 prefabInfoTbl;
        uint64 userdataInfoTbl;
        uint64 dataOffset;
    }
    
    if (ReadUInt(0) == 1414940738 || magic == 846423661) { //BHVT or mfs2
        if (magic == 846423661) { //mfs2
            uint version;
            uint signature;
            FSkip(8);
            uint64 treeData;
            uint64 transitionMapTbl;
            uint64 transitionDataTbl;
            uint64 treeInfoPtr;
            uint transitionMapCount;
            uint transitionDataCount;
            uint startTransitionDataIndex;

            FSeek(treeInfoPtr);
            uint treeDataSize;

            FSeek(transitionMapTbl);
            if (transitionMapCount) 
                struct TRANSITIONMAP {
                    uint transitionId;
                    int dataIndex;
                } TransitionMap[transitionMapCount];

            FSeek(transitionDataTbl);
            if (transitionDataCount) 
                struct TRANSITIONDATA {
                    int id;
                    uint32 endType : 4;
                    uint32 interpolationMode : 4;
                    uint32 interpolationCurve : 4;
                    uint32 prevMoveToEnd : 1;
                    uint32 startType : 4;
                    uint32 elapsedTimeZero : 1;
                    uint32 contOnLayer : 1;
                    uint32 contOnLayerInterpCurve : 4;
                    uint32 emptyBits : 9;
                    float exitFrame;
                    float startFrame;
                    float interpolationFrame;
                    if (RSZVersion != "RE2" && RSZVersion != "DMC5" ) {
                        float contOnLayerSpeed;
                        float contOnLayerTimeout;
                        uint16 contOnLayerNo;
                        uint16 contOnLayerJointMaskId;
                    }
                    FSkip(4);
                } TransitionData[transitionDataCount] <optimize=true>;

            FSeek(treeData);
        }
        struct {
            uint BHVT;
            FSkip(4);
            uint64 mSourceTreePtr;
            uint64 mNodes;
            uint64 mSelectors;
            uint64 mSelectorCallers;
            uint64 mActions;
            uint64 mConditions;
            uint64 mTransitionEvents;
            uint64 mExpressionTreeConditions;
            uint64 mSelectorValidNodeBuffer;
            uint64 mDelayedActions;
            uint64 mDelayedConditions;
            uint64 mDelayedTransitionEvents;
            uint64 mNamePoolOffs;
            uint64 mPathNamePoolOffs;
            if (RSZVersion != "RE2" && RSZVersion != "DMC5")
                uint64 mUserDataPathNamePoolOffs;
            uint64 mUserVariableDataPtr;//uint64 mRootNodeIndexOffs;
            uint64 mReferenceTreeCountOffs;
            uint64 mTreeIDOffs;
            FSeek(mTreeIDOffs+startof(this));
            unsigned int mTreeID;
            FSeek(mNamePoolOffs+startof(this));
            struct BHVTStringPool{
                if (exists(mPathNamePool))
                    uint numPaths;
                uint poolSize;
                while (FTell() < startof(this)+(poolSize*2)) {
                    struct StringRead String(FTell(), 0, true) <read=ReadBHVTStringName>;
                    if (sizeof(String) == 0) 
                        break;
                }
            } mNamePool;
            FSeek(mPathNamePoolOffs+startof(this));
            struct BHVTStringPool mPathNamePool;
            if (exists(mUserDataPathNamePoolOffs)) {
                FSeek(mUserDataPathNamePoolOffs+startof(this));
                struct BHVTStringPool mUserDataPathNamePool;
            }
            if (true) {
                FSeek(mUserVariableDataPtr+startof(this));
                struct UVAR Uvar;
                FSeek(mReferenceTreeCountOffs+startof(this));
    
                unsigned int mReferenceTreeCount;
                if (FTell()+16 <= FileSize())
                    if (ReadUInt(FTell()+16) == 1918989941) {
                        uint64 Uvar2Offset;
                        FSeek(Uvar2Offset+startof(this));
                        struct UVAR Uvar2;
                    } else {
                        uint64 thisOffset;
                    }
            }
            FSeek(mSourceTreePtr+startof(this));

            /*
                This BHVT nodes stuff is very complicated. I'm not sure how the structs are supposed to be, it's always wrong.
                Any help figuring out how to make the Node structs work and align with their string-offsets in each one would be greatly appreciated.
            */

            /* //old way
            void ReadHashList(int size) {
                local uint sz = size;
                local uint Count = ReadUInt(FTell());
                
                if (Count && Count < Header.BHVT.itemCount && FTell() + Count * (sz * 4) <= FileSize()) {
                    struct {
                        switch (1) {
                            case 1:
                                struct BHVTHash Hash0[Count];
                                break;
                            case 2:
                                struct BHVTHash Hash0[Count];
                                struct BHVTHash Hash1[Count];
                                break;
                            default:
                                struct BHVTHash Hash0[Count];
                                struct BHVTHash Hash1[Count];
                                struct BHVTHash Hash2[Count];
                                break;
                        }
                    } HashesList;
                } else
                    struct BHVTHash Hash;    
            }*/

            /*
            struct HashList { 
                uint count; 
                if (count && count < Header.BHVT.itemCount && FTell() + count * 4 <= FileSize()) {
                    
                }
            }; 
            struct DoubleHashList { 
                uint count; 
                if (count && count < Header.BHVT.itemCount && FTell() + count * 8 <= FileSize()) {
                    struct BHVTHash Hash(0)[count]; 
                    struct BHVTHash HashTwo(0)[count]; 
                }
            }; 
            struct TripleHashList { 
                local uint Count <hidden=true>; 
                if (Count && Count < Header.BHVT.itemCount && FTell() + Count * 12 <= FileSize()) {
                    uint count;
                    struct BHVTHash Hashes(0)[count]; 
                    struct BHVTHash Ints(0)[count]; 
                    struct BHVTHash Flags(0)[count]; 
                } else struct BHVTHash Hash(0);
            };
            */
            
            uint itemCount; //int a,b,c,d;

            local int lastThirtyFive <hidden=true> = FTell();
            struct {
                int A, B, C;
                int D;
                uint E;
                local uint z <hidden=true>;
                struct BHVTHash NodesList(3);
                int unknown[5];
                int thirtyFive;
                lastThirtyFive = FTell();
                int NameHash, NameHash <format=hex>;
                int ukn, ukn;
                ushort ukn;                       
                int ID : 16;
                int ukn : 16;
                struct BHVTHash ConditionID(0);
                struct BHVTHash NodeID(0);
                int hash3;
                //int hash4;       
            } RootNode <hidden=false>; 
            
            if (ReadBHVTHeader)
                struct BHVTNODES {
                    for (o=1; o<itemCount; o++) {
                        if (FTell()+4 <= FileSize()) {
                            SetForeColor(cAqua);
                            struct BHVTNode {     
                                local int index <hidden=true> = o;                            
                                if (RSZVersion != "RE2")
                                    if (ReadUInt(FTell()))
                                        int ID;
                                    else int ID;
                                struct BHVTHash hashB(0);
                                struct BHVTHash hashC(0);
                                struct BHVTHash NodeID(0);
                                //struct BHVTHash hashD(0) <name="Node ID #2">; 
                                int StringID;
                                struct BHVTHash hashE(0);
                                struct BHVTHash hashF(0);
                                if (ReadUInt(FTell()))
                                    struct BHVTHash HashList3x_B(3) <open=true>;
                                else struct BHVTHash HashList3x_B(3);
                                if (true) {
                                    struct BHVTHash hashSID1(0);//int StringID;
                                    struct BHVTHash hashH(0);
                                    struct BHVTHash hashI(0);
                                    if (ReadUInt(FTell()))
                                        struct BHVTHash Actions(3) <open=true>;
                                    else struct BHVTHash Actions(3);
                                    //struct BHVTHash hashJ(0);

                                    if (RSZVersion == "RE3") {
                                        struct BHVTHash A(0);
                                        struct BHVTHash B(0);
                                        struct BHVTHash C(2);
                                        struct BHVTHash D(0);
                                    }
                                    if (ReadUInt(0) != 1414940738 && ReadUInt(FTell()) != 35) { //the template will look for "35" in the hex to re-align with each node, until this is figured out
                                        SetForeColor(cNone);
                                        ubyte blank <hidden=true, bgcolor=cRed>;
                                        FSeek(lastThirtyFive);
                                        while(FTell() < RSZOffset && ReadUShort(FTell()) != 35) 
                                            FSkip(2);
                                        if (FTell() >= RSZOffset)
                                            break;
                                    }
                                    lastThirtyFive = FTell()+4;
                                    int thirtyFive;
                                    int InstanceID, InstanceID <format=hex>;
                                    struct BHVTHash hashK(0);
                                    short uknShort;
                                    if (ReadUInt(FTell()))
                                        struct BHVTHash HashList2x_B(2) <open=true>; 
                                    else struct BHVTHash HashList2x_B(2); 
                                }
                                
                                local wstring name <hidden=false> = ReadWString(startof(mNamePool)+4+(StringID[0]*2));
                                if (detectedString(startof(mNamePool)+4+(StringID[0]*2)))
                                    name = ReadWString(startof(mNamePool)+4+(StringID[0]*2));
                                //else if (detectedString(startof(mNamePool)+4+(StringID[1]*2)))
                                //    name = ReadWString(startof(mNamePool)+4+(StringID[1]*2));
                                
                            } Node <read=ReadBHVTNode, optimize=false>;
                        }
                    }
                } Nodes;// <size=SizeNodes>; 
            FSeek(startof(mTreeIDOffs)+8);
        } BHVT;// <size=152>;
    }
}Header;

    int SizeNodes (BHVTNODES &b) { return RSZOffset - startof(b); }

    wstring ReadBHVTNode(BHVTNode &u) { 
        if (exists(Header.BHVT.mNamePool.String[u.index])) {
            local wstring strRead = ReadStringRead(Header.BHVT.mNamePool.String[u.index]);
            if ( !exists(u.name) || u.name != strRead )
                return "*" + strRead;
            return strRead;
        }
        if (exists(u.name)) 
            return u.name; 
        return "";
    }

    wstring ReadBHVTStringName(StringRead &str) { 
        string s; 
        SPrintf(s, "%X -- ", ((startof(str) - startof(parentof(str))) - 4) / 2); 
        return s + ReadStringRead(str); 
    } 

//tests
int detectHashListSize(int64 tell) {
    local int pos = FTell();
    //local int start = tell;
    FSeek(tell);
    //while (ReadByte(FTell()-1) != 0)
    //    FSkip(-1);
    //start = FTell();// - (FTell() % 4);
    if (ReadUShort(tell+2) == 00) {
        local int count = ReadInt();
        FSkip(4);
        while (ReadByte() != 0)
            FSkip(1);
        local int numElements = (int)((FTell() - tell + 4)/4);
        if (numElements == count)
            return count;
        else tell += 4;
    } else {
        while (ReadByte() != 0)
            FSkip(1);
    }
    local int ret = (int)((FTell() - tell)/4);
    FSeek(pos);
    return ret;
}


int detectedHash(int tell) {
    local ubyte a = ReadUByte(tell);
    local ubyte b = ReadUByte(tell+1);
    local ubyte c = ReadUByte(tell+2);
    local ubyte d = ReadUByte(tell+3);
    return ((a+b+c+d == 0) || (a+b+c+d == 1020) || (a && b && c && d)); //if all zeros or all not-zeros, it may be a hash
}

struct BHVTHASH(int listSz) {
    //local int test = detectHashListSize(FTell());
    local int count <hidden=true> = ReadInt(FTell());
    local int listSize = listSz;
    local int hash <hidden=true>;
    local byte doExit <hidden=true>;
    local int valueStart <hidden=true>;
    local int multiplier = listSize;
    if (count < Header.BHVT.itemCount && count > 0 ) { //listSize > 0 && 
        int Count;
        if (listSize == 0) {
            listSize = Count;
            multiplier = 1;
        }
    } else {
        count = 1;
        if (listSize == 0)
            multiplier = 1;
    }
    
    
    local int n <hidden=true>;
    for (n=0; n<multiplier*count; n++) {
        if (!detectedHash(FTell())) {
            FSkip( -(FTell() - (startof(this) + ((exists(Count)*4)))) % (multiplier * 4) );
            break;
        }
        if (listSize != 0) {
            struct BHVTHash Hash(0); 
            hash = Hash.Hash;
        } else {
            int Hash; 
            hash = Hash;
        }
        /*
        if (hash != 0 && hash != -1 && ReadUShort(startof(this)+2) != 0 
        && (!exists(parentof(this).count) || parentof(this).count < Header.BHVT.itemCount) ) { //  
            o = 0;
            valueStart = 0;
            while (exists(Header.BHVT.Nodes.Node[o].hashD) ) {
                if (hash == ReadUInt(startof(Header.BHVT.Nodes.Node[o].NodeID))) 
                    valueStart = startof(Header.BHVT.Nodes.Node[o].NodeID);
                else if (hash == ReadUInt(startof(Header.BHVT.Nodes.Node[o].hashD))) 
                    valueStart = startof(Header.BHVT.Nodes.Node[o].hashD);
                if (valueStart) {
                    FSeek(startof(Header.BHVT.Nodes.Node[o]));
                    if (startof(this) != valueStart) 
                        struct BHVTNode ChildNode <open=true, read=ReadBHVTNode>;
                    //doExit = true;
                    break;
                }
                o++;
            }
            if (!doExit) {
                j=0;
                while(exists(RSZFile[j])) { //for (j=0; j<level; j++) {
                    i = 0;
                    while (exists(RSZFile[j].Data.RawData.RSZ[i])) {
                        k = 0;
                        while(exists(RSZFile[j].Data.RawData.RSZ[i].var[k])) {
                            if (exists(RSZFile[j].Data.RawData.RSZ[i].var[k].data) 
                            && (ReadInt(startof(RSZFile[j].Data.RawData.RSZ[i].var[k].Alignment.varStart)) == hash) ) { // || ReadInt(startof(RSZFile[j].Data.RawData.RSZ[i].var[k].Alignment.varStart)) == hash
                                FSeek(startof(RSZFile[j].Data.RawData.RSZ[i]));
                                struct RSZInstance RSZ <open=true>;
                                doExit = true;
                                break;
                            }
                            k++;
                        }
                        i++;
                        if (doExit) break;
                    }
                    if (doExit) break;
                    j++;
                }
            }
            FSeek(startof(Hash)+4);
        }
        */
        //if (Hash && Hash != -1 && !doExit)
        //    Printf("Tell: %u, Hash: %u\n", FTell()-4, Hash);
    }
};

typedef BHVTHASH BHVTHash <optimize=false, read=ReadBHVTHash, open=suppress>; //, name=ReadBHVTHashName //size=4, optimize=false, 

    wstring ReadBHVTHash(BHVTHash &h) { 
        if (exists(h.ChildNode.name)) 
            return h.ChildNode.name; 
        if (exists(h.RSZ)) 
            return h.RSZ.name; 
        string s; 
        if (exists(h.Hash.Hash))
            SPrintf(s, "%X\n", h.Hash.Hash);
        else if (exists(h.Hash)) 
            SPrintf(s, "%X\n", h.Hash);
        return s; 
    } 

    void WriteBHVTHash(BHVTHash &h, string s) { h.hash = Atoi(s); } 

    //wstring ReadBHVTHashName(BHVTHash &h) { if (exists(h.RSZ)) return h.RSZ.name; return ""; } 

typedef struct {
    HASH hash <read=ReadHASHWithName>;
    uint32 CRC;
    StringRead pathOffset(-1, 0, 0);
} UserDataInfo <name=ReadUserDataInfoName, read=ReadUserDataInfo>;

    string ReadUserDataInfo (UserDataInfo &u) { return u.pathOffset.String; }
    
    string ReadUserDataInfoName(UserDataInfo &u) { return u.hash.HashName; }

typedef struct {
    if (ReadInt(FTell()+4) != 0)
        wstring path; 
    else
        StringRead pathStr(-1, 0, 0);
} Resource_Info <name=ReadResourceInfoName, read=ReadResourceInfo, write=WriteResourceInfo>;

    string ReadResourceInfo(Resource_Info &r) { if (exists(r.path)) return r.path; return r.pathStr.String; }

    string ReadResourceInfoName(Resource_Info &r) { if (!exists(r.pathStr.OpenFile) && !exists(r.OpenFile)) return "*ResourceInfo"; return ""; }

    void WriteResourceInfo(Resource_Info &r, string s) { WriteStringRead(r.pathStr, s); }

if (Header.magic != 1280262994) { //no RCOL

    if (exists(Header.infoCount) && Header.infoCount) {
        if (Header.magic == 4343376)
	        struct GameObjectInfoPFB {
		        ObjectId id(0);
		        ObjectId parentId(0);
		        int componentCount;
	        } GameObjectInfos[Header.infoCount] <optimize=true, name=ReadGRefInfoPFBName, read=ReadGRefInfoPFB>;
        else 
            struct GameObjectInfo {
                rGUID Guid;
                ObjectId id(0);
                ObjectId parentId(0);
                ushort componentCount;
                short ukn;
                int prefabId;
            } GameObjectInfos [Header.infoCount] <optimize=true, name=ReadGRefInfoName, read=ReadGRefInfo>; 
    }

    if (exists(Header.folderCount) && Header.folderCount) {
        FSeek(Header.folderInfoTbl);
        struct {
            for (i=0; i<Header.folderCount; i++)
                struct FOLDERINFO {
                    local uint idx <hidden=true> = i;
                    ObjectId id(0);
                    ObjectId parentId(0);
                } FolderInfo <name=ReadFOLDERINFOName, read=ReadFOLDERINFO>;
        } FolderInfos;
    }
    
    if (exists(Header.userdataCount) && Header.userdataCount > 0 && (!exists(Header.userdataInfoTbl)  || Header.userdataInfoTbl > 0)) {
        FSeek(Header.userdataInfoTbl);
        struct {
	        UserDataInfo userDataInfo[Header.userdataCount] <optimize=false>;
        } userDataInfos;
    }

    if (exists(Header.resourceCount) && Header.resourceCount) {
	    FSeek(Header.resourceInfoTbl);
	    struct {
            Resource_Info ResourceInfo[Header.resourceCount] <optimize=false>;
	    } ResourceInfos;
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        FSeek(Header.prefabInfoTbl);
        struct {
            for (i=0; i<Header.prefabCount; i++)
                struct PreFab {
                    local uint idx <hidden=true> = i;
                    int id;
                    int parentId;
                    FSeek(id); wstring path;
                    if (parentId) {
                        FSeek(parentId); 
                        wstring path;
                    }
                    FSeek(startof(parentId)+4);
                    
                } PrefabInfo <read=ReadPreFab, write=WritePreFab>;
        } PrefabInfos;
    }
}

    wstring ReadGRefInfo(GameObjectInfo &g) { return ReadObjectIdTitle(g.id); }

    wstring ReadGRefInfoPFB(GameObjectInfoPFB &g) { return ReadObjectIdTitle(g.id); }

    wstring ReadGRefInfoName(GameObjectInfo &g) { return ReadObjectIdName(g.id); }

    wstring ReadGRefInfoPFBName(GameObjectInfoPFB &g) { return ReadObjectIdName(g.id); }

    wstring ReadFOLDERINFO(FOLDERINFO &f) { return ReadObjectIdTitle(f.id); }

    wstring ReadFOLDERINFOName(FOLDERINFO &f) { return ReadObjectIdName(f.id); }

    wstring ReadPreFab(PreFab &p) { return p.path; }

    void WritePreFab(PreFab &p, string s) { p.path = s; }

typedef struct {
        local ushort lvl <hidden=true>;
        if (exists(parentof(this).lvl)) 
            lvl = parentof(this).lvl;
        else lvl = getLevel(FTell());
        uint instanceId; 
        HASH typeId <read=ReadHASHWithName>;   
        if (RSZVersion == "DMC5" || RSZVersion == "RE2") {
            uint uknHash <format=hex>;
            uint uknOffs;
            uint64 pathOffs;
            local uint dataOffs <hidden=false> = pathOffs + startof(RSZHeader);
            FSkip(-1); struct { ubyte a; local wstring String; } path <hidden=true>; //dummy
        } else {
            StringRead path(-1, startof(RSZHeader), 0); 
        }
} RSZUserDataInfo <name=ReadRSZUserDataInfoName, read=ReadRSZUserDataInfo>;

    string ReadRSZUserDataInfoName(RSZUserDataInfo &u) { return RSZFile[u.lvl].InstanceInfos.instanceInfo[u.instanceId].typeId.HashName; }
    
    string ReadRSZUserDataInfo(RSZUserDataInfo &u) { return u.path.String; }

typedef struct OBJECT (ubyte isFolder)
{
    local int tempN <hidden=true>, tempJ <hidden=true>, prefabCount <hidden=true>, gChildCount <hidden=true>, fChildCount <hidden=true>, id <hidden=true>;
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else lvl = getLevel(FTell());
    local wstring title <hidden=true>;
    isFolder == true ? (id = FolderInfos.FolderInfo[n].id.id) : (id = GameObjectInfos[n].id.id);
    
    if (!isFolder && exists(GameObjectInfos[n].prefabId) && GameObjectInfos[n].prefabId != -1) {
        StringRead Prefab(startof(PrefabInfos.PrefabInfo[GameObjectInfos[n].prefabId].id), 0, 0) <open=suppress, name=PrefabName>; 
        FSkip(-1);
        title = Prefab.String;
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        for (j=0; j<Header.prefabCount; j++)
            if (PrefabInfos.PrefabInfo[j].parentId == id)
                prefabCount++;
        if (prefabCount) {
            struct {
                for (j=0; j<Header.prefabCount; j++)
                    if (PrefabInfos.PrefabInfo[j].parentId == id) {
                        StringRead Prefab(startof(PrefabInfos.PrefabInfo[j]), 0, 0) <open=suppress, name="Prefab">;
                        FSkip(-1);
                    }
                FSeek(startof(this) + 1);
            } Prefabs <name="Child Prefabs">;
            FSkip(-1);
        }
    }

    local uint counter <hidden=true>, isObject <hidden=true>;

    while (exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[id] + counter].name)) {
        isObject = FALSE;
        for (j=0; j<RSZHeader.objectCount; j++) 
            if (RSZFile[lvl].ObjectTable[id] + counter == RSZFile[lvl].ObjectTable[j]) { isObject = TRUE; break; }
        if ( counter == 0 || (RSZFile[lvl].InstanceInfos.instanceInfo[RSZFile[lvl].ObjectTable[id] + counter].typeId.HashName != "via.Folder")
            && (RSZFile[lvl].InstanceInfos.instanceInfo[RSZFile[lvl].ObjectTable[id] + counter].typeId.HashName != "via.GameObject") ) 
        {
            
            FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[id] + counter]));
            i = RSZFile[lvl].ObjectTable[id] + counter;
            tempN = n;
            if (isObject) {
                RSZInstance RSZ;
            }
            n = tempN;
            counter ++;
        } else break;
    }  
    if (title == "" && exists(RSZ[0].title))
        title = RSZ[0].title;
        
    if (exists(Header.folderCount)) {        
        for (j=0; j<Header.folderCount; j++)
            if (FolderInfos.FolderInfo[j].parentId.id == id) {
                if (!fChildCount)
                    FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                fChildCount++;
            }
        
        if (fChildCount) {
            struct {
                for (j=0; j<Header.folderCount; j++) {
                    if (FolderInfos.FolderInfo[j].parentId.id == id) {
                        tempN = n; tempJ = j;
                        FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                        n = j;
                        if (fChildCount == 1)
                            struct GameObject ChildFolder(1) <read=ReadGameObject, open=true>;
                        else
                            struct GameObject ChildFolder(1) <read=ReadGameObject>;
                        n = tempN; j = tempJ;
                    }
                }
                if (startof(this) > FTell())
                    FSeek(startof(this) + sizeof(ChildFolder[0]));
            } Folders <name="Child Folders">;
        }
    }
    
    for (j=0; j<Header.infoCount; j++)
        if (GameObjectInfos[j].parentId.id == id ) {
            if (!gChildCount && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]]))
                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]]));
            gChildCount++;
        }    
    
    if (gChildCount) {
        struct {
            for (j=0; j<Header.infoCount; j++) {
                if (GameObjectInfos[j].parentId.id == id && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]])) {
                    tempN = n; tempJ = j;
                    FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]]));
                    n = j;
                    if (gChildCount == 1)
                        struct GameObject ChildObject(0) <open=true>;
                    else
                        struct GameObject ChildObject(0);
                    n = tempN; j = tempJ;
                }
            }
            if (startof(this) > FTell())
                FSeek(startof(this) + sizeof(ChildObject[0]));
        } GameObjects <name="Child GameObjects">;
    }
    
    checkUseSpacers();
    
    if (startof(this) > FTell())
        FSeek(startof(this) + sizeof(RSZ[0]));
};

typedef OBJECT GameObject <name=ReadGameObjectName, read=ReadGameObject>;

    wstring ReadGameObjectName(GameObject &g) {         
        if (exists(g.RSZ[0].var[0].data))
            return (wstring)g.RSZ[0].var[0].data;
        return "";
    }

    wstring ReadGameObject(GameObject &g) {
        if (exists(g.RSZ[0].var[5].data ) && g.RSZ[0].name == "via.Folder")
            return g.RSZ[0].var[5].data;
        if (exists(g.RSZ[0].var[1].data ) && g.RSZ[0].name == "via.GameObject")
            return g.RSZ[0].var[1].data;
        if (exists(g.Prefab)) 
            return g.Prefab.String;
        return "";
    }

typedef uint64 InsertKey <read=ReadInsertHashKey, write=InsertHashKey>;
    
    wstring ReadInsertHashKey(InsertKey &k) { return "Input a '*' here to insert an object, or a space to insert a non-object"; }
    
    void InsertHashKey(InsertKey &k, string s) { 
        local int lvl = parentof(parentof(parentof(k))).lvl;
        int64 newValue = Atoi(s);
        local int isObject;
        if (s[0] == 42) {
            isObject = TRUE;
            newValue = Atoi(SubStr(s, 1, sizeof(s)-1));
        }
        //Printf("%i\n", (startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos)));
        local int freeSpace = 16 - ((startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos)) % 16);
        local int sizeToInsert = 8 - freeSpace;
        if (isObject)
            sizeToInsert = 12 - freeSpace;
        local int newPadding = (16 - sizeToInsert) % 16;
        local int diff = sizeToInsert + newPadding;
        //Printf("%iL %i %i %i %i %i\n", newValue, freeSpace, sizeToInsert, newPadding, diff, parentof(k).index);
        RSZFile[lvl].RSZHeader.dataOffset += diff;
        RSZFile[lvl].RSZHeader.userdataOffset += diff;
        if (isObject) {
            RSZFile[lvl].RSZHeader.instanceOffset += 4;
            RSZFile[lvl].RSZHeader.objectCount += 1;
        }
        RSZFile[lvl].RSZHeader.instanceCount += 1;
        for (o=0; o<RSZFile[lvl].RSZHeader.objectCount-1; o++) 
            if (RSZFile[lvl].ObjectTable[o] > parentof(k).index)
                RSZFile[lvl].ObjectTable[o] += 1;
        if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
            local int ii, jj;
            while (exists(RSZFile[ii])) {
                if (startof(RSZFile[ii]) < startof(RSZFile[lvl]) && RSZFile[ii].RSZHeader.RSZoffs > RSZFile[lvl].RSZHeader.RSZoffs) {
                    //Printf("%i %i %i\n", startof(r.size)+4, startof(RSZFile[ii]), startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) );
                    RSZFile[ii].RSZHeader.dataOffset += diff;
                }
                jj=0;
                while (exists(RSZFile[ii].RSZUserDataInfos.userDataInfo[jj])) {
                    if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs + startof(RSZFile[ii]) > startof(RSZFile[lvl]))
                        RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs += diff;
                    if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs + startof(RSZFile[ii]) > startof(RSZFile[lvl]))
                        RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs += diff;
                    
                    jj++;
                }
                ii++;
            }
        } else 
            for (o=0; o<RSZFile[lvl].RSZHeader.userdataCount; o++)
                RSZFile[lvl].RSZUserDataInfos.userDataInfo[o].path.strOffset += diff;
        if (freeSpace)
            DeleteBytes(startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos), freeSpace);
        if (newPadding)
            InsertBytes(startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos), newPadding, 0);
        InsertBytes(startof(parentof(k))+8, 8, 0);
        WriteInt64(startof(parentof(k))+8, newValue);
        if (isObject) {
            InsertBytes(startof(RSZFile[lvl].InstanceInfos), 4, 0);
            WriteUInt(startof(RSZFile[lvl].InstanceInfos), parentof(k).index+1);
        }
        MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
    }

typedef struct {
    struct RSZHEADER {
	    unsigned int magic;
	    unsigned int version;
	    int objectCount;
	    int instanceCount;
	    int userdataCount;
	    int reserved;
        int64 instanceOffset;
	    int64 dataOffset;
	    int64 userdataOffset;
        local uint RSZoffs = dataOffset + startof(this);
    };

    if (!ShowChildRSZs && exists(parentof(this)))
        RSZHEADER RSZHeader <hidden=true>;
    else 
        RSZHEADER RSZHeader;

    local ushort lvl <hidden=true> = getLevel(RSZHeader.RSZoffs);

    FSeek(startof(RSZHeader.userdataOffset)+8);
    if (RSZHeader.objectCount && !ShowChildRSZs && exists(parentof(this)))
        int32 ObjectTable[RSZHeader.objectCount] <hidden=true, name=ReadObjectName, read=ReadObject>;
    else if (RSZHeader.objectCount)
        int32 ObjectTable[RSZHeader.objectCount] <name=ReadObjectName, read=ReadObject>;
    
    FSeek(startof(RSZHeader) + RSZHeader.instanceOffset);
    struct INSTANCEINFO {
        for (i=0; i< RSZHeader.instanceCount; i++) {
            struct InstanceInfo {
                local uint index <hidden=true> = i;
	            HASH typeId;
                uint CRC;
                FSkip(-8);
                int64 CombinedKey;
                FSkip(-8);
                InsertKey NewKey;
                if (!i)
                    typeId.HashName = "NULL";
            } instanceInfo <name=ReadInstanceInfoName, read=ReadInstanceInfo>;
        }
    };
    
    if (!ShowChildRSZs && exists(parentof(this)))
        INSTANCEINFO InstanceInfos <hidden=true>;
    else 
        INSTANCEINFO InstanceInfos;
    
    if (RSZHeader.userdataCount) {
	    FSeek(startof(RSZHeader) + RSZHeader.userdataOffset);
        if (!ShowChildRSZs && exists(parentof(this)))
            struct RSZUSERDATAINFOS {
                for (i=0; i<RSZHeader.userdataCount; i++)
                    RSZUserDataInfo userDataInfo;
            } RSZUserDataInfos <hidden=true>;
        else struct RSZUSERDATAINFOS RSZUserDataInfos;
    }
    
    FSeek(RSZHeader.RSZoffs);
    if (RSZHeader.instanceCount > 1) {
        struct {
            local int isObject <hidden=true>;
            local ushort lvl <hidden=true> = parentof(this).lvl;
            struct DATA {
                if (!IsInitialized())
                    ParseJson(JsonPath);
                
                local int rawData <hidden=true>;
                local int lvl <hidden=true> = getLevel(FTell());
                for (i=0; i<RSZFile[lvl].RSZHeader.instanceCount; i++) {
                    if (!finished && RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.HashName == "via.GameObject") 
                    {
                        if (FTell()+4 <= FileSize())
                            fakeGameObject Test <hidden=true>;
                        if (lastGameObject > 0 && (Test.timeScale != 3212836864 )) { 
                            Printf("Seeking from %u to last GameObject at %u\n",  FTell(), lastGameObject); 
                            FSeek(startof(Test));
                            BLANK blank <read=ReadErrorNotice, bgcolor=cRed>;
                            FSeek(lastGameObject);
                            while (FTell() <= FileSize() - 8) {
                                if (ReadUInt(FTell()) == 3212836864 && detectedBools(FTell()-4) 
                                && (detectedString(FTell()-16) || detectedString(FTell()-20) || detectedString(FTell()-24)) )
                                    break;
                                FSkip(4);
                            }
                            lastGameObject = FTell()+4;
                            Printf("Redetected next GameObject at %u\n",  lastGameObject); 
                            
                            FSkip(-32);
                            //while (FTell() > lastGameObject - 28 && !detectedString(FTell()))
                            //    FSkip(-1);
                            if (detectedString(FTell()))
                                redetectStringBehind();
                            else FSkip(8);
                            //if (detectedString(FTell()-8)) {
                            //    FSkip(-8);
                            //    redetectStringBehind();
                            //}
                            broken = false;
                            SetForeColor(cAqua);
                        } else if (FTell() > lastGameObject) {
                            lastGameObject = FTell();
                            FSeek(startof(Test));
                        }
                    }
                    
                    if (GetFieldArrayState(RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.Hash, 0))
                        FSeek(getAlignedOffset(FTell(), 4));
                    else
                        FSeek(getAlignedOffset(FTell(), GetFieldAlignment(RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.Hash, 0)));
                    
                    if (!i)
                        RSZInstance RSZ <hidden=true>;
                    else
                        RSZInstance RSZ;
                    if (sizeof(RSZ) == 0) 
                        Printf("Empty struct: %u\n", FTell()); 
                    if (exists(RSZ.skipFileData)) {
                        FSeek(startof(RSZ));
                    } else if (exists(RSZ.skip)) {
                        if (i)
                            Printf("\nERROR: Missing struct for %X %s [%u]\n", RSZ.hash, RSZ.name, RSZ.idx);
                        FSeek(startof(RSZ));
                    }
                }
            };
            
            if (HideRawData || (!ShowChildRSZs && exists(parentof(parentof(parentof(this)))))) //if is an embedded RSZMagic
                DATA RawData <hidden=true, open=suppress>;
            else
                DATA RawData <open=suppress>;
        
            finished = TRUE;
                
            if (Nesting && Header.magic != 1280262994) { //no RCOL
                if (exists(Header.dataOffset) && startof(RSZFile[lvl]) == Header.dataOffset ) { //
                    if (exists(Header.folderCount))
                        for (n=0; n<Header.folderCount; n++) {
                            if (FolderInfos.FolderInfo[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]]));
                                struct GameObject MainFolder(1)  <name=ReadGameObjectName, read=ReadGameObject>;
                            }
                        }
                    if (exists(Header.infoCount))
                        for (n=0; n<Header.infoCount; n++) {
                            if (GameObjectInfos[n].id.id > -1 && GameObjectInfos[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[GameObjectInfos[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[GameObjectInfos[n].id.id]]));
                                struct GameObject MainObject(0)  <name=ReadGameObjectName, read=ReadGameObject>;
                            } 
                        }
                } else {
                    for (i=0; i<RSZHeader.instanceCount; i++) {
                        isObject = FALSE;
                        for (j=0; j<RSZHeader.objectCount; j++) 
                            if (ObjectTable[j] == i) { isObject = TRUE; break; }
                        if (isObject && exists(RawData.RSZ[i])) {
                            FSeek(startof(RawData.RSZ[i]));
                            RSZInstance RSZ; //size=SizeRSZInstance
                            if (exists(RawData.RSZ[i].skip) || exists(RawData.RSZ[i].skipFileData)) 
                                FSeek(startof(RSZ));
                        }
                    }
                }
            }
        } Data <open=true>;
    } else 
        { FSkip(-1); ubyte Data <hidden=true>; }
    
    if (exists(parentof(this)))
        checkUseSpacers();
    
    local int f <hidden=true>, ff <hidden=true>;
    if (ShowChildRSZs && (RSZHeader.userdataCount && (RSZVersion == "DMC5" || RSZVersion == "RE2")) ) {
        FSeek(RSZUserDataInfos.userDataInfo[0].dataOffs);
        struct {
            for (f=0; f<RSZHeader.userdataCount; f++) {
                FSeek(RSZUserDataInfos.userDataInfo[f].dataOffs);
                struct RSZMagic UserData <size=52>;
            }
        } UserData;
    }
    //FSeek(startof(this)+52);
} RSZMagic <name="RSZ", name=ReadRSZMagicName, read=ReadRSZMagic>;

    wstring ReadRSZMagicName(RSZMagic &m) { 
        if (exists(m.ObjectTable) && m.ObjectTable[0] >= 0 && exists(m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName)) {
            return m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName; 
        } else {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f]) == startof(m) && exists(RSZFile[f].ObjectTable) && RSZFile[f].ObjectTable[0] >= 0 && exists(RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName) ) 
                    return RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName;
            }
        }
        return "RSZ"; 
    }

    wstring ReadRSZMagic(RSZMagic &m) { 
        if (exists(m.Data.RSZ[0].title)) 
            return m.Data.RSZ[0].title;
        else if (exists(m.Data.MainObject[0].title))
            return m.Data.MainObject[0].title;
        else if (exists(m.Data.MainFolder[0].title))
            return m.Data.MainFolder[0].title;
        else {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f]) == startof(m) && exists(RSZFile[f].ObjectTable) && RSZFile[f].ObjectTable[0] >= 0 && exists(RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title) ) 
                    return RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title;
            }
        }
        return ""; 
    }

    string ReadObjectName(int &o) { 
        local ushort lvl = parentof(o).lvl;
        local uint32 hash = ReadUInt((startof(RSZFile[lvl].RSZHeader) + RSZFile[lvl].RSZHeader.instanceOffset + 8 * o)); 
        return ReadHashName(hash); 
    }

    string ReadObject(int &o) { 
        local ushort lvl = parentof(o).lvl;
        local string s;
        if (exists(RSZFile[lvl].Data.RawData.RSZ[o]))
            SPrintf(s, "%i -- %s", o, RSZFile[lvl].Data.RawData.RSZ[o].title);
        return s;
    }



    string ReadInstanceInfoName(InstanceInfo &i) { return i.typeId.HashName; }
    
    string ReadInstanceInfo(InstanceInfo &i) { string s; SPrintf(s, "%X", i.typeId.Hash); return s; }


//start of file =====================

FSeek(RSZOffset);
if (Header.magic == 4343376 || Header.magic == 5129043) // SCN or PFB
    { FSkip(-1); BLANK __; FSkip(-1); BLANK MainDataNotice <name=ReadMainDataNotice>; }
while (FTell()+4 <= FileSize()) {
    if ( ReadUInt(FTell()) == 5919570 ) { //RSZ
        finished = false;
        if (level == 1 && !FEof()) { 
            FSkip(-1); BLANK blank; 
            if (Header.magic == 4343376 || Header.magic == 5129043) {
                FSkip(-1); BLANK userDataNotice <name=ReadUserDataNotice>; 
            }
        }
        struct RSZMagic RSZFile;
        level++;
        FSeek(startof(RSZFile) + 4);
    } else 
        FSkip(1);
}
finished = true;
if (sizeof(Header) == 0) { //detect strings in motbank etc files:
    FSeek(0);
    while(FTell() + 6 <= FileSize())
        if (detectedString(FTell()))
            StringRead Detected_String(FTell(), 0, true); //absolute
        else 
            FSkip(2);
}

//RCOL only =========================

if (Header.magic == 1280262994) { 
    FSeek(Header.groupsPtrTbl);
    struct {
        struct RcolGroup {
            rGUID Guid;
            StringRead Name(-1, 0, 0);
            uint NameHash <format=hex>;
            int UserDataIndex;
            int NumShapes;
            int NumMaskGuids;
            uint64 ShapesTbl;
            int LayerIndex;
            uint MaskBits;
            uint64 MaskGuidsOffset;
            
            if (NumMaskGuids) {
                FSeek(MaskGuidsOffset);
                rGUID MaskGuids[NumMaskGuids] <optimize=false>;
                FSeek(startof(MaskGuidsOffset)+8);
            }
            
            rGUID LayerGuid;
            FSeek(ShapesTbl);
            if (NumShapes)
                struct RcolShape {
                    rGUID Guid;
                    StringRead Name(-1, 0, 0);
                    uint NameHash <format=hex>;
                    int UserDataIndex;
                    int LayerIndex;
                    int Attribute;
                    uint SkipIdBits;
                    uint IgnoreTagBits;
                    StringRead primaryJointNameStr(-1, 0, 0);
                    StringRead secondaryJointNameStr(-1, 0, 0);
                    uint PrimaryJointNameHash <format=hex>;
                    uint SecondaryJointNameHash <format=hex>;
                    enum <uint32> {
                        ShapeType_Aabb = 0x0,
                        ShapeType_Sphere = 0x1,
                        ShapeType_ContinuousSphere = 0x2,
                        ShapeType_Capsule = 0x3,
                        ShapeType_ContinuousCapsule = 0x4,
                        ShapeType_Box = 0x5,
                        ShapeType_Mesh = 0x6,
                        ShapeType_HeightField = 0x7,
                        ShapeType_StaticCompound = 0x8,
                        ShapeType_Area = 0x9,
                        ShapeType_Triangle = 0xA,
                        ShapeType_SkinningMesh = 0xB,
                        ShapeType_Cylinder = 0xC,
                        ShapeType_DeformableMesh = 0xD,
                        ShapeType_Invalid = 0xE,
                        ShapeType_Max = 0xF,
                    } ShapeType;
                    FSkip(4);
                    //RSVAr
                    struct {
                        //struct {
                            float x, y, z, w;
                            float x, y, z, w;
                            float x, y, z, w;
                            float x, y, z, w;
                            float x, y, z, w;
                        //} RotationMatrix;
                        //float CenterPoint_x, CenterPoint_y, CenterPoint_z, CenterPoint_w;
                        //float Ukn, Width, Height, Length;
                    } Parameters;
                    if (UserDataIndex) {
                        local uint RSZIdx <hidden=true> = RSZFile[0].ObjectTable[UserDataIndex];
                        FSeek(startof(RSZFile[0].Data.RawData.RSZ[RSZFile[0].ObjectTable[UserDataIndex]]));
                        RSZInstance RSZ <size=SizeRSZInstance>;
                        FSeek(startof(Parameters)+80);
                    }
                } Shape[NumShapes] <read=ReadShape, optimize=false>;
                
            FSeek(startof(LayerGuid)+16);
            checkUseSpacers();

        } Group[Header.numGroups] <size=80, read=ReadGroup, optimize=false>;
    } Groups;
    
    if (exists(Header.ignoreTagTbl) && Header.numIgnoreTags) {
        FSeek(Header.ignoreTagTbl);
        struct {
            struct RcolIgnoreTag {
                StringRead Name(-1, 0, 0);
                uint nameHash <format=hex>;
                FSkip(4);
            } IgnoreTag[Header.numIgnoreTags] <read=ReadIgnoreTag, optimize=false>; 
        } IgnoreTags;
    }
    
    if (exists(Header.autoGenerateJointDescTbl) && Header.numAutoGenerateJoints) {
        FSeek(Header.autoGenerateJointDescTbl);
        struct {
            uint ukn; //placeholder
        } AutoGenerateJointDescs;
    }

    if (exists(Header.numRequestSets) && Header.numRequestSets) {
        FSeek(Header.requestSetTbl);
        struct {
            for (n=0; n<Header.numRequestSets; n++)
                struct RcolRequestSet {
                    uint ID;
                    int GroupIndex;
                    int ShapeOffset;
                    uint status;
                    StringRead Name(-1, 0, 0);
                    uint NameHash <format=hex>;
                    FSkip(4);
                    StringRead KeyName(-1, 0, 0);
                    uint KeyHash <format=hex>;
                    
                    FSeek(startof(Groups.Group[GroupIndex]));
                    struct RcolGroup Group <read=ReadGroup, size=80>;
                    
                    local uint RSZIdx <hidden=true> = RSZFile.ObjectTable[n];
                    FSeek(startof(RSZFile.Data.RawData.RSZ[RSZIdx]));
                    RSZInstance RSZ <open=true, size=SizeRSZInstance>;

                    SetForeColor(cNone);
                    FSeek(startof(KeyHash)+8);
                } RequestSet <name=ReadRequestSetName, read=ReadRequestSet>;
        } RequestSets;
    }
} 
    wstring ReadGroup(RcolGroup &g) { 
        if (exists(parentof(g).GroupIndex) ) //&& exists(Groups.Group[parentof(g).GroupIndex])
            return Groups.Group[parentof(g).GroupIndex].Name.String; 
        if (exists(g.Name.String))
            return g.Name.String;  
        return ReadWString(ReadUInt64(startof(g)+16));
    }

    wstring ReadShape(RcolShape &s) { return s.Name.String; } 

    wstring ReadRequestSet(RcolRequestSet &a) { return a.Name.String; }

    wstring ReadRequestSetName(RcolRequestSet &a) { string s; SPrintf(s, "RequestSet ID: %u  ", a.ID); return s; }