//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: RE_RSZ.bt
//   Authors: alphaZomega w/ help from Darkness and Praydog
//   Version: 0.53
//   Purpose: Parsing RE Engine RSZ data
//  Category: RE Engine
// File Mask: *.user.2;*.pfb.*;*.scn.*;*.rcol.*;*.bhvt.*;*.motfsm2.*;*.fsmv2.*
//  ID Bytes: 
//   History: October 2, 2021
//------------------------------------------------
//              Option:                                                           //Effect:
local string    RSZVersion      <hidden=false>       = "DMC5";                    //change between RE2, RE3, RE8 or DMC5
local int       Nesting         <hidden=true>        = TRUE;                      //Attempt to nest class instances inside eachother
local int       ShowAlignment   <hidden=true>        = FALSE;                     //Show metadata for each variable
local int       ShowChildRSZs   <hidden=true>        = FALSE;                     //Show all RSZs one after another, non-nested. Disabling hides nested RSZHeaders
local int       UseSpacers      <hidden=true>        = TRUE;                      //Show blank rows between some structs
local int       AutoDetectGame  <hidden=true>        = TRUE;                      //Automatically detect RSZVersion based on the name + ext of the file being viewed
local int       ReadBHVTHeader  <hidden=true>        = TRUE;                     //Testing methods to read BHVT header w/ UVAR (also in Motfsm and fsmv2)
local int       HideRawData     <hidden=true>        = FALSE;                     //Hides RawData struct
local int       PrintClasses    <hidden=true>        = FALSE;                     //

//Path to Noesis.exe
local wstring NoesisPath <hidden=true> =            "C:\\Program Files (x86)\\Noesis\\Noesis.exe";

//Game							                    //Extracted Path
local wstring DMC5Path <hidden=true> =              "D:\\modmanager\\REtool\\DMC_chunk_000\\natives\\x64\\";
local wstring RE2Path <hidden=true> =               "D:\\modmanager\\REtool\\RE2_chunk_000\\natives\\x64\\";
local wstring RE3Path <hidden=true> =               "D:\\modmanager\\REtool\\RE3_chunk_000\\natives\\stm\\";
local wstring RE8Path <hidden=true> =               "D:\\modmanager\\REtool\\RE8_chunk_000\\natives\\stm\\";


//RSZ Parser By Darkness:
#link "RSZParser.dll"
ubyte   IsInitialized();
void    ParseJson(string jsonPath);
string  GetRSZClassName(uint32 classHash);
uint32  GetFieldCount(uint32 classHash);
uint32  GetFieldAlignment(uint32 classHash, uint32 fieldIndex);
ubyte   GetFieldArrayState(uint32 classHash, uint32 fieldIndex);
string  GetFieldName(uint32 classHash, uint32 fieldIndex);
string  GetFieldTypeName(uint32 classHash, uint32 fieldIndex);
string  GetFieldOrgTypeName(uint32 classHash, uint32 fieldIndex);
uint32  GetFieldSize(uint32 classHash, uint32 fieldIndex);
uint64  GetFieldType(uint32 classHash, uint32 fieldIndex);
ubyte   IsFieldNative(uint32 classHash, uint32 fieldIndex);
#endlink

//Local variables:
local int i <hidden=true>, j <hidden=true>, k <hidden=true>, m <hidden=true>, n <hidden=true>, o <hidden=true>, h <hidden=true>, temp <hidden=true>,
            matchSize <hidden=true>, lastGameObject <hidden=true>, uniqueHashes[5000] <hidden=true>, hashesLen <hidden=true>, noRetry <hidden=true>;
local int RSZOffset <hidden=true> = FindFirst("RSZ",1,0,0,0.0,1,0,0,24);
local int level <hidden=true>;
local int finished <hidden=true>;
local int broken <hidden=true>;
local string s <hidden=true>;
local ubyte isAIFile <hidden=true>;


if (ShowAlignment) {
    local int varLen <hidden=false>;
    local uint maxVars <hidden=true> = ((FileSize()-RSZOffset)/4); 
    if (maxVars > 1000000) maxVars = 1000000;
    local uint offs[maxVars] <hidden=false>, aligns[maxVars] <hidden=false>, sizes[maxVars] <hidden=false>; //synced
} else {
    local int varLen <hidden=true>;
}

local wstring extractedDir <hidden=true> = DMC5Path;
local wstring Local_Directory  <hidden=true> = FileNameGetPath(GetFileName(), true);
local uint findValue <hidden=true> = find(Local_Directory, "natives");
Local_Directory = StrDel( Local_Directory, findValue, sizeof(Local_Directory) - findValue) + "natives\\";
local wstring lower <hidden=true> = Lower(Local_Directory);

if (AutoDetectGame) {
    local string xFmt <hidden=true> = "x64\\";
    if (find(lower, "dmc") != -1 || find(lower, "evil may") != -1) {
	    RSZVersion = "DMC5";
	    extractedDir = DMC5Path;

    } else if (find(lower, "re2") != -1 || find(lower, "evil 2") != -1) {
	    RSZVersion = "RE2";
	    extractedDir = RE2Path;

    } else if (find(lower, "re3") != -1 || find(lower, "evil 3") != -1) {
	    RSZVersion = "RE3";
	    extractedDir = Lower(RE3Path);
	    xFmt = "stm\\";

    } else if (find(lower, "re8") != -1 || find(lower, "evil 8") != -1 || find(lower, "illage") != -1) {
	    RSZVersion = "RE8";
	    extractedDir = Lower(RE8Path);
	    xFmt = "stm\\";
    } 
	Local_Directory += xFmt;

} else if (RSZVersion == "DMC5" || RSZVersion == "RE2" || RSZVersion == "RE7") {
    Local_Directory += "x64\\";
} else {
    Local_Directory += "stm\\";
}
Local_Directory = Lower(Local_Directory);
local string JsonPath<hidden=true> = Lower(FileNameGetPath(GetTemplateFileName()) + "RSZ" + RSZVersion + ".json"); 
ParseJson(JsonPath);

//===========================
//Create your own enums here:
//They will be added inside the struct for any variable with the name detected by findS()
void enums(){
    if (findS(fieldName, "DamageType") != -1) {
        FSkip(-sizeof(data));
        enum { 
            None = -1,
            Minimum = 0,
            NormalS = 1,
            NormalL = 2,
            NormalLL = 3,
            Down = 4,
            DownBound = 5,
            Slam = 6,
            SlamBound = 7,
            Upper = 8,
            HyperUpper = 9,
            HyperUpperAir = 10,
            Blown = 11,
            Collapse = 12,
            RollingUpper = 13,
            CheckSpin = 14,
            Spin = 15,
            DiagonalBlown = 16,
            WindS = 17,
            WindL = 18,
            SnatchRelase = 19,
            StraightBlown = 20,
            Tremor = 21,
            Inhale = 22,
            MotionContinue = 23,
            Explosion = 24
        } DamageType;
    }
}

//============================
//Special functions & structs:
LittleEndian();
if (AutoDetectGame)
    AutoDetectVersion();

void AutoDetectVersion() {
    local string hashName;
    local uint checkedVersions, instanceCount, objectCount, hash, zz, varsChecked;
    local string origVersion = RSZVersion, 
    origExtractedDir = (string)extractedDir, 
    origXFmt = xFmt, 
origLocal_Directory = Local_Directory, 
origJsonPath = JsonPath;
    FSeek(RSZOffset);
    while (FTell() < FileSize()-4 && ReadUInt() == 5919570) {
        instanceCount = ReadUInt(FTell() + 12), objectCount = ReadUInt(FTell() + 8);
        if (instanceCount) FSkip(48 + 4*objectCount + 8);
        for (zz=1; zz<instanceCount; zz++) {
            if (varsChecked > 100) break;
            hash = ReadUInt();
            hashName = ReadHashName(hash);
            checkedVersions = 0;
            if (hash != 0 && checkedVersions < 4 && hashName == "Unknown Class!") {
                while (checkedVersions < 4 && hashName == "Unknown Class!") {
                    switch (checkedVersions) {
                        case 0: RSZVersion = "DMC5"; extractedDir = DMC5Path; xFmt = "x64\\";  break;
                        case 1: RSZVersion = "RE2"; extractedDir = DMC5Path; xFmt = "x64\\"; break;
                        case 2: RSZVersion = "RE3"; extractedDir = DMC5Path; xFmt = "stm\\"; break;
                        default: RSZVersion = "RE8"; extractedDir = DMC5Path; xFmt = "stm\\"; break;
                    }
                    Local_Directory = lower + xFmt; JsonPath = Lower(FileNameGetPath(GetTemplateFileName()) + "RSZ" + RSZVersion + ".json");
                    ParseJson(JsonPath);
                    hashName = ReadHashName(hash);
                    checkedVersions++;
                }
                if (checkedVersions == 3 && hashName == "Unknown Class!") {
                    RSZVersion = origVersion; extractedDir = origExtractedDir; xFmt = origXFmt; Local_Directory = origLocal_Directory; JsonPath = origJsonPath;
                } else {
                    Printf("RSZVersion auto detected to %s\n", RSZVersion);
                    break;
                }
            }
            varsChecked++;
            FSkip(8);
        }
        if (varsChecked > 15) break;
        while (FTell() < FileSize()-4 && ReadUInt() != 5919570) FSkip(1);
    }
    FSeek(0);
}

void PrintRSZClass(string className) {
    local int z;
    local string dataType;
    local string secondDataType;
    local string output = className; 
    local uint index = findS(output, "\\."); 
    while (index != -1) {
		output = StrDel(output, index, sizeof(output) - index + 1) + "_" + SubStr(output, index + 1, -1);
		index = findS(output, "\\.");
    }
    local string newClassName = output;

    SPrintf(output, "public class %s : MonoBehaviour\n{\n    public string FieldName;\n", output);
    
    for (z = 0; z < GetFieldCount(hash); z++) {
        dataType = Lower(GetFieldTypeName(hash, z));
        if (dataType == "userdata" || dataType == "object") //|| dataType == "userdata"
            dataType = "int";
        else if (dataType == "data") {
            if (GetFieldSize(hash, z) == 1)
                dataType = "bool";
            else 
                dataType = "float";
        }
        if (GetFieldArrayState(hash,z))
            dataType += "[]";
        SPrintf(output, "%s    public %s %s;\n", output, dataType, GetFieldName(hash, z));
    }
    SPrintf(output, "%s\n    public %s()\n    {\n        FieldName = SCNImporter.RSZ.name;\n", output, newClassName);
    for (z = 0; z < GetFieldCount(hash); z++) {
        dataType = Lower(GetFieldTypeName(hash, z));
        if (dataType == "string") {
            SPrintf(output, "%s        %s = SCNImporter.RSZ.Fields[%d].String;\n", output, GetFieldName(hash, z), z);
        } else {
            
            if (dataType == "bool" || GetFieldSize(hash, z) == 1) { //if (dataType == "data") 
                dataType = "Boolean";
            } else if (dataType == "int" || dataType == "uint" || dataType == "object" || dataType == "userdata" || dataType == "uint64" || dataType == "int64")
                dataType = "Int32";
            else
                dataType = "Single";
            
            if (GetFieldArrayState(hash, z) == 1) {
                secondDataType = dataType;
                if (dataType == "Single")
                    secondDataType = "float";
                if (dataType == "Boolean")
                    secondDataType = "bool";
                if (dataType == "Int32")
                    secondDataType = "int";
                SPrintf(output, "%s        %s = new %s[Convert.ToInt32(SCNImporter.RSZ.Fields[%d].count)];\n", output, GetFieldName(hash, z), secondDataType, z);
                SPrintf(output, "%s        for(int j=0; j<Convert.ToInt32(SCNImporter.RSZ.Fields[%d].count); j++)\n", output, z);
                SPrintf(output, "%s            %s[j] = Convert.To%s(SCNImporter.RSZ.Fields[%d].count);\n", output, GetFieldName(hash, z), dataType, z);
            } else 
                SPrintf(output, "%s        %s = Convert.To%s(SCNImporter.RSZ.Fields[%d].data[0]);\n", output, GetFieldName(hash, z), dataType, z);
        }
    }
    SPrintf(output, "%s    }\n\n    void Start()\n    {\n    }\n    void Update()\n    {\n    }\n}\n", output);
    Printf("%s\n", output);
    
}


void align(uint alignment) { 
    while (FTell() % alignment != 0 && FTell() <= FileSize()) 
    FSkip(1); 
}

int detectedColorVector(uint64 tell) { 
    if (tell+16<=FileSize()) {
        local float R = ReadFloat(tell), G = ReadFloat(tell+4), B = ReadFloat(tell+8), A = ReadFloat(tell+12); 
        return ((R >= 0 && G >= 0 && B >= 0 && (A == 0 || A == 1)) && ((R+G+B+A <= 4) || (R+G+B+A) % 1.0 == 0));
    } return 0;
}

float readColorFloat(uint64 tell) {
	local float colorFlt = ReadFloat(tell); 
    if (colorFlt <= 1) {
        colorFlt = (uint)(colorFlt * 255.0f + 0.5);
	    if (colorFlt > 255) 
		    return 255;
    }
	return colorFlt ; 
}

int detectedFloat(uint64 offset) {
    if (offset+4 <= FileSize()) {
        local float flt = ReadFloat(offset);
        return (ReadUByte(offset+3) < 255 && (Abs(flt) > 0.0000001 && Abs(flt) < 10000000) || ReadInt(offset) == 0); 
    } return false;
}

int detectedStringSm(uint64 offset) {
    //return offset+4 <= FileSize() && ReadUShort(offset-2) == 0 && (ReadByte(offset) != 0 && ReadByte(offset + 1) == 0 && sizeof(ReadWString(offset)) > 3);
    if (offset+4 <= FileSize())
        if (ReadUShort(offset-2) == 0)
            if (ReadByte(offset) != 0)
                if (ReadByte(offset + 1) == 0) 
                    if (sizeof(ReadWString(offset)) > 3)
                        return true;
                    else Printf("%s, %i\n", ReadWString(offset), offset);
                else Printf("%s, %i\n", ReadWString(offset), offset);
    return false;
}

int detectedString(uint64 offset) { 
    //return offset+6 <= FileSize() && (ReadByte(offset) != 0 && ReadByte(offset + 1) == 0 && ReadByte(offset + 2) != 0 && ReadByte(offset + 3) == 0 && ReadByte(offset + 4) != 0 && ReadByte(offset + 5) == 0);
    if (offset+6 <= FileSize())
        if (ReadByte(offset) != 0 && ReadByte(offset + 1) == 0) 
            if (ReadByte(offset + 2) != 0 && ReadByte(offset + 3) == 0)
                if (ReadByte(offset + 4) != 0) // && ReadByte(offset + 5) == 0
                    return true;
    return false;
}

int find(wstring str, wstring term) { return (RegExSearch(str, term, matchSize, 0)); }

int findS(string str, string term) { return (RegExSearch(str, term, matchSize, 0)); }

wstring Lower(wstring s1) { local string s = s1, s2 = s; for (k=0; k < sizeof(s); k++) s2[k] = ToLower(s[k]); return s2; }

wstring Upper(wstring s1) { local string s = s1, s2 = s; for (k=0; k < sizeof(s); k++) s2[k] = ToUpper(s[k]); return s2; }

int detectedBools(uint tell) {
    local uint nonBoolTotal;
    for (o=0; o<4; o++)
        if (ReadUByte(tell + o) > 1)
            nonBoolTotal++;
    if (nonBoolTotal == 0)
        return true;
    return false;
}

uint detectedHash(uint tell) {
    local ubyte nonHashTotal;
    for (o=0; o<4; o++)
        if (ReadUByte(tell + o) == 0)
            nonHashTotal++;
    if (nonHashTotal <= 1)
        return true;
    return false;
}

void FileOpener(wstring path) { 
    local wstring tmpNm = GetTemplateFileNameW();
    if (FileExists(NoesisPath) && (find(path, ".mesh.") != -1 || find(path, ".tex.") != -1)) {
        Exec(NoesisPath, "\"" + path + "\"", 0);
	    FileOpen(path, TRUE, "hex", 0); 
    } else FileOpen(path, TRUE, "hex", 1);
    FileSelect(FindOpenFileW(path));
	if (GetTemplateFileNameW() == "")
		RunTemplate(tmpNm, 0);
}

typedef byte BLANK <name=readBLANK, read=readBLANK, write="">;

    string readBLANK(BLANK &ref) { return " ";}

    string ReadErrorNotice(BLANK &b) { return "[Read Error Adjustment]"; }

    string ReadUserDataNotice(BLANK &b) { return "[Embedded UserDatas]"; }

    string ReadMainDataNotice(BLANK &b) { return "[Main Data]"; }

void checkUseSpacers() {
    if (UseSpacers) {
        FSkip(-1); 
        BLANK blank;
    }
}

typedef enum <uint32> {
	ukn_error = 0,
	ukn_type,
	not_init,
	class_not_found,
	out_of_range,
	Undefined_tid,
	Object_tid,
	Action_tid,
	Struct_tid,
	NativeObject_tid,
	Resource_tid,
	UserData_tid,
	Bool_tid,
	C8_tid,
	C16_tid,
	S8_tid,
	U8_tid,
	S16_tid,
	U16_tid,
	S32_tid,
	U32_tid,
	S64_tid,
	U64_tid,
	F32_tid,
	F64_tid,
	String_tid,
	MBString_tid,
	Enum_tid,
	Uint2_tid,
	Uint3_tid,
	Uint4_tid,
	Int2_tid,
	Int3_tid,
	Int4_tid,
	Float2_tid,
	Float3_tid,
	Float4_tid,
	Float3x3_tid,
	Float3x4_tid,
	Float4x3_tid,
	Float4x4_tid,
	Half2_tid,
	Half4_tid,
	Mat3_tid,
	Mat4_tid,
	Vec2_tid,
	Vec3_tid,
	Vec4_tid,
	VecU4_tid,
	Quaternion_tid,
	Guid_tid,
	Color_tid,
	DateTime_tid,
	AABB_tid,
	Capsule_tid,
	TaperedCapsule_tid,
	Cone_tid,
	Line_tid,
	LineSegment_tid,
	OBB_tid,
	Plane_tid,
	PlaneXZ_tid,
	Point_tid,
	Range_tid,
	RangeI_tid,
	Ray_tid,
	RayY_tid,
	Segment_tid,
	Size_tid,
	Sphere_tid,
	Triangle_tid,
	Cylinder_tid,
	Ellipsoid_tid,
	Area_tid,
	Torus_tid,
	Rect_tid,
	Rect3D_tid,
	Frustum_tid,
	KeyFrame_tid,
	Uri_tid,
	GameObjectRef_tid,
	RuntimeType_tid,
	Sfix_tid,
	Sfix2_tid,
	Sfix3_tid,
	Sfix4_tid,
	Position_tid,
	F16_tid,
	End_tid,
	Data_tid
} TypeIDs;

typedef struct VARDATA(uint algn) {
    local ubyte alignment = algn;
    local uint offset = FTell();//getAlignedOffset(FTell(), algn);
    local uint varSz = offset; //placeholder
    local ubyte padding = offset - FTell();
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());
    
    if (!finished) {
        local uint varIdx = varLen;
        varLen++;
        if (ShowAlignment && offs[varIdx] == 0) {
            if ( varIdx != 0 && offs[varIdx-1] >= offset) { //new vars at the same offset overwrite old ones
                varLen--;
                varIdx--;
            } else {
                offs[varIdx] = offset;
                aligns[varIdx] = alignment;
                sizes[varIdx] = -1;
            }
        }
    }
    if (!FEof())
        ubyte varStart <hidden=true>;
    else Printf("End of File\n");
};

uint getAlignedOffset(uint tell, uint alignment) {
    local uint offset = tell;
    switch (alignment) {
        case 2:  offset = tell + (tell % 2); break;  //2-byte
        case 4:  offset = (tell + 3) & 0xFFFFFFFFFFFFFFFC; break;  //4-byte
        case 8:  offset = (tell + 7) & 0xFFFFFFFFFFFFFFF8; break;  //8-byte
        case 16: offset = (tell + 15) & 0xFFFFFFFFFFFFFFF0; break; //16-byte
        default: break;
    }
    return offset;
}

//re-aligns variables, given the index of the first variable after the change (varIdx), the offset at the end of the change (tell), and the amount of bytes lost/gained (sizeChange):
void fixAlignment(uint varIdx, uint tell, uint sizeChange) {
    local int diff;
    local int oldPadding;
    
    //apply original size difference to all offsets after the change:
    for (m=varIdx+1; m<varLen; m++) 
        offs[m] += sizeChange;
    
    //remove all old padding from after the change:
    for (m=varLen-3; m>varIdx; m--) {
        oldPadding = offs[m+1] - (offs[m] + sizes[m]);
        
        if (oldPadding > 0) {
            //Printf("%u deleting %i bytes from %u\n", m, oldPadding, offs[m+1] - oldPadding);
            DeleteBytes(offs[m+1] - oldPadding, oldPadding);
        }
        for (o=varLen-1; o>m; o--) 
            offs[o] -= oldPadding;
    }
    
    //remove old padding from struct directly following the change:
    oldPadding = offs[varIdx+1] - tell;
    if (oldPadding > 0) {
        DeleteBytes(tell, oldPadding);
        for (o=varIdx+1; o<varLen; o++) 
            offs[o] -= oldPadding;
    }
    
    //add new padding for each variable based on its type:
    for (m=varIdx+1; m<varLen; m++) {
        offs[m] += diff;
        while (aligns[m] && offs[m] % aligns[m] != 0) {
            InsertBytes(offs[m], 1, 0);
            offs[m] += 1;
            diff += 1;
        }
    }
    MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
}

void setSize() {
    if (exists(Alignment.varStart)) {
        Alignment.varSz = FTell() - startof(Alignment.varStart);
        if (ShowAlignment && !finished && sizes[Alignment.varIdx] == -1) 
            sizes[Alignment.varIdx] = Alignment.varSz;
    }
}

void setAlignment(uint algn) {
    if (ShowAlignment)
        struct VARDATA Alignment(algn) <name="Alignment">;
    else
        struct VARDATA Alignment(algn) <name="Alignment", hidden=true>;
    FSkip(-1);
}

int getLevel(uint offset) {
    local int L = 0;
    for (L=0; L<level; L++)
        if (offset >= startof(RSZFile[L].Data) && offset < startof(RSZFile[L].Data) + sizeof(RSZFile[L].Data))
            break;
    return L;
}

int getLevelRSZ(uint offset) {
    local int L = 0;
    for (L=0; L<level; L++)
        if (offset >= startof(RSZFile[L]) && offset < startof(RSZFile[L])+64)
            break;
    return L;
}

typedef struct {
    uchar uuid[16] <open=suppress>;
    if (finished && exists(GameObjectInfos.Guid)) {
        local ushort lvl <hidden=true> = level; if (exists(parentof(this).lvl)) lvl = parentof(this).lvl;
        for (o=0; o<Header.infoCount; o++)
            if (GameObjectInfos[o].Guid.uuid == uuid) {
                local string GameObjectRef <open=suppress>;
                if (exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id]].var[0].data))
                    SPrintf(GameObjectRef, "via.GameObject[%u] -- %s", RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id], RSZFile[lvl].Data.RawData.RSZ[ObjectTable[GameObjectInfos[o].id.id]].var[0].data);
                else if (exists(RSZFile[lvl]))
                    SPrintf(GameObjectRef, "%s[%u]", RSZFile[lvl].InstanceInfos.instanceInfo[ RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id] ].typeId.HashName, RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id]);
                break;
            }
    }
} rGUID <read=ReadrGUID, write=WriterGuid, comment=ReadrGUIDComment>;

    string TranslateGUID (uchar uuid[]) {
        local char s[37];
        SPrintf(s, 
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
            uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7],
            uuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]
        );
        return s;
    }

    string ReadrGUID (rGUID &g) {
        local string Guid = TranslateGUID(g.uuid);
        return Guid;
    }

    string ReadrGUIDComment(rGUID &g) { if (exists(g.GameObjectRef)) return g.GameObjectRef; return ""; }

    void WriterGuid (rGUID &g, string s) {
        local string out;
        local byte ii, offset, var;
        for (ii=0; ii<16; ii++) {
            if (ii==4 || ii== 6 || ii==8 || ii==10) 
                offset++;
            SScanf(SubStr(s, ii*2 + offset, 2), "%x", var);
            WriteByte(startof(g) + ii, var);
        }
    }

//functions for opening files:
string getRE2ext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".tex": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769669";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": case ".fbxskel": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1808312334";
		case ".fsmv2": case ".bhvt": case ".motfsm2": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".lprb": return ".3";
		case ".mmtr": return ".1808160001";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

string getRE3ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".12";
		case ".pfb": return ".17";
		case ".mdf2": return ".13";
		case ".tex": return ".190820018";
		case ".rcol": case ".jmap": return ".11";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1902042334";
		case ".fsmv2": case ".bhvt": case ".tml": case ".clip": return ".34";
		case ".motfsm2": return ".36";
		case ".scn": return ".20";
		case ".mov": return ".1";
		case ".chain": return ".24";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".99";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".78";
		case ".gui": return ".340020";
		case ".rmesh": return ".17008";
		case ".rtex": return ".4";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".14";
		case ".msg": return ".15";
		default: return "";
	}
}

string getRE8ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".16";
		case ".pfb": return ".17";
		case ".mdf2": return ".19";
		case ".tex": return ".30";
		case ".rcol": return ".18";
		case ".jmap": return ".17";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".2101050001";
		case ".bhvt": case ".tml": return ".34";
		case ".fsmv2": case ".clip": return ".40";
		case ".motfsm2": return ".42";
		case ".scn": return ".20";
		case ".mov": case ".finf": return ".1";
		case ".chain": return ".39";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".486";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".458";
		case ".gui": return ".400023";
		case ".rmesh": return ".17008";
		case ".rtex": return ".5";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".17";
		case ".msg": return ".15";
		case ".gpuc": return ".62";
		default: return "";
	}
}

string getDMCext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769672";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": return ".2";
		case ".wel": case ".tex":  return ".11";
		case ".mesh": return ".1808282334";
		case ".fsmv2": case ".bhvt": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".fbxskel": case ".lprb": return ".3";
		case ".motfsm2": return ".31";
		case ".mmtr": return ".1808168797";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

//convert a filepath string to Windows format:
string MakeBackslashes (wstring path) {
	local wstring localPath <hidden=true> = path;
	if (find(path, "@") != -1)
		localPath = StrDel(localPath, 0, 1);
	local uint index = find(localPath, "/");

	while (index != -1) {
		localPath = StrDel(localPath, index, sizeof(localPath) - index + 1) + "\\" + SubStr(localPath, index + 1, -1);
		index = find(localPath, "/");
	} return localPath;
}

void ReadRSZPath(wstring data) {
	local wstring localPath <hidden=true> = data;
	if (RSZVersion == "DMC5") {
		localPath = MakeBackslashes(localPath) + getDMCext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE3") {
		localPath = MakeBackslashes(localPath) + getRE3ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE2") {
		localPath = MakeBackslashes(localPath) + getRE2ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE8") {
		localPath = MakeBackslashes(localPath) + getRE8ext(FileNameGetExtension(localPath));
	}
	if (exists(fullPath)) { 
	    fullPath = Local_Directory + localPath;
	    if (Local_Directory != extractedDir && FileExists(Local_Directory + localPath)) {
		    local uint existsInMod <hidden=false> = 1;
		    fullPath = Local_Directory + localPath;
	    }
	    if (extractedDir != "" && FileExists((extractedDir + localPath))) {
		    if (exists(existsInMod)) {
			    local uint existsInPak <hidden=false> = 1;
		    } else { 
			    local uint existsInPak <hidden=true> = 1; 
			    fullPath = extractedDir + localPath;
		    }
	    }
	    if (fullPath != "" && FileExists(fullPath)) {
		    FSkip(-1);
		    ubyte OpenFile <name="OpenFile", write=WriteOpenFile, read=ReadOpenFile, open=false>;
	    }
    }
}

    string ReadOpenFile (ubyte &in) { return "Input here to open File"; }
    
    void WriteOpenFile(ubyte &in, wstring s) { FileOpener(parentof(in).fullPath); }

int detectedGuid(uint tell) {
    local int zerosCount;
    for (o=0; o<16; o++) 
        zerosCount += (ReadUByte(FTell()+o) == 0);
    return zerosCount;
}

int detectedObject(uint tell) {
    local int test = ReadInt(tell);
    //if (detectedString(tell))
    //    setAsBroken();
    if (tell+4 <= FileSize() && test < idx && test > 0 && (test > idx - 100 || exists(userDataPath)))
        return true;
    return false;
}

void redetectObject() {
    if (!finished && broken ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4) {
            if (detectedObject(FTell())) {
                SetForeColor(cYellow);
                Printf("Redetected object from %u to %u\n",  pos, FTell()); 
                break;
            } else FSkip(4);
        }
    }
}

void setAsBroken() {
    FSkip(-1);
    broken = true;
    SetForeColor(cNone);
    ubyte blank <hidden=true, bgcolor=cRed>;
}

void redetectFloat() {
    if (broken && FTell() + 4 <= FileSize() && (broken && !finished)) { 
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && detectedFloat(FTell()))
            FSkip(4);
        
        if (FTell() != pos && FTell() < pos + 16) {
            broken = FALSE;
            SetForeColor(cYellow);
            Printf("Redetected float from %u to %u\n",  pos, FTell()); 
        } else FSeek(pos);
    }
    if (!detectedFloat(FTell()) && ReadFloat(FTell()) != 0) {
        broken = TRUE;
        SetForeColor(cNone);
    }
}

void redetectGuid() {
    if (FTell() + 16 <= FileSize() && !finished && (detectedGuid(FTell()) >= 4)) { // && broken
        local int pos = FTell();
        //if (broken) 
        //    FSkip(-12);
        while(FTell() <= FileSize() - 16) {
            if (detectedGuid(FTell()) == 16 || (detectedGuid(FTell()) < 4 && (detectedGuid(FTell()) <= detectedGuid(FTell() + 8)))) {
                if (pos != FTell()) {
                    broken = FALSE;
                    SetForeColor(cYellow);
                    Printf("Redetected GUID from %u to %u\n",  pos, FTell()); 
                }
                break;
            } else FSkip(8);
        }
    }
}

int isValidString(uint tell) {
    local int alignedOffs = getAlignedOffset(tell, 4);
    if (alignedOffs + 4 >= FileSize())
        return false;
    local uint size = ReadUInt(alignedOffs);
    if (sizeof(ReadWString(alignedOffs+4)) == 0)
        return false;
    local wstring String = ReadWString(alignedOffs+4);
    return (alignedOffs+8 <= FileSize() && ReadUInt64(alignedOffs) == 1 || size == 0 || (size == sizeof(String)/2 && ReadUByte(alignedOffs+7 != 0)) );
}

void redetectStringBehind() {
    local int pos = FTell();
    if (detectedString(FTell())) {
        while (detectedString(FTell()) && ReadUInt(FTell()-4) != sizeof(ReadWString(FTell())) / 2) 
            FSkip(-2);
        FSkip(-4);
        if (pos == FTell() || !isValidString(FTell()) || (sizeof( ReadWString(FTell()+4)) + FTell() <= pos) ) {
            //Printf("Aborting string redetection from %u to %u\n",  pos, FTell()); 
            FSeek(pos);
            setAsBroken();
        } else if (FTell() < pos) {
            SetForeColor(cYellow);
            broken = FALSE;
            Printf("Redetected string from %u back to %u\n",  pos, FTell()); 
        }
    } 
}

void redetectString() {
    if (!broken && !isValidString(FTell()+4)) 
        return;
    if  (FTell() + 4 <= FileSize() && ( !finished && (broken || !isValidString(FTell()) ) ) ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && FTell() - 24 < pos) {
            if (((detectedString(FTell()) && isValidString(FTell()-4)))) {
                FSkip(-4);
                break;
            } else uint skip <hidden=true>; //fgcolor=cRed,
        }
        if (FTell() - pos > 16 && broken) {
            FSeek(pos); //abort
        } else if (FTell() - pos > 8 && !broken) {
            FSeek(pos); //abort
        } else {
            SetForeColor(cYellow);
            broken = FALSE;
            Printf("Redetected string from %u to %u\n",  pos, FTell()); 
        }
    }
}

void ForceWriteString(uint tell, uint maxSize, wstring str) {
    OverwriteBytes(tell, maxSize, 0); 
    if (str != " " && str != "")
        WriteWString(tell, str); 
}

typedef ubyte Bool <read=ReadBOOL, write=WriteBOOL>;

    wstring ReadBOOL(Bool &b) {
        if (b)
            return "True";
        return "False";
    }
    
    void WriteBOOL(Bool &b, wstring s) {
        if (find(Lower(s), "true") != -1 || Atoi(s) >= 1)
            b = 1;
        else b = 0;
    }
    
//main typedef for RSZ chunks:
typedef struct(uint32 classHash, ubyte fieldIndex) {
    local uint32 classHash <hidden=true> = classHash;
    local ubyte fieldIndex <hidden=true> = fieldIndex;
    local string fieldName <hidden=true> = GetFieldName(classHash, fieldIndex);
    local string fieldDataType <hidden=true> = GetFieldTypeName(classHash, fieldIndex);
    local TypeIDs fieldType <hidden=true> = GetFieldType(classHash, fieldIndex);
    local ushort elementSize <hidden=true> = GetFieldSize(classHash, fieldIndex);
    local ubyte align <hidden=true> = GetFieldAlignment(classHash, fieldIndex);
    local ubyte isList <hidden=true> = GetFieldArrayState(classHash, fieldIndex);
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());

    if ((isList) && !exists(parentof(this).Count)) {
		setAlignment(4);
        if (FTell()+4 <= FileSize()) {
            uint Count;
		    setSize();
            if (Count > -1 && Count < FileSize() && elementSize > 0 && Count * elementSize <= FileSize() - FTell() && !detectedString(FTell())) {
                local uint c <hidden=true>, alignedOffs <hidden=true>;
                for (c=0; c<Count; c++) {
                    alignedOffs = getAlignedOffset(FTell(), align);
                    if (alignedOffs+elementSize <= FileSize()) { // && (fieldType != Object_tid || (ReadInt(FTell()) < idx && ReadInt(FTell()) > 0 )
                        FSeek(getAlignedOffset(FTell(), align));
                        if (Count == 1 && fieldType == Object_tid || (fieldType == Data_tid && detectedObject(FTell()))) {
			                struct RSZVariable var(classHash, fieldIndex) <open=true>;
                            checkUseSpacers();
                        } else
                            struct RSZVariable var(classHash, fieldIndex);
                        //if (var.fieldDataType == "String" && !isValidString(startof(var))) {
                        //    setAsBroken();
                        //    break;   
                        //}
                    } else {
                        setAsBroken();
                        break;    
                    }
                }
            } else setAsBroken();
        }
	} else {
        setAlignment(align);
		switch (fieldType) {
			case Bool_tid:
				if (FTell()+1 <= FileSize())
				    Bool data;
				break;
			case Color_tid:
                if (FTell()+4 <= FileSize())
				    ubyte data <name="ubyte R">, data <name="ubyte G">, data <name="ubyte B">, data <name="ubyte A">;
				break;
			case F32_tid:
				fieldDataType = "Float";
				if (FTell()+4 <= FileSize())
				    float data;
				break;
			case F64_tid:
				fieldDataType = "Double";
				if (FTell()+8 <= FileSize())
				    double data;
				break;
            case PlaneXZ_tid:
				if (FTell()+8 <= FileSize())
				    float data <name="float x">, data <name="float z">;
				break;
			case Float2_tid:
			case Point_tid:
            case Segment_tid:
				if (FTell()+8 <= FileSize())
				    float data <name="float x">, data <name="float y">;
				break;
			case Float3_tid:
				if (FTell()+12 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				break;
			case Quaternion_tid:
			case Float4_tid:
				if (FTell()+16 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				break;
			case GameObjectRef_tid:
            case Guid_tid:
            case Uri_tid:
				if (FTell()+16 <= FileSize())
				    rGUID data;
                break;
            case OBB_tid:
            case AABB_tid:
            case Capsule_tid:
            case LineSegment_tid:
			case Mat4_tid:
				if (FTell()+32 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                    if (fieldType == Capsule_tid) {
                        if (FTell()+4 <= FileSize())
				            float data <name="float r">;
                    } else if (fieldType != AABB_tid) {
					    if (FTell()+32 <= FileSize()) {
				            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
					        float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (fieldType == OBB_tid && FTell()+16 <= FileSize())
                                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        } 
                    }
                }
				break;
			case UserData_tid:
            case Object_tid:
                if (FTell()+4 <= FileSize())
                    int ObjectIndex;
                if (fieldType == UserData_tid && exists(ObjectIndex) && ObjectIndex > -1) {
                    if ((RSZVersion == "DMC5" || RSZVersion == "RE2") && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx) 
                    && exists(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].dataOffs)) {
                        FSeek(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].dataOffs);
                        struct RSZMagic UserData <open=true, size=52>;
                        FSeek(startof(ObjectIndex)+4);
                        checkUseSpacers();
                        break;
                    } else if (exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx)) {
                        FSkip(-1);
                        struct StringRead path ( (startof(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx])+8), startof(RSZFile[lvl].RSZHeader), 0);
                        break;
                    } 
                } else if (fieldType == Object_tid &&  exists(ObjectIndex) && ObjectIndex > 0 && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) {
					FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])); 
                    temp = GetForeColor();
                    SetForeColor(cNone);
					struct RSZInstance RSZ(ObjectIndex) <open=true, size=SizeRSZInstance>;
					FSeek(startof(ObjectIndex)+4);
                    SetForeColor(temp);
                    checkUseSpacers();
				}
				break;
			case Range_tid:
                if (FTell()+8 <= FileSize())
				    float data <name="float R">, data <name="float S">;
				break;
			case RangeI_tid:
                if (FTell()+8 <= FileSize())
				    int data <name="int R">, data <name="int S">;
				break;
			case RuntimeType_tid:
                if (FTell()+4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size <= FileSize())
					    char data[size];
                }
				break;
			case S16_tid:
                if (FTell()+2 <= FileSize())
				    short data;
				break;
			case S32_tid:
				fieldDataType = "Int";
				if (FTell()+4 <= FileSize())
				    int data;
				break;
			case S64_tid:
				fieldDataType = "Int64";
				if (FTell()+8 <= FileSize())
				    int64 data;
				break;
			case S8_tid:
				fieldDataType = "Byte";
				if (FTell()+1 <= FileSize())
				    byte data;
				break;
			case Size_tid:
				fieldDataType = "Size";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U16_tid:
				fieldDataType = "UShort";
				if (FTell()+2 <= FileSize())
				    ushort data;
				break;
			case U32_tid:
				fieldDataType = "UInt";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U64_tid:
				fieldDataType = "UInt64";
				if (FTell()+8 <= FileSize())
				    uint64 data;
				break;
			case U8_tid:
				fieldDataType = "UByte";
				if (FTell()+1 <= FileSize())
				    ubyte data;
				break;
			case Vec2_tid:
				if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">;
				    float data <hidden=true>, data <hidden=true>; //FSkip(8);
                }
				break;
			case Vec3_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				    float data <hidden=true>; //FSkip(4);
                }
				break;
			case Vec4_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                }
				break;
			case Int2_tid:
                if (FTell()+8 <= FileSize())
				    int32 data <name="int x">, data <name="int y">;
                break;
            case Int3_tid:
                if (FTell()+12 <= FileSize())
				    int32 data <name="int x">, data <name="int y">, data <name="int z">;
                break;  
            case Uint3_tid:
                if (FTell()+12 <= FileSize())
				    uint32 data <name="uint x">, data <name="uint y">, data <name="uint z">;
                break;
            case Data_tid:
            case ukn_type: 
                if (find((wstring)fieldDataType, "tring") == -1) { //if NOT a string:
                    if (elementSize == 1 ) { 
                        fieldDataType = "Byte";
                        if (FTell()+1 <= FileSize())
				            byte data;
                    } else if (elementSize == 2) {
                        fieldDataType = "Int16";
                        if (FTell()+2 <= FileSize())
				            short data;
                    } else if (elementSize == 4) {
                        fieldDataType = "Data";
                        if (FTell()+4 <= FileSize())
                            if (ReadUInt(FTell()) != 0 && detectedFloat(FTell()) ) { //&& ReadUByte(FTell()+3) != 255
                                if (FTell()+4 <= FileSize()) {
				                    float data;
                                    FSkip(-4);
                                    int data_As_Int;
                                }
                            } else if (detectedObject(FTell())){
                                fieldDataType = "Data (Object?)";
                                if (FTell()+4 <= FileSize()) {
				                    int ObjectIndex <name="int data (ObjectIndex?)">;
					                if (exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) {
						                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]));
						                struct RSZInstance RSZ(ObjectIndex) <open=true, size=SizeRSZInstance>;
						                FSeek(startof(ObjectIndex)+4);
						                FSkip(-1);
						                BLANK blank;
                                        //checkUseSpacers();
					                }
                                }
                            } else {
                                if (FTell()+4 <= FileSize()) {
				                    int data;
                                    FSkip(-4);
                                    float data_As_Float;
                                }
                            }
                    } else if (elementSize == 8) {
                        if (detectedFloat(FTell()) && detectedFloat(FTell()+4)) {
                            if (FTell()+8 <= FileSize())
				                float data <name="float x">, data <name="float y">;
                        } else {
                            fieldDataType = "Int64";
                            if (FTell()+8 <= FileSize())
				                int64 data;
                        }
                    } else if (elementSize == 16) {
                        if (align == 8) {
                            fieldDataType = "Guid";
                            //redetectGuid();
                            if (FTell()+16 <= FileSize())
				                rGUID Guid;
                        } else {
                            fieldDataType = "Vec4";
                            if (FTell()+16 <= FileSize())
				                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        }
                    } else if (elementSize == 64 || elementSize == 80) {
                        fieldDataType = "Mat4";
                        if (FTell()+4 <= FileSize()) {
                            float data <name="float x1">, data <name="float y1">, data <name="float z1">, data <name="float w1">;
                            float data <name="float x2">, data <name="float y2">, data <name="float z2">, data <name="float w2">;
                            float data <name="float x3">, data <name="float y3">, data <name="float z3">, data <name="float w3">;
                            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (elementSize == 80) {
                                fieldDataType = "OBB";
                                if (FTell()+16 <= FileSize())
				                    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            }
                        }
                    } else {
                        if (FTell()+elementSize <= FileSize())
                            if (elementSize % 4 == 0) {
                                local ubyte counter <hidden=true>;
                                while(counter < (uint)(elementSize / 4)) {
                                    if (detectedFloat(FTell()))
                                        float data;
                                    else int data;
                                    counter++;
                                }
                            }
				            else ubyte data[elementSize];
                    }
                    break;
                } //if it IS a string, don't break and continue on:
            
			case Resource_tid:
			case String_tid:
                fieldType = String_tid;
				fieldDataType = "String";
                FSeek(getAlignedOffset(FTell(), 4));
                redetectStringBehind();
				FSeek(getAlignedOffset(FTell(), 4)); 
                if (isValidString(FTell()) && ReadUInt(FTell()) != 0)
                    broken=false;
                else redetectString();
                if (FTell() + 4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size * 2 <= FileSize() )
					    wchar_t data[size] <open=suppress>;
                    if (size > 0 && !exists(data) && !detectedFloat(FTell()-4)) 
                        setAsBroken();
                    local ubyte isString <hidden=true> = TRUE;
                    if (!isValidString(startof(size)) && (size > 128) || (broken && size > 64))
                        FSeek(startof(size)+1);
                } else FSeek(startof(this));
				break;
            
			default:
				Printf("%u Unknown type %s in class \"%s\" (Hash: 0x%08X) field number %d returned TypeID = \"%d\" ListFlag = \"%d\"\r\n", FTell(), EnumToString(fieldType), GetRSZClassName(classHash), classHash, fieldIndex, fieldType, isList);
                if (elementSize % 4 == 0)
                    float data[elementSize/4];
                else
                    ubyte data[elementSize];
				break;
		}
        
        if (elementSize > 16)
            FSeek(startof(Alignment.varStart) + elementSize);
        else if (elementSize == 4 && exists(data) && ReadInt(startof(data)) <= 512)
            enums();
    }
    setSize();
    
    if (title == "" && exists(this.size) && exists(this.data) && size > 1 ) {
        title = (wstring)data;
    } else if (secondTitle == "") {
        if (exists(this.UserData)) {
            secondTitle = ReadRSZMagic(this.UserData);
        } else if (exists(this.Guid) && ReadUInt64(startof(Guid)) != 0) {
            secondTitle = ReadrGUID(Guid);
        } else if (exists(this.RSZ) && this.ObjectIndex > 2) {
            if (!isList || parentof(this).Count == 1) {
                secondTitle = ReadRSZInstance(this.RSZ);
                if (Atoi(secondTitle) != 0 || secondTitle == "False" || secondTitle == "True") 
                    secondTitle = "";
            } else if (parentof(this).Count > 1 && exists(parentof(this).var[parentof(this).Count-2])) {
                SPrintf(s, "%s - [%i]", ReadRSZInstanceName(parentof(this).var[0].RSZ), this.ObjectIndex) ;
                secondTitle = s;
            }
        }
    }
    
    if (fieldDataType == "String" && exists(data) && find((wstring)data, "/") != -1 && FileNameGetExtension((wstring)data) != ".json") {
        local wstring fullPath <hidden=true>;
        ReadRSZPath((wstring)data);
    }
    if (FTell() <= startof(this)) {
        Printf("Empty struct %s\n", ReadRSZInstanceName(parentof(this))); 
        FSeek(startof(this));
    }
} RSZVariable <optimize=false, name=ReadRSZVariableName, read=ReadRSZVariable, write=WriteRSZVariable, comment=ReadRSZVariableComment>;;

    string ReadRSZVariableComment(RSZVariable &r) { if (exists(r.data.GameObjectRef)) return r.data.GameObjectRef; return ""; }
    
    string ReadRSZVariableName(RSZVariable &r) { 
        local string s; 
        if (r.isList) {
            if ((exists(r.var[0]) && exists(r.var[0].ObjectIndex) && r.var[0].ObjectIndex != 0) || exists(r.var[0].UserData) ) {
                if (r.fieldDataType == "Data") {
                    SPrintf(s, "List (Object?) *%s", r.fieldName); // %s[%u] //, RSZFile[r.lvl].Data.RawData.RSZ[r.var[0].ObjectIndex].name, r.var[0].ObjectIndex
                } else { SPrintf(s, "List (%s) *%s", r.fieldDataType, r.fieldName); }
            } else if (exists(r.RSZ)) {
                s = ReadRSZInstanceName(r.RSZ) + " " + r.fieldName;
            } else { s = "List" + " (" + r.fieldDataType + ") " + r.fieldName; }
        } else if (exists(r.ObjectIndex) && exists(parentof(r).fieldDataType) && parentof(r).fieldDataType == "List") {
            SPrintf(s, "%s[%u]", RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].name, r.ObjectIndex);
        } else if (r.fieldDataType != "") {
            if ((exists(r.RSZ) && r.ObjectIndex != 0) || exists(r.UserData) )
                s = r.fieldDataType + " *" + r.fieldName; 
            else if (r.fieldDataType + " " + r.fieldName == "Byte v0")
                s = "Byte v0 (isEnabled)";
            else s = r.fieldDataType + " " + r.fieldName;  
        } else s = r.fieldName; 
        return s;
    }

    wstring ReadRSZVariable(RSZVariable &r) {
        local string s;
        if (exists(r.UserData)) {
            return ReadRSZMagic(r.UserData);
        } else if (exists(r.var)) {
            if (exists(r.var[1].RSZ)) {
                SPrintf(s, "%s - [%i]", ReadRSZInstanceName(r.var[0].RSZ), r.var[r.Count-1].ObjectIndex); 
                return s;
            } 
            return ReadRSZVariable(r.var[0]);
        } else if (exists(r.RSZ) && r.ObjectIndex > 0) {
            return ReadRSZInstance(r.RSZ);
        } else 
            switch (r.fieldType) {
                case Bool_tid:
                    if (exists(r.data))
                        s = ReadBOOL(r.data);
                    break;
		        case S16_tid:
		        case S32_tid:
		        case S64_tid:
		        case Size_tid:
		        case S8_tid:
		        case U16_tid:
		        case U32_tid:
		        case U64_tid:
                    if (exists(r.data))
                        SPrintf(s, "%Li", r.data);
                    break;
                case F32_tid:
                    if (exists(r.data))
                        SPrintf(s, "%f", r.data);
                    break;
		        case Resource_tid:
                case String_tid:
                    if (exists(r.data))
                        return r.data;
                    break;
                case Float2_tid:
                case Vec2_tid:
                case Point_tid:
                case Range_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                    break;
                case Vec3_tid:
                case Float3_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g]", r.data[0], r.data[1], r.data[2]);
                    break;
                case Color_tid:
                case Vec4_tid:
                case Mat4_tid:
                case Float4_tid:
				case Quaternion_tid:
                case Int3_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                    break;
                case Guid_tid:
                case GameObjectRef_tid:
                case Uri_tid:
                    if (exists(r.data))
                        s = ReadrGUID(r.data);
                    break;
                case AABB_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g] [%g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[4],  r.data[5],  r.data[6]);
                    break;
                case Mat4_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g %g] [%g, %g, %g %g] [%g, %g, %g %g] [%g, %g, %g %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                    break;
                case ukn_type:
                case Data_tid:
                    if (exists(r.data) && r.elementSize == 1 ) { //|| r.fieldOrgTypeName == "Data1A1"
                        if (r.data == 1) {
                            s = "True";
                        } else if (r.data == 0) {
                            s = "False";
                        } else 
                            SPrintf(s, "%i", r.data);
                    } else if (exists(r.data) && r.elementSize == 4) {
                        if (exists(r.data_As_Int))
                            SPrintf(s, "%f", r.data);
                        else if (Abs(r.data) > 1000000) 
                            SPrintf(s, "%X", r.data);    
                        else 
                            SPrintf(s, "%i", r.data);
                    } else if (exists(r.data) && r.elementSize == 8) {
                        if (exists(r.data[1]) && (detectedFloat(FTell()) || detectedFloat(FTell()+4)))
                            SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                        else
                            SPrintf(s, "%Li", r.data);
                    } else if (r.elementSize == 16) {
                        if (exists(r.Guid))
                            s = ReadrGUID(r.Guid);
                        else if (exists(r.data[3]))
                            SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                    } else if (exists(r.data) && r.elementSize == 64) {
                        SPrintf(s, "[%g, %g, %g %g] [%g, %g, %g %g] [%g, %g, %g %g] [%g, %g, %g %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], 
                            r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                    }
                    break;
                default:
                    break;
            }
        return s;
    }
    
    void WriteRSZString(RSZVariable &r, wstring s) { 
        local int oldDataSz;
        if (exists(r.data)) 
            wstring oldData = r.data;
        else
            wstring oldData = "";
        
        if (exists(r.data)) {
            oldDataSz = sizeof(r.data);
            local int temp;
            if (exists(Header.resourceCount))
                for (o=0; o<Header.resourceCount; o++) {
                    if (exists(ResourceInfos.ResourceInfo[o].pathStr) && ResourceInfos.ResourceInfo[o].pathStr.String == oldData) {
                        while (ReadByte(startof(ResourceInfos.ResourceInfo[o].pathStr.String)+oldDataSz+temp) == 0)
                            temp++;
                        oldDataSz += temp;
                    } else if (exists(ResourceInfos.ResourceInfo[o].path) && ResourceInfos.ResourceInfo[o].path == oldData) {
                        while (ReadByte(startof(ResourceInfos.ResourceInfo[o].path)+oldDataSz+temp) == 0)
                            temp++;
                        oldDataSz += temp;
                    }
                } 
        }
        Printf("Sizeof(input)=%i, sizeof(oldData)=%i \n", sizeof(s)-2, oldDataSz);
        local int sizeToInsert = (sizeof(s)-2) - oldDataSz;
        
        if (sizeToInsert > 0) {
            if (exists(r.data))
                Printf("Size to Insert: %i\nr.data: %s\ns.data: %s\n", sizeToInsert, r.data, s);
            
            while (sizeToInsert % 16 != 0)
                sizeToInsert++;
            Printf("Size to Insert (padded): %i\n", sizeToInsert);
            if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
                local int ii;
                while (exists(RSZFile[ii])) {
                    if (startof(r.size)+4 > startof(RSZFile[ii]) && startof(r.size)+4 < startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) && startof(RSZFile[r.lvl]) != startof(RSZFile[ii])) {
                        Printf("%i %i %i\n", startof(r.size)+4, startof(RSZFile[ii]), startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) );
                        RSZFile[ii].RSZHeader.dataOffset += sizeToInsert;
                    }
                    ii++;
                }
            }
            InsertBytes(startof(r.size)+4, sizeToInsert, 0); 
        } else 
            sizeToInsert = 0;
        
        ForceWriteString(startof(r.size)+4, sizeToInsert+oldDataSz, s); 
        r.size = (sizeToInsert+oldDataSz)/2;
        
        if (find(oldData, "/") != -1) { //sizeToInsert > 0 && 
            local byte resourceInfosIncreased = FALSE;
            local int changeOffs, h;
            for (h=0; h<Header.resourceCount; h++)
                if (ResourceInfos.ResourceInfo[h].pathStr.String == oldData) {
                    resourceInfosIncreased = TRUE;
                    break;
                }
            
            if (resourceInfosIncreased == TRUE && exists(Header.userdataCount)) { // if not PFB
                local int paddingBytes;
                while((RSZFile[r.lvl].RSZHeader.dataOffset + sizeToInsert + paddingBytes) % 16 != RSZFile[r.lvl].RSZHeader.dataOffset % 16)
                    paddingBytes++;
                
                for (h=0; h<Header.resourceCount; h++) {
                    if (ResourceInfos.ResourceInfo[h].pathStr.String == oldData) {
                        Printf("Found old ResourceInfo\n");
                        changeOffs = startof(ResourceInfos.ResourceInfo[h].pathStr.String);
                        //DeleteBytes(startof(ResourceInfos.ResourceInfo[h].pathStr.String), sizeof(ResourceInfos.ResourceInfo[h].pathStr.String));
                        if (sizeToInsert > 0) {
                            InsertBytes(startof(ResourceInfos.ResourceInfo[h].pathStr.String) + sizeof(ResourceInfos.ResourceInfo[h].pathStr.String), sizeToInsert);
                        }
                        ForceWriteString(startof(ResourceInfos.ResourceInfo[h].pathStr.String), oldDataSz, s);
                    }
                    if (changeOffs > 0 && changeOffs < startof(ResourceInfos.ResourceInfo[h].pathStr.String))
                        ResourceInfos.ResourceInfo[h].pathStr.strOffset += sizeToInsert;
                }
                if (changeOffs > 0 && sizeToInsert) {
                    for (h=0; h<Header.prefabCount; h++) 
                        PrefabInfos.PrefabInfo[h].id += sizeToInsert;
                }
                if (paddingBytes)
                    InsertBytes(RSZFile[r.lvl].RSZHeader.dataOffset + startof(RSZFile[r.lvl].RSZHeader), paddingBytes, 0);
                RSZFile[r.lvl].RSZHeader.dataOffset += paddingBytes;
            }
            
        }
        if (sizeToInsert > 0) {
            if (exists(resourceInfosIncreased) && resourceInfosIncreased == TRUE)
                Header.dataOffset += sizeToInsert;
            if (exists(userDataInfos)) {
                
                for (h=0; h<Header.userdataCount; h++)
                    userDataInfos.userDataInfo[h].pathOffset.strOffset += sizeToInsert;
                for (h=0; h<Header.prefabCount; h++)
                    PrefabInfos.PrefabInfo[h].id += sizeToInsert;
            }
            MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
        } 
    }

    void WriteRSZVariable(RSZVariable &r, wstring s) {
        if (exists(r.fullPath) && r.fullPath != "" && sizeof(s) <= 6) {
            FileOpener(r.fullPath);
        } else {
            local int pos = startof(r.Alignment.varStart);
            switch (r.fieldType) {
                case Bool_tid:
                    WriteBOOL(r.data, s); break;
		        case S16_tid:
                    WriteShort(pos, Atoi(s)); break;
		        case Object_tid:
		        case UserData_tid:
                case Size_tid:
		        case S32_tid:
                    WriteInt(pos, Atoi(s)); break;
		        case S64_tid:
                    WriteInt64(pos, Atoi(s)); break;
		        case S8_tid:
                    WriteByte(pos, Atoi(s)); break;
		        case U16_tid:
                    WriteUShort(pos, Atoi(s)); break;
		        case U32_tid:
                    WriteUInt(pos, Atoi(s)); break;
		        case U64_tid:
                    WriteUInt64(pos, Atoi(s)); break;
                case F32_tid:
                    WriteFloat(pos, Atof(s)); break;
                case String_tid:
                case Resource_tid:
                    WriteRSZString(r, s);
                    break;
                case Vec2_tid:
                case Range_tid:
                case Float2_tid:
                case Point_tid:
                    WriteRSZArray(r, s, 2, 4);
                    break;
                case Vec3_tid:
                case Float3_tid:
                    WriteRSZArray(r, s, 3, 4);
                    break;
                case Vec4_tid:
                case Float4_tid:
                case Quaternion_tid:
                    WriteRSZArray(r, s, 4, 4);
                    break;
                case Color_tid:
                    WriteRSZArray(r, s, 4, 1);
                    break;
                case AABB_tid:
                    WriteRSZArray(r, s, 8, 4);
                    break;
                case Mat4_tid:
                    WriteRSZArray(r, s, 16, 4);
                    break;
                case Guid_tid:
                case GameObjectRef_tid:
                case Uri_tid:
                    WriterGuid(r.data, (string)s);
                    break;
                case Data_tid:
                case ukn_type:
                    s = Lower(s);
                    if (exists(r.data) && r.elementSize == 1) {
                        if (s == "true") {
                            r.data = 1;
                        } else if (s == "false") {
                            r.data = 0;
                        } else r.data = Atoi(s);
                    } else if (exists(r.ObjectIndex) || exists(r.data_As_Int) || exists(r.data_As_Float)) {
                        
                        if (exists(r.data_As_Int)) {
                            WriteFloat(startof(r.Alignment.varStart), Atof(s));
                        } else {
                            WriteInt(startof(r.Alignment.varStart), Atoi(s));
                        }
                    } else if (exists(r.size) || find((wstring)r.fieldDataType, "tring") != -1) {
        	            WriteRSZString(r, s);
                    } else if (r.fieldDataType == "Vec4") {
                        WriteRSZArray(r, s, 4, 4);
                    }
                    break;
                default:
                    break;
            }
        }
    }

    void WriteRSZArray(RSZVariable &r, wstring array, uint count, uint elementSize) {
        local uint q; 
        local float outArr[count];
        local string fmtString;
        local string FMT = "%g";
        if (elementSize == 1)
            FMT = "%i";
        if (array[0] == 91)
            fmtString += "[";
        if (find(array, ",") == -1) {
            for (q=0; q<count-1; q++)
                fmtString += FMT + " ";
            fmtString += FMT;
        } else {
            for (q=0; q<count-1; q++)
                fmtString += FMT + ", ";
            fmtString += FMT;
        }
        if (count == 2)
            SScanf(array, fmtString, r.data[0], r.data[1]);
        else if (count == 3)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2]);
        else if (count == 4)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2], r.data[3]);
        else if (count == 8)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7]);
        else if (count == 16)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10],  r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
    }

typedef struct(int ObjectIdx) {
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else lvl = getLevel(FTell());
    local int idx <hidden=true> = ObjectIdx;
    
    if (finished && (idx >= RSZFile[lvl].RSZHeader.instanceCount || idx == -1))
        for (o=1;o<RSZFile[lvl].RSZHeader.instanceCount;o++)
            if (startof(RSZFile[lvl].Data.RawData.RSZ[o]) == startof(this)) 
                { idx = o; break; }
    
    if (exists(parentof(this).ObjectIndex) ) {
        idx = parentof(this).ObjectIndex;  
    } else if (exists(parentof(this).RSZIdx) )
        idx = parentof(this).RSZIdx;
    
    if (!IsInitialized() || (finished && idx && GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF) ) { //|| GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF
        //Printf("Not initialized at %u", FTell());
        if (!noRetry) {
            ParseJson(JsonPath);  Printf("\nParsing JSON %s\n", JsonPath);
            if (!IsInitialized() || (finished && idx && GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF) )
                noRetry = TRUE;
        }
    }
    
    local string name <hidden=true> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.HashName;
    local wstring title <hidden=true>; 
    local wstring secondTitle <hidden=true>;
    local uint hash <hidden=true, format=hex> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash;
    local ubyte isUserData <hidden=true>;

    if (exists(RSZFile[lvl].RSZUserDataInfos))
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].typeId.Hash == hash) 
                { isUserData = TRUE; break; }

    if (name == "Unknown Class!"){
        Printf("Hash %X not found in JSON!\n", hash);
        byte skip <hidden=true>;
    } else if (idx && GetFieldCount(hash) == 0xFFFFFFFF) { 
        Printf("Class %u %s not detected in JSON!\n", hash, name);
        byte skip <hidden=true>;
    } else if (isUserData) {
        byte skipFileData <hidden=true>;
        local short userDataIdx <hidden=true> = -1;
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == RSZ.idx) { 
                userDataIdx = j;
                if (RSZVersion != "RE2" && RSZVersion != "DMC5") {
                    local wstring userDataPath <hidden=true> = RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String; 
                    local wstring fullPath <hidden=true>;
                    ReadRSZPath(userDataPath);
                    if (title == "")
                        title = userDataPath;
                }
                break; 
            }
    } else if (idx && !FEof()) {
        local int z <hidden=true>, FieldType <hidden=true>, FieldSize <hidden=true>, IsList <hidden=true>;
        for (z = 0; z < GetFieldCount(hash); z++) {
            FieldType = (TypeIDs)GetFieldType(hash, z);
            FieldSize = GetFieldSize(hash, z);
            IsList = GetFieldArrayState(hash, z);
            if (IsList)
                FSeek(getAlignedOffset(FTell(), 4));
            else
                FSeek(getAlignedOffset(FTell(), GetFieldAlignment(hash, z)));   
            
            //Detect and set colors:
            if (FieldType == Color_tid) {
                temp = ((int)ReadUByte(FTell()+2)<<16 | (int)ReadUByte(FTell()+1)<<8 | (int)ReadUByte(FTell()));
                SetForeColor(temp); 
                SetBackColor(temp);
            } else if ((FieldSize == 16 && GetFieldAlignment(hash,z) == 16 && detectedColorVector(FTell())) && (findS(this.name, "olor") != -1 
            || findS(GetFieldName(hash,z), "olor") != -1 || (FieldType == Data_tid && findS(this.name, "render") != -1)) )  {
                temp = ( (int)readColorFloat(FTell()+8)<<16 | (int)readColorFloat(FTell()+4)<<8 | (int)readColorFloat(FTell()));
                SetForeColor(temp); 
                SetBackColor(temp);
            } else (!broken ) ? SetForeColor(cGreen) : SetForeColor(cYellow);
            
            if (FTell() + 4 <= FileSize() && ReadUInt(FTell()) != 0 && FieldType == Object_tid || FieldType == UserData_tid || FieldType == ukn_type 
            || (FieldType == Data_tid && FieldSize == 4 && FTell() + 4 + (IsList * 4) <= FileSize() && detectedObject(FTell() + (IsList * 4)))) {
                struct RSZVariable var(hash, z);
            } else {
                struct RSZVariable var(hash, z) <open=suppress>;
            }
            SetForeColor(cNone);
            SetBackColor(cNone);
        }
    } 
    if (FEof())
        i = RSZHeader.instanceCount; 
  
    if (PrintClasses && idx) {
        local int foundHash = false, zz;
        for (zz=0; zz<hashesLen; zz++)
            if (uniqueHashes[zz] == hash)
                foundHash = true;
        if (foundHash == false) {
            PrintRSZClass(GetRSZClassName(hash));
            uniqueHashes[hashesLen] = hash;
            hashesLen++;
        }
    }
    
    if (title == "") {
        if (secondTitle != "") {
            title = secondTitle;
        } else if (exists(this.var[0])) {
            if (exists(this.var[0].RSZ)) {
                title = ReadRSZInstanceName(this.var[0].RSZ);
            } else {
                title = ReadRSZVariable(this.var[0]);
            }
        }
    }
    if (FTell() - startof(this)  == 0) { 
        ubyte skipFileData <hidden=true>;
    }
    if (FTell()==startof(this))
        Printf(name + "\n");
} RSZInstance <name=ReadRSZInstanceName, read=ReadRSZInstance, write=WriteRSZInstance>;

    wstring ReadRSZInstanceName(RSZInstance &r) { 
        local ushort lvl <hidden=true>;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else lvl = getLevel(startof(r));
        local string s;
        
        if (exists(r.skip) || exists(parentof(r).ObjectIndex) && exists(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex].skip))
            s = "*";

        /*if (exists(parentof(r).ObjectIndex) && parentof(r).ObjectIndex >= 0 && parentof(r).ObjectIndex >= 0 && parentof(r).ObjectIndex <= (int)(sizeof(RSZFile[lvl].ObjectTable) / 4)) {
            lvl = parentof(r).lvl;
            SPrintf(s, "%s[%u] ", RSZFile[lvl].InstanceInfos.instanceInfo[parentof(r).ObjectIndex].typeId.HashName, parentof(r).ObjectIndex);
        } else*/ 
        if (exists(r.idx)) {
            if (exists(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx]))
                s += RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.HashName;
            else if (exists(r.name))
                s += r.name;
            if (!exists(parentof(r).rawData))
                SPrintf(s, "%s[%u]", s, r.idx);
        } else if (exists(RSZFile[lvl].RSZHeader)) {
            for (o=1;o<RSZFile[lvl].RSZHeader.instanceCount;o++) {
                if (exists(RSZFile[lvl].Data.RawData.RSZ[o]) && !exists(RSZFile[lvl].Data.RawData.RSZ[o].skipFileData) 
                && !exists(RSZFile[lvl].Data.RawData.RSZ[o].skip) && startof(RSZFile[lvl].Data.RawData.RSZ[o]) == startof(r)) { 
                    SPrintf(s, "%s[%u]", ReadRSZInstanceName(RSZFile[lvl].Data.RawData.RSZ[o]), o);
                    break;
                }
            }
        }
        return s;
    }

    int SizeRSZInstance(RSZInstance &r) { 
        if ((exists(Alignment.varStart) && exists(RSZFile[lvl].Data.RawData.RSZ[ReadUInt(startof(Alignment.varStart))]))) //detectedObject(startof(Alignment.varStart))
            return sizeof(RSZFile[lvl].Data.RawData.RSZ[ReadUInt(startof(Alignment.varStart))]); 
        return 4;
    }

    wstring ReadRSZInstance(RSZInstance &r) {
        local ushort lvl;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else lvl = getLevel(startof(r));
        if (exists(r.skip)) {
            return ReadHash(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.Hash);
        } else if (exists(r.skipFileData)) {
            for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
                if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == r.idx)
                    return RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String;
        } else if (exists(r.title)) {
            return r.title;
        } else if (exists(parentof(r).ObjectIndex) ) {
            return ReadRSZInstance(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex]);
        } else {
            for (o=1;o<RSZFile[lvl].RSZHeader.instanceCount;o++) 
                if (startof(RSZFile[lvl].Data.RawData.RSZ[o]) == startof(r) && !exists(RSZFile[lvl].Data.RawData.RSZ[o].skipFileData))
                    return RSZFile[lvl].Data.RawData.RSZ[o].title;
        } return "";
    }

    void WriteRSZInstance(RSZInstance &r, wstring s) { 
        if (exists(r.fullPath) && s == " ")
            FileOpener(r.title);
        else {
            local int w;
            local string oldVar = ReadRSZInstance(r);
            while(exists(r.var[w])) {
                if (ReadRSZVariable(r.var[w]) == oldVar) {
                    WriteRSZVariable(r.var[w], s);
                    r.title = ReadRSZVariable(r.var[w]);
                    break;   
                }
                w++;
            }
        }
    }

//================= 
//Other typedefs:

typedef struct(int64 atAddress, int64 addOffset, byte isAbsolute) {
    if (isAbsolute < 1) {
        if (atAddress > -1)
            FSeek(atAddress);
        if (isAbsolute == 0) {
            uint64 strOffset;
            FSeek(strOffset + addOffset);
        } else { //for BHVTNodes
            uint strOffset;
            FSeek((strOffset * 2) + addOffset);
        }
    } else
        FSeek(atAddress + addOffset);
    wstring String <open=suppress>;
    if (find(String, "/") != -1 && FileNameGetExtension(String) != ".json") {
        local wstring fullPath <open=suppress, hidden=true>;
        ReadRSZPath(String);
    }
    if (exists(strOffset)) {
        if (atAddress == -1 || startof(this) == atAddress) {
            FSeek(startof(strOffset)+4+((isAbsolute != -1)*4));
        } else 
            FSeek(startof(this)+1);
    }
} StringRead <fgcolor=cNone, read=ReadStringRead, write=WriteStringRead>;

    wstring ReadStringRead(StringRead &st) { return st.String; }
    
    void WriteStringRead(StringRead &st, string s) { 
        if (s == " " && exists(st.fullPath) && st.fullPath != "")
            FileOpener(st.fullPath);
        else {
            char buffer[sizeof(st.String)];
            WriteBytes(buffer, startof(st.String), sizeof(st.String)); //write 0s
            st.String = s; 
        }
    }
    
    string PrefabName(StringRead &p) {
        if (exists(p.OpenFile))
            return "Prefab (Exists)";
        return "Prefab";
    }

typedef struct {
	uint32 Hash;
	local string HashName = ReadHashName(Hash);
} HASH <read=ReadHASH>;

    string ReadHASH (HASH &h) {
	    return ReadHash(h.Hash);
    }
    
    string ReadHash(uint32 &input) {
	    string s;
	    SPrintf(s, "%X", input);
	    return s;
    }
    
    string ReadHashName(uint32 &input) {
        if (!IsInitialized())
            ParseJson(JsonPath);
        return GetRSZClassName(input);
    }

    string ReadHASHWithName(HASH &h) {
        return ReadHash(h.Hash) + " -- " +  GetRSZClassName(h.Hash);
    }

typedef struct {
    wstring str;
} WSTRING <optimize=false, read=ReadWSTRING, write=WriteWSTRING>;
    wstring ReadWSTRING(WSTRING &input) { return input.str; }
    void WriteWSTRING(WSTRING &input, wstring s) {
        for (k = 0; k < sizeof(input.str)/2; k++)
            input.str[k] = 0;
        input.str = s;
    }

typedef struct {
    FSkip(16);
} SUBPROP4 <optimize=false>;

typedef struct {
    uint32 nameHash, type;
    switch (type) {
        case 6: uint32 value; break;
        case 7: int32 value; break;
        case 7: float value; break;
        case 20: uint64 hashOffs; break;
        default:
            local uint64 test <hidden=true> = ReadUInt64(FTell());
            if (test > 0 && test <= FileSize()-16 && test > FTell()) {
                uint64 hashOffs; 
            } else if (detectedFloat(FTell())) {
                float value;
            } else { uint value; }
            if (exists(value))
                local float hiddenValue <hidden=true> = value;
            break;
    }
    if (exists(hashOffs)) {
        FSeek(start + hashOffs);
        rGUID value;
    }
    FSeek(startof(nameHash) + 16);
} HASHPROP <read=ReadHASHPROP, optimize=false>;

    string ReadHASHPROP (HASHPROP &input) {
        string s = "";
        if (exists(input.hiddenValue))
            SPrintf(s, "%g", input.hiddenValue);
        return s;
    }

typedef struct {
    ushort propCount, B, C; //skipToNextLine();
    skipToNextLine();
    uint64 offs1, offs2;
    if (propCount > 0) {
        if (offs1 <= FileSize()) {
            FSeek(start + offs1);
            string name; //SUBPROP3 SubProp3;
        }
        if (offs2 <= FileSize()) {
            FSeek(start + offs2);
            if (ReadUShort(FTell()+2) != 0)
                HASHPROP Value;
            else
                SUBPROP4 SubProp4;
        }
    }
    FSeek(startof(this)+32);
} SUBPROP2 <optimize=false>;

typedef struct {
    uint64 nameOffset;
    uint64 dataOffset;
    local int pos <hidden=true> = FTell();
    FSeek(start + nameOffset);
    
    if (nameOffset > 0 && nameOffset <= FileSize())
        string name <open=suppress>;
    FSeek(start + dataOffset);
    
    if (dataOffset > 0 && dataOffset + start <= FileSize())
        HASHPROP Hashed_Value;

    if (exists(Hashed_Value.hiddenValue))
        local float hiddenValue <hidden=true> = Hashed_Value.hiddenValue;
    FSeek(pos);
    FSkip(16);
    
} NODE <name=ReadNODENAME, read=ReadNODE, optimize=false>;

    string ReadNODENAME (NODE &input) {
        if (exists(input.name))
            return input.name;
        return "";
    }

    string ReadNODE (NODE &input) {
        string s = "";
        if (exists(input.hiddenValue))
            SPrintf(s, "%g", input.hiddenValue);
        return s;
    }
typedef struct {
    uint32 ukn, ukn;
    uint16 uknShort, uknShort2;
    uint32 ukn2;
    if (uknShort)
        uint ukn3[4];
    
} OFFSET2_DATA;

typedef struct {
    uint64 nodesOffset;
    uint64 offset2;
    ushort propCount, B, C; //skipToNextLine();
    if (propCount > 0) {
        if (nodesOffset > 0) {
            FSeek(start + nodesOffset);
            if (ReadUInt(FTell()) <= FileSize())
                struct NODE Node[propCount];
            else 
                string name <open=suppress>;
        }
        if (offset2 > 0) {
            FSeek(start + offset2);
            OFFSET2_DATA Offset2_Data;
        }
    }
} PROP <read=ReadProp, optimize=false>;  
    
    string ReadProp (PROP &input) {
        if (exists(input.name))
            return input.name;
        return "";
    }


typedef struct {
    rGUID Guid;
    uint64 nameOffset;
    FSeek(start + nameOffset);
    wstring name <open=suppress>;
    FSeek(startof(nameOffset) + 8);
    uint64 floatOffset, uknOffset;
    uint type : 24;
    uint numBits : 8;
    uint nameHash;

    if (floatOffset > 0) { //!didSeek && 
        FSeek(start + floatOffset);
        
        if ((numBits / 32) <= 1) {
            float Value_As_Float;
            FSeek(startof(Value_As_Float));
            int Value_As_Int;
        } else {
            float Value_As_Float[(numBits / 32)];
            FSeek(startof(Value_As_Float[0]));
            int Value_As_Int[(numBits / 32)];
        }
    }
    if (uknOffset > 0) {
        FSeek(start + uknOffset);
        PROP VarData;           
    }
    FSeek(startof(nameHash) + 4);
} UVARIABLE <optimize=false, name=ReadUVariableName, read=ReadUVariable, write=WriteUVariable>;

    wstring ReadUVariableName(UVARIABLE &input) { if (exists(input.VarData)) return (input.name + "*"); return input.name; }

    void WriteUVariable(UVARIABLE &input, string s) { WriteUInt(startof(input.Value_As_Int), Atoi(s)); }

    wstring ReadUVariable(UVARIABLE &input) {
        string s = "";
        if (exists(input.Value_As_Float)) {
            if (detectedFloat(startof(input.Value_As_Float)))
                SPrintf(s, "%g", input.Value_As_Float[0]);
            else
                SPrintf(s, "%u", input.Value_As_Int[0]); 
        }
        return (s);
    }

typedef struct {
    
    if (exists(parentof(this).mNamePool))
        local int start <hidden=true> = startof(parentof(this));
    else 
        local int start = startof(this);
    
    struct {
        uint version;
        uint magic;
        uint64 stringsOffset;
        uint64 dataOffset;
        uint64 embedsInfoOffset;
        uint64 hashInfoOffset;
        uint64 ukn;
        uint UVARhash;
        ushort variableCount;
        ushort embedCount;
        //if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
        //    FSeek(getAlignedOffset(FTell(),16));
        //    uint64 uknOffs, uknOffs, uknOffs, uknOffs;
        //}
    } Header;
    if (Header.magic == 1918989941) {
        if (Header.variableCount && Header.dataOffset+start > startof(this)) { 
            FSeek(start + Header.dataOffset);
            struct {
                for (j=0;j<Header.variableCount;j++) {
                    struct UVARIABLE Var;
                }
            } Data;
        }
        if (Header.stringsOffset) { 
            FSeek(start + Header.stringsOffset);
            struct {
                if (Header.variableCount)
                    WSTRING str[Header.variableCount] <open=suppress>;
                else while (detectedString(FTell()))
                    WSTRING str <open=suppress>;
            } Strings;
        }
        if (Header.embedCount && Header.embedsInfoOffset) {
            FSeek(start + Header.embedsInfoOffset);
            uint64 embedOffsets[Header.embedCount];
            for (i=0; i<Header.embedCount; i++) {
                FSeek(start + embedOffsets[i]);
                struct UVAR UVAR_File;
                start = startof(parentof(this));
            }
        }
        
        if (Header.variableCount && Header.hashInfoOffset+start > startof(this)) {
            FSeek(start + Header.hashInfoOffset);
            struct {
                uint64 HashDataOffsets[4];
                FSeek(start + HashDataOffsets[0]);
                struct rGUID GUIDs[Header.variableCount] <optimize=false>;
                FSeek(start + HashDataOffsets[1]);
                uint dataHashMap[Header.variableCount];
                FSeek(start + HashDataOffsets[2]);
                uint nameHashes[Header.variableCount];
                FSeek(start + HashDataOffsets[3]);
                uint nameHashMap[Header.variableCount];
            } HashData;
        }
    }
} UVAR <read=ReadUVAR>;

    wstring ReadUVAR (UVAR &input) {
        if (exists(input.Data.Var[0]))
            return input.Data.Var[0].name;
        return "";
    }

struct OBJECTID(int lv) {
    int id;
    local int level <hidden=true> = lv;
};

typedef OBJECTID ObjectId <read=ReadObjectIdTitle, write=WriteObjectId>;

    wstring ReadObjectIdName(ObjectId &o) {
        local string s;
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) && exists(RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]])) {
            SPrintf(s, "%i -- %s", o.id, RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]].typeId.HashName);
            if (s != "")
                SPrintf(s, "%s[%i]", s, RSZFile[o.level].ObjectTable[o.id]);
        }
        return s;
    }

    wstring ReadObjectId(ObjectId &o) {
        local string s;
        SPrintf(s, "%i", o.id);
        return s;
    }

    void WriteObjectId(ObjectId &o, string s) {
        o.id = Atoi(s);
    } 

    wstring ReadObjectIdTitle(ObjectId &o) {
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) 
        && exists(RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]])) {
            local string s = ReadObjectId(o) + " -- " + RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]].title;
            return s;
        }
        return "";
    }

    wstring ReadInstanceID(ObjectId &in) { 
        if (exists (RSZFile[in.level].InstanceInfos.instanceInfo[in.id].typeId.HashName)) {
            local string s; 
            SPrintf(s, "%i -- %s", in.id, RSZFile[in.level].InstanceInfos.instanceInfo[in.id].typeId.HashName);
            return s; 
        } 
        return ""; 
    }

struct fakeGameObject {
    FSeek(getAlignedOffset(FTell(), 4));
    uint size0;
    if (size0 && FTell()+size0*2 <= FileSize())
        wchar_t name[size0];
    FSeek(getAlignedOffset(FTell(), 4));
    uint size1;
    if (size1 && FTell()+size1*2 <= FileSize())
        wchar_t tag[size1];
    FSeek(getAlignedOffset(FTell()+2, 4));
    uint timeScale;
};


if (ReadUInt()==4343376 || ReadUInt()==5395285 || ReadUInt()==1280262994 || ReadUInt()==5129043 || ReadUInt(4)==846423661 || ReadUInt()==1414940738 )
    struct {
        local uint magic <hidden=true> = ReadUInt(FTell());
        if (ReadUShort(2) == 0)
            magic = ReadUInt(FTell()+4);
	    if (magic == 1414940738) // BHVT
            uint magic;
        isAIFile = (findS(GetFileName(), "bhvt") != -1); //Header.magic == 1414940738 && (ReadUInt(4) > 0) && 
        
        if (magic == 4343376) {//50 46 42 00 PFB 
            uint signature;
	        int infoCount;
            int resourceCount;
            
            if (RSZVersion != "DMC5" && RSZVersion != "RE2") {
                int uknPFBInfoCount;
                int userdataCount;
                int reserved;
                uint64 uknPFBInfoTbl;
	            uint64 resourceInfoTbl;
	            uint64 userdataInfoTbl;
            } else {
                int uknPFBInfoCount;
	            uint64 uknPFBInfoTbl;
	            uint64 resourceInfoTbl;
            }



	        uint64 dataOffset;
        }
    
        if (magic == 5395285) { //USR 
            uint signature;
            int resourceCount;
	        int infoCount;
            int userdataCount;
	        uint64 resourceInfoTbl;
	        uint64 userdataInfoTbl;
	        uint64 dataOffset;
        }
        
        if (magic == 1280262994) {//52 43 4F 4C RCOL
            uint signature;
            int numGroups;
            int numShapes;
            int numUserData;
            int numRequestSets;
            uint maxRequestSetId;
            if (RSZVersion == "RE8") {
                int numIgnoreTags;
                int numAutoGenerateJoints;
            }
            uint userDataSize;
            uint status;
            if (RSZVersion == "RE3") {
                uint64 uknA; 
                uint64 uknB; 
            }
            uint64 groupsPtrTbl;
            uint64 dataOffset <name="userDataStreamPtr">;
            uint64 requestSetTbl; 
            if (RSZVersion == "RE8") {
                uint64 ignoreTagTbl;
                uint64 autoGenerateJointDescTbl;
            }
        }
        if (magic == 5129043) { // 53 43 4E 00 SCN
            uint signature;
            int infoCount;
            int resourceCount;
            int folderCount;
            if (RSZVersion == "DMC5" && RSZVersion != "RE2") {
                int userdataCount;
                int prefabCount;
            } else {
                int prefabCount;
                int userdataCount;
            }
    
            uint64 folderInfoTbl;
            uint64 resourceInfoTbl;
            uint64 prefabInfoTbl;
            uint64 userdataInfoTbl;
            uint64 dataOffset;
        }
        
        if (ReadUInt(0) == 1414940738 || magic == 846423661) { //BHVT or mfs2
            if (magic == 846423661) { //mfs2
                uint version;
                uint signature;
                FSkip(8);
                uint64 treeData;
                uint64 transitionMapTbl;
                uint64 transitionDataTbl;
                uint64 treeInfoPtr;
                uint transitionMapCount;
                uint transitionDataCount;
                uint startTransitionDataIndex;
    
                FSeek(treeInfoPtr);
                uint treeDataSize;
    
                FSeek(transitionMapTbl);
                if (transitionMapCount) 
                    struct TRANSITIONMAP {
                        uint transitionId;
                        int dataIndex;
                        if (exists(Header.TransitionData[dataIndex])) {
                            FSeek(startof(Header.TransitionData[dataIndex]));
                            struct TRANSITIONDATA TransitionData <open=true>;
                            checkUseSpacers();
                            FSeek(startof(dataIndex)+4);
                        }
                    } TransitionMap[transitionMapCount] <optimize=true>;
    
                FSeek(transitionDataTbl);
                if (transitionDataCount) 
                    struct TRANSITIONDATA {
                        int id;
                        uint32 endType : 4;
                        uint32 interpolationMode : 4;
                        uint32 interpolationCurve : 4;
                        uint32 prevMoveToEnd : 1;
                        uint32 startType : 4;
                        uint32 elapsedTimeZero : 1;
                        uint32 contOnLayer : 1;
                        uint32 contOnLayerInterpCurve : 4;
                        uint32 emptyBits : 9;
                        float exitFrame;
                        float startFrame;
                        float interpolationFrame;
                        if (RSZVersion != "RE2" && RSZVersion != "DMC5" ) {
                            float contOnLayerSpeed;
                            float contOnLayerTimeout;
                            uint16 contOnLayerNo;
                            uint16 contOnLayerJointMaskId;
                        }
                        FSkip(4);
                    } TransitionData[transitionDataCount] <optimize=true>;
                FSeek(startTransitionDataIndex+4);
            }
        }
        
        if (exists(treeData) || magic == 1414940738) {
            if (exists(treeData))
                FSeek(treeData);
            else FSeek(startof(magic));
            struct {
                uint BHVT;
                FSkip(4);
                unsigned __int64 nodeOffset;
                unsigned __int64 actionOffset;
                unsigned __int64 selectorOffset;
                unsigned __int64 selectorCallerOffset;
                unsigned __int64 conditionsOffset;
                unsigned __int64 transitionEventOffset;
                unsigned __int64 expressionTreeConditionsOffset;
                unsigned __int64 staticActionOffset;
                unsigned __int64 staticSelectorCallerOffset;
                unsigned __int64 staticConditionsOffset;
                unsigned __int64 staticTransitionEventOffset;
                unsigned __int64 staticExpressionTreeConditionsOffset;
                unsigned __int64 stringOffset;
                unsigned __int64 resourcePathsOffset;
                unsigned __int64 userdataPathsOffset;
                unsigned __int64 variableOffset;
                unsigned __int64 baseVariableOffset;
                unsigned __int64 referencePrefabGameObjectsOffset;
        
                FSeek(stringOffset+startof(this));
                struct BHVTStringPool{
                    if (exists(mPathNamePool) && !detectedString(FTell()+4))
                        uint numPaths;
                    uint poolSize;
                    while (FTell() < startof(this)+(poolSize*2)) {
                        struct StringRead String(FTell(), 0, true) <read=ReadBHVTStringName>;
                        if (sizeof(String) == 0) 
                            break; 
                    }
                } mNamePool;
                FSeek(resourcePathsOffset+startof(this));
                struct BHVTStringPool mPathNamePool;
                if (exists(userdataPathsOffset) && ReadUInt(userdataPathsOffset+startof(this)) != 2) {
                    FSeek(userdataPathsOffset+startof(this));
                    struct BHVTStringPool mUserDataPathNamePool;
                }
                if (ReadBHVTHeader) {
                    //FSeek(variableOffset+startof(this)); 
                    FSeek(userdataPathsOffset+startof(this)-4); 
                    while (FTell()+8<FileSize() && ReadUInt(FTell()+4) != 1918989941) FSkip(1);
                    while(FTell() + 8 < FileSize()){
                        struct UVAR UVariable;
                        while (FTell() + 8 < FileSize() && ReadUInt(FTell()+4) != 1918989941) 
                            FSkip(1);
                    }
                    FSeek(baseVariableOffset+startof(this));
                    
                    unsigned int mReferenceTreeCount;
                    if (FTell()+16 <= FileSize())
                        if (ReadUInt(FTell()+16) == 1918989941) {
                            uint64 Uvar2Offset;
                            FSeek(Uvar2Offset+startof(this));
                            struct UVAR Uvar2;
                        } else {
                            uint64 thisOffset;
                        }
                }
                FSeek(startof(referencePrefabGameObjectsOffset) + 8);
            } BHVT;
        }
    } Header;


    if (exists(Header.BHVT) && ReadBHVTHeader) {
        FSeek(Header.BHVT.nodeOffset+startof(Header.BHVT));
        struct {
            uint32 mNodeCount;
            local uint32 mNodeCounter <hidden=true>;
            struct {

                /*enum BHVTlvl {
                    id_All = -1,
                    id_Actions = 0,
                    id_Selectors = 1,
                    id_SelectorCallers = 2,
                    id_Conditions = 3,
                    id_transitionEvents = 4,
                    id_expressionTreeConditions = 5,
                    id_staticActions = 6,
                    id_staticSelectorCallers = 7,
                    id_staticConditions = 8,
                    id_staticTransitionEvents = 9,
                    id_staticExpressionTreeConditions = 10
                };*/

                typedef struct {
                    if (exists(mNodeCounter)) 
                        local uint32 index = mNodeCounter;
                    struct BHVTHash ID(id_Actions); 
                    struct BHVTHash exID(id_Actions);
                    StringRead mNameOffset(-1, 4+startof(Header.BHVT)+Header.BHVT.stringOffset, -1);
                    struct BHVTHash mParent(id_All);
                    struct BHVTHash mParentEx(id_All);
                    int childCount;
                    if (childCount && childCount < FileSize() && FTell() + childCount * 4 < RSZOffset) {
                        if (childCount > 1) struct { struct BHVTHash children(id_All)[childCount]; } children; else struct BHVTHash children(id_All);
                        if (childCount > 1) struct { struct BHVTHash childrenEx(id_All)[childCount]; } childrenEx; else struct BHVTHash childrenEx(id_All);
                        if (childCount > 1) struct { struct BHVTHash conditions(id_Conditions)[childCount]; } conditions; else struct BHVTHash conditions(id_Conditions);
                    }
                    int selectorId;
                    if (exists(RSZ[6].Data.RawData.RSZ[selectorId])) {
                        FSeek(startof(RSZ[6].Data.RawData.RSZ[selectorId]));
                        struct RSZInstance Selector;
                        FSeek(startof(selectorId)+4);
                    }
                    int selectorCallersCount;
                    if (selectorCallersCount && selectorCallersCount < FileSize() && FTell() + selectorCallersCount * 4 < RSZOffset) {
                        if (selectorCallersCount > 1) struct { struct BHVTHash selectorCallers(id_SelectorCallers)[selectorCallersCount]; } selectorCallers; else struct BHVTHash selectorCallers(id_SelectorCallers);
                    }
                    int mSelectorCallConditionID <format=hex>;
                    int mActionsCount;
                    if (mActionsCount && mActionsCount < FileSize() && FTell() + mActionsCount * 4 < RSZOffset) {
                        if (mActionsCount > 1) struct { struct BHVTHash mActions(id_Actions)[mActionsCount]; } mActions; else struct BHVTHash mActions(id_Actions);
                        if (mActionsCount > 1) struct { struct BHVTHash mActionsEx(id_Actions)[mActionsCount]; } mActionsEx; else struct BHVTHash mActionsEx(id_Actions);
                    }
                    
                    int mPriority;
                    if (!isAIFile) {
                        int mNodeAttribute;
                        if (mNodeAttribute & 0x20) {
                            int mNameHash <format=hex>;
                            int mFullnameHash <format=hex>;
                            int mTagsCount;
                            if (mTagsCount && mTagsCount < FileSize() && FTell() + mTagsCount * 4 < RSZOffset)
                                if (mTagsCount > 1) struct { int mTags[mTagsCount] <optimize=false, format=hex>; } mTags; else int mTags <format=hex>;
                        }
                        ubyte mIsBranch;
                        ubyte mIsEnd;
                    }
                    
                    int mStatesCount;
                    if (mStatesCount && mStatesCount < FileSize() && FTell() + mStatesCount * 4 < RSZOffset) {
                        if (mStatesCount > 1) struct { struct BHVTHash mStates(id_All)[mStatesCount]; } mStates; else struct BHVTHash mStates(id_All);
                        if (mStatesCount > 1) struct { struct BHVTHash mTransitions(id_All)[mStatesCount]; } mTransitions; else struct BHVTHash mTransitions(id_All);
                        if (mStatesCount > 1) struct { struct BHVTHash mTransitionsID(id_All)[mStatesCount]; } mTransitionsID; else struct BHVTHash mTransitionsID(id_All);
                        if (mStatesCount > 1) struct { struct BHVTHash mStatesEx(id_TransitionId)[mStatesCount]; } mStatesEx; else struct BHVTHash mStatesEx(id_TransitionId);
                        if (mStatesCount > 1) struct { struct BHVTHash mTransitionAttributes(id_All)[mStatesCount]; } mTransitionAttributes; else struct BHVTHash mTransitionAttributes(id_All);
                        if (mStatesCount > 1) struct { struct BHVTHash mTransitionUnknown(id_All)[mStatesCount]; } mTransitionUnknown; else struct BHVTHash mTransitionUnknown(id_All);
                    }

                    int mTransitionCount;
                    if (mTransitionCount && mTransitionCount < FileSize() && FTell() + mTransitionCount * 4 < RSZOffset) {
                        if (mTransitionCount > 1) struct { struct BHVTHash mStartTransitionEvent(id_All)[mTransitionCount]; } mStartTransitionEvent; else struct BHVTHash mStartTransitionEvent(id_All);
                        if (mTransitionCount > 1) struct { struct BHVTHash mStartState(id_All)[mTransitionCount]; } mStartState; else struct BHVTHash mStartState(id_All);
                        if (mTransitionCount > 1) struct { struct BHVTHash mStartStateTransition(id_All)[mTransitionCount]; } mStartStateTransition; else struct BHVTHash mStartStateTransition(id_All);
                        if (RSZVersion != "RE2" && RSZVersion != "DMC5") 
                            if (mTransitionCount > 1) struct { struct BHVTHash mStartStateEx(id_All)[mTransitionCount]; } mStartStateEx; else struct BHVTHash mStartStateEx(id_All);
                    }
                    if (RSZVersion == "DMC5") {
                        int unknownCount;
                        FSkip(4*5*unknownCount);
                    }
                    if (exists(mNodeAttribute) && (mNodeAttribute & 4) == 0) { //{
                        int mAllStateCount;
                        if (mAllStateCount && mAllStateCount < FileSize() && FTell() + mAllStateCount * 4 < RSZOffset) {
                            if (mAllStateCount > 1) struct { struct BHVTHash mAllState(id_All)[mAllStateCount]; } mAllState; else struct BHVTHash mAllState(id_All);
                            if (mAllStateCount > 1) struct { struct BHVTHash mAllTransition(id_TransitionId)[mAllStateCount]; } mAllTransition; else struct BHVTHash mAllTransition(id_TransitionId);
                            if (mAllStateCount > 1) struct { struct BHVTHash mAllTransitionID(id_TransitionId)[mAllStateCount]; } mAllTransitionID; else struct BHVTHash mAllTransitionID(id_TransitionId);
                            if (RSZVersion != "DMC5") {
                                if (mAllStateCount > 1) struct { struct BHVTHash mAllStateEx(id_All)[mAllStateCount]; } mAllStateEx; else struct BHVTHash mAllStateEx(id_All);
                                if (mAllStateCount > 1) struct { struct BHVTHash mAllTransitionAttributes(id_All)[mAllStateCount]; } mAllTransitionAttributes; else struct BHVTHash mAllTransitionAttributes(id_All);
                                
                            } else uint ukn, ukn;
                        }
                    }
                    
                    if (RSZVersion == "RE8") {
                        int mReferenceTreePathOffset;
                    } else if (RSZVersion != "DMC5") {
                        int unknown2Count;
                    }
                    
                    if (!finished && RSZVersion != "RE8") {
                        if (index == 3)  
                            123;
                        while(ReadUInt()==0)FSkip(4);
                        if (mNodeCounter < mNodeCount-2) { //automatic correction
                            if ( ReadUInt(FTell()+8) == 0 || (startof(Header.BHVT.mNamePool) + 4 + (ReadUInt(FTell()+8)*2) > startof(Header.BHVT.mNamePool)+sizeof(Header.BHVT.mNamePool) )
                            || ReadUShort(startof(Header.BHVT.mNamePool) + 2 + (ReadUInt(FTell()+8)*2)) != 0) {
                                ubyte blank <bgcolor=cRed, hidden=true>;
                                FSkip(-33);
                                while(FTell()+12<FileSize() && (!detectedHash(FTell()) || ReadUInt(FTell()+8) == 0 || (!detectedStringSm(startof(Header.BHVT.mNamePool) + 4 + (ReadUInt(FTell()+8)*2)))))  {
                                    if (index == 3) 
                                        Printf("%i\n",FTell());
                                    FSkip(2);
                                }
                            }
                        }
                        mNodeCounter++;
                    }
                    
                } BHVTNode <read=ReadBHVTNode, optimize=false>;
                
                for (n=0; n<mNodeCount; n++) {
                    struct BHVTNode Node;
                    if (FTell()>RSZOffset)
                        break;
                    //if ( ReadUInt64(FTell()+32) + ReadUInt64(FTell()+40) + ReadUInt64(FTell()+48) == 0)
                    //    break;
                }
            } RawNodes <open=suppress, hidden=false>;
        } BehaviorTree;
    }
    
        wstring ReadBHVTNode(BHVTNode &b) { 
            if (exists(b.mNameOffset.String)) {
                return b.mNameOffset.String; 
            } else {
                local ushort z;
                for (z=0; z<BehaviorTree.mNodeCount; z++) {
                    if (startof(b) == startof(BehaviorTree.RawNodes.Node[z]))
                        return BehaviorTree.RawNodes.Node[z].mNameOffset.String;
                }
            }
        }
        
        wstring ReadBHVTStringName(StringRead &str) { 
            SPrintf(s, "%i -- ", ((startof(str) - startof(parentof(str))) - 4) / 2); 
            return s + ReadStringRead(str); 
        } 

        int ReadBHVTStringID(StringRead &str) { return (startof(str) - startof(parentof(str)) - 4) / 2; } 


typedef struct {
    HASH hash <read=ReadHASHWithName>;
    uint32 CRC;
    StringRead pathOffset(-1, 0, 0);
} UserDataInfo <name=ReadUserDataInfoName, read=ReadUserDataInfo>;

    string ReadUserDataInfo (UserDataInfo &u) { return u.pathOffset.String; }
    
    string ReadUserDataInfoName(UserDataInfo &u) { return u.hash.HashName; }

typedef struct {
    if (ReadInt(FTell()+4) != 0)
        StringRead pathStr(FTell(), 0, 1); 
    else
        StringRead pathStr(-1, 0, 0);
} Resource_Info <name=ReadResourceInfoName, read=ReadResourceInfo, write=WriteResourceInfo>;

    string ReadResourceInfo(Resource_Info &r) { return r.pathStr.String; }

    string ReadResourceInfoName(Resource_Info &r) { if (!exists(r.pathStr.OpenFile) && !exists(r.OpenFile)) return "*ResourceInfo"; return "ResourceInfo"; }

    void WriteResourceInfo(Resource_Info &r, string s) { WriteStringRead(r.pathStr, s);  }

if (ReadUInt(0) != 1280262994) { //no RCOL

    if (exists(Header.infoCount) && Header.infoCount) {
        if (Header.magic == 4343376)
	        struct GameObjectInfoPFB {
		        ObjectId id(0);
		        ObjectId parentId(0);
		        int componentCount;
	        } GameObjectInfos[Header.infoCount] <optimize=true, name=ReadGRefInfoPFBName, read=ReadGRefInfoPFB>;
        else 
            struct GameObjectInfo {
                rGUID Guid;
                ObjectId id(0);
                ObjectId parentId(0);
                ushort componentCount;
                short ukn;
                int prefabId;
            } GameObjectInfos [Header.infoCount] <optimize=true, name=ReadGRefInfoName, read=ReadGRefInfo>; 
    }

    if (exists(Header.folderCount) && Header.folderCount) {
        FSeek(Header.folderInfoTbl);
        struct {
            for (i=0; i<Header.folderCount; i++)
                struct FOLDERINFO {
                    local uint idx <hidden=true> = i;
                    ObjectId id(0);
                    ObjectId parentId(0);
                } FolderInfo <name=ReadFOLDERINFOName, read=ReadFOLDERINFO>;
        } FolderInfos;
    }
    
    if (exists(Header.userdataCount) && Header.userdataCount > 0 && (!exists(Header.userdataInfoTbl)  || Header.userdataInfoTbl > 0)) {
        FSeek(Header.userdataInfoTbl);
        struct {
	        UserDataInfo userDataInfo[Header.userdataCount] <optimize=false>;
        } userDataInfos;
    }


    if (exists(Header.uknPFBInfoCount) && Header.uknPFBInfoCount > 0) {
        FSeek(Header.uknPFBInfoTbl);
        struct {
	        struct {
                ObjectId InstanceID(0) <read=ReadObjectIdName>;
                ushort shortA;
                ushort shortB;
                int intA;
                ObjectId GameObjectID(0);
            } uknPFBInfo[Header.uknPFBInfoCount] <optimize=false>;
        } uknPFBInfos;
    }
    
    if (exists(Header.resourceCount) && Header.resourceCount) {
	    FSeek(Header.resourceInfoTbl);
	    struct {
            Resource_Info ResourceInfo[Header.resourceCount] <optimize=false>;
	    } ResourceInfos;
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        FSeek(Header.prefabInfoTbl);
        struct {
            for (i=0; i<Header.prefabCount; i++)
                struct PreFab {
                    local uint idx <hidden=true> = i;
                    int id;
                    int parentId;
                    FSeek(id); wstring path;
                    if (parentId) {
                        FSeek(parentId); 
                        wstring path;
                    }
                    FSeek(startof(parentId)+4);
                    
                } PrefabInfo <read=ReadPreFab, write=WritePreFab>;
        } PrefabInfos;
    }
}

    wstring ReadGRefInfo(GameObjectInfo &g) { return ReadObjectIdTitle(g.id); }

    wstring ReadGRefInfoPFB(GameObjectInfoPFB &g) { return ReadObjectIdTitle(g.id); }

    wstring ReadGRefInfoName(GameObjectInfo &g) { return ReadObjectIdName(g.id); }

    wstring ReadGRefInfoPFBName(GameObjectInfoPFB &g) { return ReadObjectIdName(g.id); }

    wstring ReadFOLDERINFO(FOLDERINFO &f) { return ReadObjectIdTitle(f.id); }

    wstring ReadFOLDERINFOName(FOLDERINFO &f) { return ReadObjectIdName(f.id); }

    wstring ReadPreFab(PreFab &p) { return p.path; }

    void WritePreFab(PreFab &p, string s) { p.path = s; }

typedef struct {
        local ushort lvl <hidden=true>;
        if (exists(parentof(this).lvl)) 
            lvl = parentof(this).lvl;
        else lvl = getLevel(FTell());
        uint instanceId; 
        HASH typeId <read=ReadHASHWithName>;   
        if (RSZVersion == "DMC5" || RSZVersion == "RE2") {
            uint uknHash <format=hex>;
            uint uknOffs;
            uint64 pathOffs;
            local uint dataOffs <hidden=false> = pathOffs + startof(RSZHeader);
            FSkip(-1); struct { ubyte a; local wstring String; } path <hidden=true>; //dummy
        } else {
            StringRead path(-1, startof(RSZHeader), 0); 
        }
} RSZUserDataInfo <name=ReadRSZUserDataInfoName, read=ReadRSZUserDataInfo>;

    string ReadRSZUserDataInfoName(RSZUserDataInfo &u) { return RSZFile[u.lvl].InstanceInfos.instanceInfo[u.instanceId].typeId.HashName; }
    
    string ReadRSZUserDataInfo(RSZUserDataInfo &u) { return u.path.String; }

typedef struct(ubyte isFolder)
{
    local int tempN <hidden=true>, tempJ <hidden=true>, prefabCount <hidden=true>, gChildCount <hidden=true>, fChildCount <hidden=true>, id <hidden=true>;
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else lvl = getLevel(FTell());
    local wstring title <hidden=true>;
    isFolder == true ? (id = FolderInfos.FolderInfo[n].id.id) : (id = GameObjectInfos[n].id.id);
    
    if (!isFolder && exists(GameObjectInfos[n].prefabId) && GameObjectInfos[n].prefabId != -1) {
        StringRead Prefab(startof(PrefabInfos.PrefabInfo[GameObjectInfos[n].prefabId].id), 0, 0) <open=suppress, name=PrefabName>; 
        FSkip(-1);
        title = Prefab.String;
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        for (j=0; j<Header.prefabCount; j++)
            if (PrefabInfos.PrefabInfo[j].parentId == id)
                prefabCount++;
        if (prefabCount) {
            struct {
                for (j=0; j<Header.prefabCount; j++)
                    if (PrefabInfos.PrefabInfo[j].parentId == id) {
                        StringRead Prefab(startof(PrefabInfos.PrefabInfo[j]), 0, 0) <open=suppress, name="Prefab">;
                        FSkip(-1);
                    }
                FSeek(startof(this) + 1);
            } Prefabs <name="Child Prefabs">;
            FSkip(-1);
        }
    }

    local uint counter <hidden=true>, componentCount <hidden=true>;
    if (!isFolder)
        componentCount = GameObjectInfos[n].componentCount;
    for (counter=id; counter<id+1+componentCount; counter++) {
        if (exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[counter]])) {
            i = RSZFile[lvl].ObjectTable[counter];
            tempN = n;
            FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[counter]]));
            RSZInstance RSZ(i);
            n = tempN;
        }
    }
    
    if (title == "" && exists(RSZ[0].title))
        title = RSZ[0].title; 
        
    if (exists(Header.folderCount)) {        
        for (j=0; j<Header.folderCount; j++)
            if (FolderInfos.FolderInfo[j].parentId.id == id) {
                if (!fChildCount)
                    FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                fChildCount++;
            }
        
        if (fChildCount) {
            struct {
                for (j=0; j<Header.folderCount; j++) {
                    if (FolderInfos.FolderInfo[j].parentId.id == id) {
                        tempN = n; tempJ = j;
                        FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                        n = j;
                        if (fChildCount == 1)
                            struct GameObject ChildFolder(1) <read=ReadGameObject, open=true>;
                        else
                            struct GameObject ChildFolder(1) <read=ReadGameObject>;
                        n = tempN; j = tempJ;
                    }
                }
                if (startof(this) > FTell())
                    FSeek(startof(this) + sizeof(ChildFolder[0]));
            } Folders <name="Child Folders">;
        }
    }
    
    for (j=0; j<Header.infoCount; j++)
        if (GameObjectInfos[j].parentId.id == id ) {
            if (!gChildCount && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]]))
                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]]));
            gChildCount++;
        }    
    
    if (gChildCount) {
        struct {
            for (j=0; j<Header.infoCount; j++) {
                if (GameObjectInfos[j].parentId.id == id && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]])) {
                    tempN = n; tempJ = j;
                    FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]]));
                    n = j;
                    if (gChildCount == 1)
                        struct GameObject ChildObject(0) <open=true>;
                    else
                        struct GameObject ChildObject(0);
                    n = tempN; j = tempJ;
                }
            }
            if (startof(this) > FTell())
                FSeek(startof(this) + sizeof(ChildObject[0]));
        } GameObjects <name="Child GameObjects">;
    }
    
    checkUseSpacers();
    
    if (startof(this) > FTell())
        FSeek(startof(this) + sizeof(RSZ[0]));
} GameObject <name=ReadGameObjectName, read=ReadGameObject>;;

    wstring ReadGameObjectName(GameObject &g) {         
        return ReadRSZInstanceName(g.RSZ[0]);
    }

    wstring ReadGameObject(GameObject &g) {
        local wstring s;
        if (exists(g.RSZ[0].var[0].data)) {
            s = (wstring)g.RSZ[0].var[0].data;
            if (exists(g.RSZ[0].var[5].data ) && g.RSZ[0].var[5].data != "" && g.RSZ[0].name == "via.Folder")
                s += "  :  " + g.RSZ[0].var[5].data + "";
            else if (exists(g.RSZ[0].var[1].data ) && g.RSZ[0].var[1].data != "" && g.RSZ[0].name == "via.GameObject")
                s += " (" + g.RSZ[0].var[1].data + ")";
        }
        return s;
    }

typedef uint64 InsertKey <read=ReadInsertHashKey, write=InsertHashKey>;
    
    wstring ReadInsertHashKey(InsertKey &k) { return "Input a '*' here to insert an object, or a space to insert a non-object"; }
    
    void InsertHashKey(InsertKey &k, string s) { 
        local int lvl = parentof(parentof(parentof(k))).lvl;
        int64 newValue = Atoi(s);
        local int isObject;
        if (s[0] == 42) {
            isObject = TRUE;
            newValue = Atoi(SubStr(s, 1, sizeof(s)-1));
        }
        //Printf("%i\n", (startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos)));
        local int freeSpace = 16 - ((startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos)) % 16);
        local int sizeToInsert = 8 - freeSpace;
        if (isObject)
            sizeToInsert = 12 - freeSpace;
        local int newPadding = (16 - sizeToInsert) % 16;
        local int diff = sizeToInsert + newPadding;
        //Printf("%iL %i %i %i %i %i\n", newValue, freeSpace, sizeToInsert, newPadding, diff, parentof(k).index);
        RSZFile[lvl].RSZHeader.dataOffset += diff;
        RSZFile[lvl].RSZHeader.userdataOffset += diff;
        if (isObject) {
            RSZFile[lvl].RSZHeader.instanceOffset += 4;
            RSZFile[lvl].RSZHeader.objectCount += 1;
        }
        RSZFile[lvl].RSZHeader.instanceCount += 1;
        for (o=0; o<RSZFile[lvl].RSZHeader.objectCount-1; o++) 
            if (RSZFile[lvl].ObjectTable[o] > parentof(k).index)
                RSZFile[lvl].ObjectTable[o] += 1;
        if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
            local int ii, jj;
            while (exists(RSZFile[ii])) {
                if (startof(RSZFile[ii]) < startof(RSZFile[lvl]) && RSZFile[ii].RSZHeader.RSZoffs > RSZFile[lvl].RSZHeader.RSZoffs) {
                    //Printf("%i %i %i\n", startof(r.size)+4, startof(RSZFile[ii]), startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) );
                    RSZFile[ii].RSZHeader.dataOffset += diff;
                }
                jj=0;
                while (exists(RSZFile[ii].RSZUserDataInfos.userDataInfo[jj])) {
                    if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs + startof(RSZFile[ii]) > startof(RSZFile[lvl]))
                        RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs += diff;
                    if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs + startof(RSZFile[ii]) > startof(RSZFile[lvl]))
                        RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs += diff;
                    
                    jj++;
                }
                ii++;
            }
        } else 
            for (o=0; o<RSZFile[lvl].RSZHeader.userdataCount; o++)
                RSZFile[lvl].RSZUserDataInfos.userDataInfo[o].path.strOffset += diff;
        if (freeSpace)
            DeleteBytes(startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos), freeSpace);
        if (newPadding)
            InsertBytes(startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos), newPadding, 0);
        InsertBytes(startof(parentof(k))+8, 8, 0);
        WriteInt64(startof(parentof(k))+8, newValue);
        if (isObject) {
            InsertBytes(startof(RSZFile[lvl].InstanceInfos), 4, 0);
            WriteUInt(startof(RSZFile[lvl].InstanceInfos), parentof(k).index+1);
        }
        MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
    }

typedef struct {
    struct RSZHEADER {
	    unsigned int magic;
	    unsigned int version;
	    int objectCount;
	    int instanceCount;
	    int userdataCount;
	    int reserved;
        int64 instanceOffset;
	    int64 dataOffset;
	    int64 userdataOffset;
        local uint RSZoffs = dataOffset + startof(this);
    };

    if (!ShowChildRSZs && exists(parentof(this)))
        RSZHEADER RSZHeader <hidden=true>;
    else 
        RSZHEADER RSZHeader;

    local ushort lvl <hidden=true> = getLevel(RSZHeader.RSZoffs);

    FSeek(startof(RSZHeader.userdataOffset)+8);
    if (RSZHeader.objectCount && !ShowChildRSZs && exists(parentof(this)))
        int32 ObjectTable[RSZHeader.objectCount] <hidden=true, name=ReadObjectName, read=ReadObject>;
    else if (RSZHeader.objectCount)
        int32 ObjectTable[RSZHeader.objectCount] <name=ReadObjectName, read=ReadObject>;
    
    FSeek(startof(RSZHeader) + RSZHeader.instanceOffset);
    struct INSTANCEINFO {
        for (i=0; i< RSZHeader.instanceCount; i++) {
            struct InstanceInfo {
                local uint index <hidden=true> = i;
	            HASH typeId;
                uint CRC;
                FSkip(-8);
                int64 CombinedKey;
                FSkip(-8);
                InsertKey NewKey;
                if (!i)
                    typeId.HashName = "NULL";
            } instanceInfo <name=ReadInstanceInfoName, read=ReadInstanceInfo>;
        }
    };
    
    if (!ShowChildRSZs && exists(parentof(this)))
        INSTANCEINFO InstanceInfos <hidden=true>;
    else 
        INSTANCEINFO InstanceInfos;
    
    if (RSZHeader.userdataCount) {
	    FSeek(startof(RSZHeader) + RSZHeader.userdataOffset);
        if (!ShowChildRSZs && exists(parentof(this)))
            struct RSZUSERDATAINFOS {
                for (i=0; i<RSZHeader.userdataCount; i++)
                    RSZUserDataInfo userDataInfo;
            } RSZUserDataInfos <hidden=true>;
        else struct RSZUSERDATAINFOS RSZUserDataInfos;
    }
    local ubyte isUserData <hidden=true>;
    
    FSeek(RSZHeader.RSZoffs);
    if (RSZHeader.instanceCount > 1) {
        struct {
            local ubyte isObject <hidden=true>;
            
            local ushort lvl <hidden=true> = parentof(this).lvl;
            struct DATA {
                if (!IsInitialized())
                    ParseJson(JsonPath);
                local int temp <hidden=true>;
                local int rawData <hidden=true>;
                local int lvl <hidden=true> = getLevel(FTell());
                for (i=0; i<RSZFile[lvl].RSZHeader.instanceCount; i++) {
                    if (!finished && RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.HashName == "via.GameObject") 
                    {
                        if (FTell()+4 <= FileSize())
                            fakeGameObject Test <hidden=true>;
                        if (lastGameObject > 0 && (Test.timeScale != 3212836864 )) { 
                            Printf("Seeking from %u to last GameObject at %u\n",  FTell(), lastGameObject); 
                            FSeek(startof(Test));
                            BLANK blank <read=ReadErrorNotice, bgcolor=cRed>;
                            FSeek(lastGameObject);
                            while (FTell() <= FileSize() - 8) {
                                if (ReadUInt(FTell()) == 3212836864 && detectedBools(FTell()-4) 
                                && (detectedString(FTell()-16) || detectedString(FTell()-20) || detectedString(FTell()-24)) )
                                    break;
                                FSkip(4);
                            }
                            lastGameObject = FTell()+4;
                            Printf("Redetected next GameObject at %u\n",  lastGameObject); 
                            
                            FSkip(-32);
                            //while (FTell() > lastGameObject - 28 && !detectedString(FTell()))
                            //    FSkip(-1);
                            if (detectedString(FTell()))
                                redetectStringBehind();
                            else FSkip(8);
                            //if (detectedString(FTell()-8)) {
                            //    FSkip(-8);
                            //    redetectStringBehind();
                            //}
                            broken = false;
                            SetForeColor(cYellow);
                        } else if (FTell() > lastGameObject) {
                            lastGameObject = FTell();
                            FSeek(startof(Test));
                        }
                    }
                    temp = FTell();
                    if (GetFieldArrayState(RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.Hash, 0))
                        FSeek(getAlignedOffset(FTell(), 4));
                    else
                        FSeek(getAlignedOffset(FTell(), GetFieldAlignment(RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.Hash, 0))); 
                    
                    if (!i)
                        RSZInstance RSZ(i) <hidden=true>;
                    else
                        RSZInstance RSZ(i);
                    
                    if (sizeof(RSZ) == 0) 
                        Printf("Empty struct: %u\n", FTell()); 
                    if (exists(RSZ.skipFileData)) {
                        FSeek(temp);
                    } else if (exists(RSZ.skip)) {
                        if (i)
                            Printf("\nERROR: Missing struct for %X %s [%u]\n", RSZ.hash, RSZ.name, RSZ.idx);
                        FSeek(startof(RSZ));
                    }
                }
            };
            SetForeColor(cNone);
            if (HideRawData || (!ShowChildRSZs && exists(parentof(parentof(parentof(this)))))) //if is an embedded RSZMagic
                DATA RawData <hidden=true, open=suppress>;
            else
                DATA RawData <open=suppress>;
            SetForeColor(cNone);
            finished = TRUE;
            isUserData = false;
            if (RSZHeader.objectCount > 0 && findS(ReadObject(ObjectTable[RSZHeader.objectCount-1]), "assets:") != -1)
                isUserData = true;
            if (Nesting && Header.magic != 1280262994) { //no RCOL
                if (exists(Header.dataOffset) && startof(RSZFile[lvl]) == Header.dataOffset ) { //
                    if (exists(Header.folderCount))
                        for (n=0; n<Header.folderCount; n++) {
                            if (FolderInfos.FolderInfo[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]]));
                                struct GameObject MainFolder(1)  <name=ReadGameObjectName, read=ReadGameObject>;
                            }
                        }
                    if (exists(Header.infoCount))
                        for (n=0; n<Header.infoCount; n++) {
                            if (GameObjectInfos[n].id.id > -1 && GameObjectInfos[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[GameObjectInfos[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[GameObjectInfos[n].id.id]]));
                                struct GameObject MainObject(0)  <name=ReadGameObjectName, read=ReadGameObject>;
                            } 
                        }
                } else if (isUserData || (Header.magic != 846423661 && Header.magic != 1414940738)) { //no mfs2 bhvt
                    for (i=0; i<RSZHeader.instanceCount; i++) {
                        isObject = FALSE; 
                        for (j=0; j<RSZHeader.objectCount; j++) 
                            if (ObjectTable[j] == i) { isObject = TRUE; break; }
                        if (isObject && exists(RawData.RSZ[i])) {
                            FSeek(startof(RawData.RSZ[i]));
                            if (RSZHeader.objectCount == 1) {
                                struct RSZInstance RSZ(i) <open=true>; // <size=SizeRSZInstance;
                                checkUseSpacers();
                            } else struct RSZInstance RSZ(i); // <size=SizeRSZInstance>;
                            if (exists(RawData.RSZ[i].skip) || exists(RawData.RSZ[i].skipFileData)) 
                                FSeek(startof(RSZ));
                        }
                    }
                }
            }
            SetForeColor(cNone);
        } Data <open=true>;
    } else 
        { FSkip(-1); ubyte Data <hidden=true>; }
    
    if (exists(parentof(this)))
        checkUseSpacers();
    
    local int f <hidden=true>, ff <hidden=true>;
    if (ShowChildRSZs && (RSZHeader.userdataCount && (RSZVersion == "DMC5" || RSZVersion == "RE2")) ) {
        FSeek(RSZUserDataInfos.userDataInfo[0].dataOffs);
        struct {
            for (f=0; f<RSZHeader.userdataCount; f++) {
                FSeek(RSZUserDataInfos.userDataInfo[f].dataOffs);
                struct RSZMagic UserData <size=52>;
            }
        } UserData;
    }
    //FSeek(startof(this)+52);
} RSZMagic <name="RSZ", name=ReadRSZMagicName, read=ReadRSZMagic>;

    wstring ReadRSZMagicName(RSZMagic &m) { 
        if (exists(m.ObjectTable) && m.ObjectTable[0] >= 0 && exists(m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName)) {
            return m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName; 
        } else {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f]) == startof(m) && exists(RSZFile[f].ObjectTable) && RSZFile[f].ObjectTable[0] >= 0 && exists(RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName) ) 
                    return RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName;
            }
        }
        return "RSZ"; 
    }

    wstring ReadRSZMagic(RSZMagic &m) { 
        if (exists(m.Data.RSZ[0].title)) 
            return m.Data.RSZ[0].title;
        else if (exists(m.Data.MainObject[0].title))
            return m.Data.MainObject[0].title;
        else if (exists(m.Data.MainFolder[0].title))
            return m.Data.MainFolder[0].title;
        else {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f]) == startof(m) && exists(RSZFile[f].ObjectTable) && RSZFile[f].ObjectTable[0] >= 0 && exists(RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title) ) 
                    return RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title;
            }
        }
        return ""; 
    }

    string ReadObjectName(int &o) { 
        local ushort lvl = parentof(o).lvl;
        local uint32 hash = ReadUInt((startof(RSZFile[lvl].RSZHeader) + RSZFile[lvl].RSZHeader.instanceOffset + 8 * o)); 
        return ReadHashName(hash); 
    }

    string ReadObject(int &o) { 
        local ushort lvl = parentof(o).lvl;
        local string s;
        if (exists(RSZFile[lvl].Data.RawData.RSZ[o]))
            SPrintf(s, "%i -- %s", o, RSZFile[lvl].Data.RawData.RSZ[o].title);
        return s;
    }

    string ReadInstanceInfoName(InstanceInfo &i) { return i.typeId.HashName; }
    
    string ReadInstanceInfo(InstanceInfo &i) { string s; SPrintf(s, "%X", i.typeId.Hash); return s; }


//start of file =====================

FSeek(RSZOffset);
if (ReadUInt(0) == 4343376 || ReadUInt(0) == 5129043) // SCN or PFB
    { FSkip(-1); BLANK __; FSkip(-1); BLANK MainDataNotice <name=ReadMainDataNotice>; }
while (FTell()+4 <= FileSize()) {
    if ( ReadUInt(FTell()) == 5919570 ) { //RSZ
        finished = false;
        if (level == 1 && !FEof()) { 
            if (Header.magic == 4343376 || Header.magic == 5129043) {
                FSkip(-1); BLANK blank; 
                FSkip(-1); BLANK userDataNotice <name=ReadUserDataNotice>; 
            }
        }
        if (ReadUInt(FTell()+8) == 0)
            struct RSZMagic RSZFile <hidden=true>;
        else struct RSZMagic RSZFile;
        level++;
        FSeek(startof(RSZFile) + 4);
    } else 
        FSkip(1);
}
finished = true;
if (!exists(Header)) { //detect strings in motbank etc files:
    FSeek(0);
    while(FTell() + 6 <= FileSize())
        if (detectedString(FTell()))
            StringRead Detected_String(FTell(), 0, true); //absolute
        else 
            FSkip(2);
}

//BehaviorTree
if (exists(BehaviorTree.RawNodes)) {
    FSeek(startof(BehaviorTree.RawNodes));
    struct BHVTNode Nodes <read=ReadBHVTNode, optimize=false>;
}

//RCOL only =========================

if (ReadUInt(0) == 1280262994) { 
    FSeek(Header.groupsPtrTbl);
    struct {
        struct RcolGroup {
            rGUID Guid;
            StringRead Name(-1, 0, 0);
            uint NameHash <format=hex>;
            int UserDataIndex;
            int NumShapes;
            int NumMaskGuids;
            uint64 ShapesTbl;
            int LayerIndex;
            uint MaskBits;
            uint64 MaskGuidsOffset;
            
            if (NumMaskGuids) {
                FSeek(MaskGuidsOffset);
                rGUID MaskGuids[NumMaskGuids] <optimize=false>;
                FSeek(startof(MaskGuidsOffset)+8);
            }
            
            rGUID LayerGuid;
            FSeek(ShapesTbl);
            if (NumShapes)
                struct RcolShape {
                    rGUID Guid;
                    StringRead Name(-1, 0, 0);
                    uint NameHash <format=hex>;
                    int UserDataIndex;
                    int LayerIndex;
                    int Attribute;
                    uint SkipIdBits;
                    uint IgnoreTagBits;
                    StringRead primaryJointNameStr(-1, 0, 0);
                    StringRead secondaryJointNameStr(-1, 0, 0);
                    uint PrimaryJointNameHash <format=hex>;
                    uint SecondaryJointNameHash <format=hex>;
                    enum <uint32> {
                        ShapeType_Aabb = 0x0,
                        ShapeType_Sphere = 0x1,
                        ShapeType_ContinuousSphere = 0x2,
                        ShapeType_Capsule = 0x3,
                        ShapeType_ContinuousCapsule = 0x4,
                        ShapeType_Box = 0x5,
                        ShapeType_Mesh = 0x6,
                        ShapeType_HeightField = 0x7,
                        ShapeType_StaticCompound = 0x8,
                        ShapeType_Area = 0x9,
                        ShapeType_Triangle = 0xA,
                        ShapeType_SkinningMesh = 0xB,
                        ShapeType_Cylinder = 0xC,
                        ShapeType_DeformableMesh = 0xD,
                        ShapeType_Invalid = 0xE,
                        ShapeType_Max = 0xF,
                    } ShapeType;
                    
                    FSkip(4);
                    struct {
                        float x, y, z, w;
                        float x, y, z, w;
                        float x, y, z, w;
                        float x, y, z, w;
                        float x, y, z, w;
                    } Parameters;
                    if (UserDataIndex) {
                        local uint RSZIdx <hidden=true> = RSZFile[0].ObjectTable[UserDataIndex];
                        FSeek(startof(RSZFile[0].Data.RawData.RSZ[RSZFile[0].ObjectTable[UserDataIndex]]));
                        RSZInstance RSZ(RSZFile[0].ObjectTable[UserDataIndex]) <size=SizeRSZInstance>;
                        FSeek(startof(Parameters)+80);
                    }
                } Shape[NumShapes] <read=ReadShape, optimize=false>;
                
            FSeek(startof(LayerGuid)+16);
            checkUseSpacers();

        } Group[Header.numGroups] <size=80, read=ReadGroup, optimize=false>;
    } Groups;
    
    if (exists(Header.ignoreTagTbl) && Header.numIgnoreTags) {
        FSeek(Header.ignoreTagTbl);
        struct {
            struct RcolIgnoreTag {
                StringRead Name(-1, 0, 0);
                uint nameHash <format=hex>;
                FSkip(4);
            } IgnoreTag[Header.numIgnoreTags] <read=ReadIgnoreTag, optimize=false>; 
        } IgnoreTags;
    }
    
    if (exists(Header.autoGenerateJointDescTbl) && Header.numAutoGenerateJoints) {
        FSeek(Header.autoGenerateJointDescTbl);
        struct {
            uint ukn; //placeholder
        } AutoGenerateJointDescs;
    }

    if (exists(Header.numRequestSets) && Header.numRequestSets) {
        FSeek(Header.requestSetTbl);
        struct {
            for (n=0; n<Header.numRequestSets; n++)
                struct RcolRequestSet {
                    uint ID;
                    int GroupIndex;
                    int ShapeOffset;
                    uint status;
                    StringRead Name(-1, 0, 0);
                    uint NameHash <format=hex>;
                    FSkip(4);
                    StringRead KeyName(-1, 0, 0);
                    uint KeyHash <format=hex>;
                    
                    FSeek(startof(Groups.Group[GroupIndex]));
                    struct RcolGroup Group <read=ReadGroup, size=80>;
                    
                    local uint RSZIdx <hidden=true> = RSZFile.ObjectTable[n];
                    FSeek(startof(RSZFile.Data.RawData.RSZ[RSZIdx]));
                    RSZInstance RSZ(RSZIdx) <open=true, size=SizeRSZInstance>;

                    SetForeColor(cNone);
                    FSeek(startof(KeyHash)+8);
                } RequestSet <size=48, name=ReadRequestSetName, read=ReadRequestSet>;
        } RequestSets;
    }
} 
    wstring ReadGroup(RcolGroup &g) { return ReadWString(ReadUInt64(startof(g)+16)); }

    wstring ReadShape(RcolShape &s) { return s.Name.String; } 

    wstring ReadRequestSet(RcolRequestSet &a) { return ReadWString(ReadUInt(startof(a)+16)); }

    wstring ReadRequestSetName(RcolRequestSet &a) { string s; SPrintf(s, "RequestSet ID: %u  ", ReadUInt(startof(a))); return s; }

enum BHVTlvl {
    id_All = -1,
    id_Actions = 0,
    id_Selectors = 1,
    id_SelectorCallers = 2,
    id_Conditions = 3,
    id_transitionEvents = 4,
    id_expressionTreeConditions = 5,
    id_staticActions = 6,
    id_staticSelectorCallers = 7,
    id_staticConditions = 8,
    id_staticTransitionEvents = 9,
    id_staticExpressionTreeConditions = 10,
    id_TransitionId = 11
};

typedef struct(BHVTlvl lv) {
    local short lvl <hidden=true>;
    switch (lv) {
        case 0: lvl=getLevelRSZ(Header.BHVT.actionOffset+80); break;
        case 1: lvl=getLevelRSZ(Header.BHVT.selectorOffset+80); break;
        case 2: lvl=getLevelRSZ(Header.BHVT.selectorCallerOffset+80); break;
        case 3: lvl=getLevelRSZ(Header.BHVT.conditionsOffset+80); break;
        case 4: lvl=getLevelRSZ(Header.BHVT.transitionEventOffset+80); break;
        case 5: lvl=getLevelRSZ(Header.BHVT.expressionTreeConditionsOffset+80); break;
        case 6: lvl=getLevelRSZ(Header.BHVT.staticActionOffset+80); break;
        case 7: lvl=getLevelRSZ(Header.BHVT.staticSelectorCallerOffset+80); break;
        case 8: lvl=getLevelRSZ(Header.BHVT.staticConditionsOffset+80); break;
        case 9: lvl=getLevelRSZ(Header.BHVT.staticTransitionEventOffset+80); break;
        case 10: lvl=getLevelRSZ(Header.BHVT.staticExpressionTreeConditionsOffset+80); break;
        default: lvl=-1; break;
    }
    
    int hash <format=hex>;
    if (finished)
    if (lv == id_TransitionId) {
        m=0;
        while(exists(Header.TransitionMap[m])) {
            if (Header.TransitionMap[m].transitionId == hash) {
                FSeek(startof(Header.TransitionMap[m]));
                struct TRANSITIONMAP TransitionMap;
                break;   
            }
            m++;
        }
    } else if (hash != -1 && hash != 0 ) {  //&& exists(Nodes)

        local int kk <hidden=true>, valueStart <hidden=true>, doExit <hidden=true>;
        if (lvl == -1) {
            while (exists(BehaviorTree.RawNodes.Node[kk]) ) {

                if (hash == BehaviorTree.RawNodes.Node[kk].ID.hash || hash == BehaviorTree.RawNodes.Node[kk].exID.hash 
                && startof(BehaviorTree.RawNodes.Node[kk].exID.hash) != startof(this)) {
                    valueStart = startof(BehaviorTree.RawNodes.Node[kk]);
                    if (startof(this) != valueStart) {
                        FSeek(valueStart);
                        i = -1;
                        struct BHVTNode Node <size=SizeBHVTNode, open=true>;
                        checkUseSpacers();
                    }
                    doExit = true;
                    break;
                }
                kk++;
            }
        }
        
        if (true) { //search for RSZ structs
            (lv == -1) ? j=0 : j=lvl; 
            if (!exists(RSZFile[j]))
                j=0;
            while(exists(RSZFile[j])) { 
                i = 0;
                while (exists(RSZFile[j].Data.RawData.RSZ[i])) {
                    k = 0;
                    while(exists(RSZFile[j].Data.RawData.RSZ[i].var[k])) {
                        if (exists(RSZFile[j].Data.RawData.RSZ[i].var[k].data)) 
                        
                        if (ReadInt(startof(RSZFile[j].Data.RawData.RSZ[i].var[k].data)) == hash) { // || 
                            FSeek(startof(RSZFile[j].Data.RawData.RSZ[i]));
                            lvl = j;
                            struct RSZInstance RSZ(i) <open=true>; //size=SizeRSZInstance, 
                            checkUseSpacers();
                            doExit = true;
                            break;
                        } 

                        k++;
                    }
                    i++;
                    if (doExit) break;
                }
                if (doExit || ((lv != -1 && lv != id_Actions) && (!exists(RSZFile[j+1]) || RSZFile[j+1].isUserData == false) )) 
                    break;
                j++;
            }
        }
    }
    FSeek(startof(hash)+4);
} BHVTHash <optimize=false, read=ReadBHVTHash, write=WriteBHVTHash>;

    int SizeBHVTNode(BHVTNode &b) {
        local ushort z;
        for (z=0; z<BehaviorTree.mNodeCount; z++) {
            if (startof(b) == startof(BehaviorTree.RawNodes.Node[z]))
                return sizeof(BehaviorTree.RawNodes.Node[z]);
        }
    }

    wstring ReadBHVTHash(BHVTHash &h) { 
        if (exists(h.Node)) 
            return ReadBHVTNode(h.Node); 
        if (exists(h.RSZ)) 
            return ReadRSZInstanceName(h.RSZ); 
        string s; 
        if (exists(h.hash))
            SPrintf(s, "%X\n", h.hash);
        else if (exists(h.Hash)) 
            SPrintf(s, "%X\n", h.Hash);
        return s; 
    } 
    
    void WriteBHVTHash(BHVTHash &h, string s) { h.hash = Atoi(s); } 

    //wstring ReadBHVTHashName(BHVTHash &h) { if (exists(h.RSZ)) return h.RSZ.name; return ""; } 