//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: RE_RSZ.bt
//   Authors: alphaZomega w/ help from Darkness and Praydog
//   Version: 0.49
//   Purpose: Parsing RE Engine RSZ data
//  Category: RE Engine
// File Mask: *.user.2;*.pfb.*;*.scn.*;*.rcol.*;*.bhvt.*;*.motfsm2.*;*.fsmv2.*
//  ID Bytes: 
//   History: August 7, 2021
//------------------------------------------------
//              Option:                                                           //Effect:
local string    RSZVersion      <hidden=false>       = "DMC5";                    //change between RE2, RE3, RE8 or DMC5
local int       Nesting         <hidden=true>        = TRUE;                      //Attempt to nest class instances inside eachother
local int       ShowAlignment   <hidden=true>        = FALSE;                     //Show metadata for each variable
local int       ShowChildRSZs   <hidden=true>        = FALSE;                      //Show all RSZs one after another, non-nested. Disabling hides nested RSZHeaders
local int       UseSpacers      <hidden=true>        = TRUE;                      //Show blank rows between some structs
local int       AutoDetectGame  <hidden=true>        = TRUE;                      //Automatically detect RSZVersion based on the name + ext of the file being viewed
local int       ReadBHVTHeader  <hidden=true>        = TRUE;

//Game							                    //Extracted Path
local wstring DMC5Path <hidden=true> =              "D:\\modmanager\\REtool\\DMC_chunk_000\\natives\\x64\\";
local wstring RE2Path <hidden=true> =               "D:\\modmanager\\REtool\\RE2_chunk_000\\natives\\x64\\";
local wstring RE3Path <hidden=true> =               "D:\\modmanager\\REtool\\RE3_chunk_000\\natives\\stm\\";
local wstring RE8Path <hidden=true> =               "D:\\modmanager\\REtool\\RE8_chunk_000\\natives\\stm\\";


//RSZ Parser By Darkness:
#link "RSZParser.dll"
ubyte   IsInitialized();
void    ParseJson(string jsonPath);
string  GetRSZClassName(uint32 classHash);
uint32  GetFieldCount(uint32 classHash);
uint32  GetFieldAlignment(uint32 classHash, uint32 fieldIndex);
ubyte   GetFieldArrayState(uint32 classHash, uint32 fieldIndex);
string  GetFieldName(uint32 classHash, uint32 fieldIndex);
string  GetFieldTypeName(uint32 classHash, uint32 fieldIndex);
string  GetFieldOrgTypeName(uint32 classHash, uint32 fieldIndex);
uint32  GetFieldSize(uint32 classHash, uint32 fieldIndex);
uint64  GetFieldType(uint32 classHash, uint32 fieldIndex);
ubyte   IsFieldNative(uint32 classHash, uint32 fieldIndex);
#endlink

//Local variables:
local int i <hidden=true>, j <hidden=true>, k <hidden=true>, m <hidden=true>, n <hidden=true>, o <hidden=true>, 
            matchSize <hidden=true>, lastGameObject <hidden=true>;
local int RSZOffset <hidden=true> = FindFirst("RSZ",1,0,0,0.0,1,0,0,24);
local int level <hidden=true>;
local int finished <hidden=true>;
local int broken <hidden=true>;

//local int fileOffsets[100000] <hidden=true>;
if (ShowAlignment) {
    local int varLen <hidden=false>;
    local uint offs[1000000] <hidden=false>, aligns[1000000] <hidden=false>, sizes[1000000] <hidden=false>; //synced
} else {
    local int varLen <hidden=true>;
    local uint offs[1000000] <hidden=true>, aligns[1000000] <hidden=true>, sizes[1000000] <hidden=true>; //synced
}

local wstring extractedDir <hidden=true>;
local wstring Local_Directory  <hidden=true> = FileNameGetPath(GetFileName(), true);
local uint findValue <hidden=true> = find(Local_Directory, "natives");
Local_Directory = StrDel( Local_Directory, findValue, sizeof(Local_Directory) - findValue) + "natives\\";
local wstring lower <hidden=true> = Lower(Local_Directory);
	
if (AutoDetectGame) {

    if (find(lower, "dmc") != -1 || find(lower, "evil may") != -1) {
	    RSZVersion = "DMC5";
	    extractedDir = DMC5Path;

    } else if (find(lower, "re2") != -1 || find(lower, "evil 2") != -1) {
	    RSZVersion = "RE2";
	    extractedDir = RE2Path;

    } else if (find(lower, "re3") != -1 || find(lower, "evil 3") != -1) {
	    RSZVersion = "RE3";
	    extractedDir = Lower(RE3Path);
	    Local_Directory += "stm\\";

    } else if (find(lower, "re8") != -1 || find(lower, "evil 8") != -1 || find(lower, "illage") != -1) {
	    RSZVersion = "RE8";
	    extractedDir = Lower(RE8Path);
	    Local_Directory += "stm\\";

    } else 
	    Local_Directory += "x64\\";

} else if (RSZVersion == "DMC5" || RSZVersion == "RE2" || RSZVersion == "RE7") {
    Local_Directory += "x64\\";
} else {
    Local_Directory += "stm\\";
}
Local_Directory = Lower(Local_Directory);
local string JsonPath<hidden=true> = Lower(FileNameGetPath(GetTemplateFileName()) + "RSZ" + RSZVersion + ".json"); 
ParseJson(JsonPath);

//Special functions & structs:
LittleEndian();

//Create enums here:
void enums(){
    if (fieldName == "DmgType") {
        FSkip(-4);
        enum { 
            None = -1,
            Minimum = 0,
            NormalS = 1,
            NormalL = 2,
            NormalLL = 3,
            Down = 4,
            DownBound = 5,
            Slam = 6,
            SlamBound = 7,
            Upper = 8,
            HyperUpper = 9,
            HyperUpperAir = 10,
            Blown = 11,
            Collapse = 12,
            RollingUpper = 13,
            CheckSpin = 14,
            Spin = 15,
            DiagonalBlown = 16,
            WindS = 17,
            WindL = 18,
            SnatchRelase = 19,
            StraightBlown = 20,
            Tremor = 21,
            Inhale = 22,
            MotionContinue = 23,
            Explosion = 24
        } DamageType;
    }
}

void align(uint alignment) { 
    while (FTell() % alignment != 0 && FTell() <= FileSize()) 
    FSkip(1); 
}

int detectedFloat(uint64 offset) {
    if (offset+4 <= FileSize()) {
        local float flt = ReadFloat(offset);
        return (ReadUByte(offset+3) != 255 && (Abs(flt) > 0.0000001 && Abs(flt) < 10000000) || flt == 0); 
    } return false;
}

int detectedString(uint64 offset) { 
    return offset+6 <= FileSize() && (ReadByte(offset) != 0 && ReadByte(offset + 1) == 0 && ReadByte(offset + 2) != 0 && ReadByte(offset + 3) == 0 && ReadByte(offset + 4) != 0 && ReadByte(offset + 5) == 0);
}

int find(wstring str, wstring term) { return (RegExSearch(str, term, matchSize, 0)); }

wstring Lower(wstring s1) {
	local string s = s1;
    local string s2 = s;
    for (k=0; k < sizeof(s); k++)
        s2[k] = ToLower(s[k]);
    return s2;
}

uint detectedBools(uint tell) {
    local uint nonBoolTotal;
    for (o=0; o<4; o++)
        if (ReadUByte(tell + o) > 1)
            nonBoolTotal++;
    if (nonBoolTotal == 0)
        return true;
    return false;
}

void FileOpener(wstring path) { 
    local wstring tmpNm = GetTemplateFileNameW();
	FileOpen(path, TRUE, "hex", 1); 
    FileSelect(FindOpenFileW(path));
	if (GetTemplateFileNameW() == "")
		RunTemplate(tmpNm, 0);
}

typedef byte BLANK <name=readBLANK, read=readBLANK, write="">;

    string readBLANK(BLANK &ref) { return " ";}

    string ReadErrorNotice(BLANK &b) { return "[Read Error Adjustment]"; }

void checkUseSpacers() {
    if (UseSpacers) {
        FSkip(-1); 
        BLANK blank;
    }
}

typedef enum <uint32> {
	ukn_error = 0,
	ukn_type,
	not_init,
	class_not_found,
	out_of_range,
	Undefined_tid,
	Object_tid,
	Action_tid,
	Struct_tid,
	NativeObject_tid,
	Resource_tid,
	UserData_tid,
	Bool_tid,
	C8_tid,
	C16_tid,
	S8_tid,
	U8_tid,
	S16_tid,
	U16_tid,
	S32_tid,
	U32_tid,
	S64_tid,
	U64_tid,
	F32_tid,
	F64_tid,
	String_tid,
	MBString_tid,
	Enum_tid,
	Uint2_tid,
	Uint3_tid,
	Uint4_tid,
	Int2_tid,
	Int3_tid,
	Int4_tid,
	Float2_tid,
	Float3_tid,
	Float4_tid,
	Float3x3_tid,
	Float3x4_tid,
	Float4x3_tid,
	Float4x4_tid,
	Half2_tid,
	Half4_tid,
	Mat3_tid,
	Mat4_tid,
	Vec2_tid,
	Vec3_tid,
	Vec4_tid,
	VecU4_tid,
	Quaternion_tid,
	Guid_tid,
	Color_tid,
	DateTime_tid,
	AABB_tid,
	Capsule_tid,
	TaperedCapsule_tid,
	Cone_tid,
	Line_tid,
	LineSegment_tid,
	OBB_tid,
	Plane_tid,
	PlaneXZ_tid,
	Point_tid,
	Range_tid,
	RangeI_tid,
	Ray_tid,
	RayY_tid,
	Segment_tid,
	Size_tid,
	Sphere_tid,
	Triangle_tid,
	Cylinder_tid,
	Ellipsoid_tid,
	Area_tid,
	Torus_tid,
	Rect_tid,
	Rect3D_tid,
	Frustum_tid,
	KeyFrame_tid,
	Uri_tid,
	GameObjectRef_tid,
	RuntimeType_tid,
	Sfix_tid,
	Sfix2_tid,
	Sfix3_tid,
	Sfix4_tid,
	Position_tid,
	F16_tid,
	End_tid,
	Data_tid
} TypeIDs;

typedef struct VARDATA(uint algn) {
    local ubyte alignment = algn;
    local uint offset = getAlignedOffset(FTell(), algn);
    local uint varSz = offset; //placeholder
    local ubyte padding = offset - FTell();
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());
    
    if (offset > FTell()) {
        while (FTell() != offset) {
            if (!broken && ReadByte(FTell()) != 0) {
                SetForeColor(cNone);
                ubyte blank <hidden=true>;//, fgcolor=cRed>;
            } else FSkip(1);
        }
        FSeek(offset);
    }
    
    if (!finished) {
        local uint varIdx = varLen;
        varLen++;
        if (offs[varIdx] == 0) {
            if ( varIdx != 0 && offs[varIdx-1] >= offset) { //new vars at the same offset overwrite old ones
                varLen--;
                varIdx--;
            } else {
                offs[varIdx] = offset;
                aligns[varIdx] = alignment;
                sizes[varIdx] = -1;
            }
        }
    }
    if (!FEof())
        ubyte varStart <hidden=true>;
};

uint getAlignedOffset(uint tell, uint alignment) {
    local uint offset = tell;
    switch (alignment) {
        case 2:  offset = tell + (tell % 2); break;  //2-byte
        case 4:  offset = (tell + 3) & 0xFFFFFFFFFFFFFFFC; break;  //4-byte
        case 8:  offset = (tell + 7) & 0xFFFFFFFFFFFFFFF8; break;  //8-byte
        case 16: offset = (tell + 15) & 0xFFFFFFFFFFFFFFF0; break; //16-byte
        default: break;
    }
    return offset;
}

//re-aligns variables, given the index of the first variable after the change (varIdx), the offset at the end of the change (tell), and the amount of bytes lost/gained (sizeChange):
void fixAlignment(uint varIdx, uint tell, uint sizeChange) {
    local int diff;
    local int oldPadding;
    
    //apply original size difference to all offsets after the change:
    for (m=varIdx+1; m<varLen; m++) 
        offs[m] += sizeChange;
    
    //remove all old padding from after the change:
    for (m=varLen-3; m>varIdx; m--) {
        oldPadding = offs[m+1] - (offs[m] + sizes[m]);
        
        if (oldPadding > 0) {
            //Printf("%u deleting %i bytes from %u\n", m, oldPadding, offs[m+1] - oldPadding);
            DeleteBytes(offs[m+1] - oldPadding, oldPadding);
        }
        for (o=varLen-1; o>m; o--) 
            offs[o] -= oldPadding;
    }
    
    //remove old padding from struct directly following the change:
    oldPadding = offs[varIdx+1] - tell;
    if (oldPadding > 0) {
        DeleteBytes(tell, oldPadding);
        for (o=varIdx+1; o<varLen; o++) 
            offs[o] -= oldPadding;
    }
    
    //add new padding for each variable based on its type:
    for (m=varIdx+1; m<varLen; m++) {
        offs[m] += diff;
        while (aligns[m] && offs[m] % aligns[m] != 0) {
            InsertBytes(offs[m], 1, 0);
            offs[m] += 1;
            diff += 1;
        }
    }
    MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
}

void setSize() {
    if (exists(Alignment.varStart)) {
        Alignment.varSz = FTell() - startof(Alignment.varStart);
        if (!finished && sizes[Alignment.varIdx] == -1) 
            sizes[Alignment.varIdx] = Alignment.varSz;
    }
}

void setAlignment(uint algn) {
    if (ShowAlignment)
        struct VARDATA Alignment(algn) <name="Alignment">;
    else
        struct VARDATA Alignment(algn) <name="Alignment", hidden=true>;
    FSkip(-1);
}

int getLevel(uint offset) {
    local int L = 0;
    for (L=0; L<level; L++)
        if (offset >= startof(RSZFile[L].Data) && offset < startof(RSZFile[L].Data) + sizeof(RSZFile[L].Data))
            break;
    return L;
}

typedef struct {
    uchar uuid[16];
} rGUID <read=ReadrGUID>;

    string TranslateGUID (uchar uuid[]) {
        local char s[37];
        SPrintf(s, 
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
            uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7],
            uuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]
        );
        return s;
    }

    wstring ReadrGUID (rGUID &g) {
        local string Guid = TranslateGUID(g.uuid);
        if (exists(GameObjectInfos.Guid))
            for (o=0; o<Header.infoCount; o++)
                if ( TranslateGUID(GameObjectInfos[o].Guid.uuid) == Guid) {
                    local ushort lvl <hidden=true>;
                    if (exists(parentof(g).lvl)) 
                        lvl = parentof(g).lvl;
                    else lvl = getLevel(startof(g));
                    if (exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id]].Name.data))
                        SPrintf(Guid, "%s[%u] -- %s", RSZFile[lvl].RawData.RSZ[ObjectTable[GameObjectInfos[o].id.id]].Name.data, RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id], Guid);
                    else if (exists(RSZFile[lvl]))
                        SPrintf(Guid, "%s[%u] -- %s", RSZFile[lvl].InstanceInfos.instanceInfo[ RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id] ].typeId.HashName, RSZFile[lvl].ObjectTable[GameObjectInfos[o].id.id], Guid);
                    break;
                }
        return Guid;
    }
    /*wstring ReadrGUID (rGUID &g) {
        local char s[37];
        SPrintf(s, 
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
            g.uuid[0], g.uuid[1], g.uuid[2], g.uuid[3], g.uuid[4], g.uuid[5], g.uuid[6], g.uuid[7],
            g.uuid[8], g.uuid[9], g.uuid[10], g.uuid[11], g.uuid[12], g.uuid[13], g.uuid[14], g.uuid[15]
        );
        return s;
    }*/

//section for opening files:

string getRE2ext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".tex": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769669";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": case ".fbxskel": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1808312334";
		case ".fsmv2": case ".bhvt": case ".motfsm2": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".lprb": return ".3";
		case ".mmtr": return ".1808160001";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

string getRE3ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".12";
		case ".pfb": return ".17";
		case ".mdf2": return ".13";
		case ".tex": return ".190820018";
		case ".rcol": case ".jmap": return ".11";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1902042334";
		case ".fsmv2": case ".bhvt": case ".tml": case ".clip": return ".34";
		case ".motfsm2": return ".36";
		case ".scn": return ".20";
		case ".mov": return ".1";
		case ".chain": return ".24";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".99";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".78";
		case ".gui": return ".340020";
		case ".rmesh": return ".17008";
		case ".rtex": return ".4";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".14";
		case ".msg": return ".15";
		default: return "";
	}
}

string getRE8ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".16";
		case ".pfb": return ".17";
		case ".mdf2": return ".19";
		case ".tex": return ".30";
		case ".rcol": return ".18";
		case ".jmap": return ".17";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".2101050001";
		case ".bhvt": case ".tml": return ".34";
		case ".fsmv2": case ".clip": return ".40";
		case ".motfsm2": return ".42";
		case ".scn": return ".20";
		case ".mov": case ".finf": return ".1";
		case ".chain": return ".39";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".486";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".458";
		case ".gui": return ".400023";
		case ".rmesh": return ".17008";
		case ".rtex": return ".5";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".17";
		case ".msg": return ".15";
		case ".gpuc": return ".62";
		default: return "";
	}
}

string getDMCext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769672";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": return ".2";
		case ".wel": case ".tex":  return ".11";
		case ".mesh": return ".1808282334";
		case ".fsmv2": case ".bhvt": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".fbxskel": case ".lprb": return ".3";
		case ".motfsm2": return ".31";
		case ".mmtr": return ".1808168797";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

string MakeBackslashes (wstring path) {
	local wstring localPath <hidden=true> = path;
	if (find(path, "@") != -1)
		localPath = StrDel(localPath, 0, 1);
	local uint index = find(localPath, "/");

	while (index != -1) {
		localPath = StrDel(localPath, index, sizeof(localPath) - index + 1) + "\\" + SubStr(localPath, index + 1, -1);
		index = find(localPath, "/");
	} return localPath;
}

void ReadRSZPath(wstring data) {
	local wstring localPath <hidden=true> = data;
	if (RSZVersion == "DMC5") {
		localPath = MakeBackslashes(localPath) + getDMCext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE3") {
		localPath = MakeBackslashes(localPath) + getRE3ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE2") {
		localPath = MakeBackslashes(localPath) + getRE2ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE8") {
		localPath = MakeBackslashes(localPath) + getRE8ext(FileNameGetExtension(localPath));
	}
	if (exists(fullPath)) {
	    fullPath = Local_Directory + localPath;
	    if (Local_Directory != extractedDir && FileExists(Local_Directory + localPath)) {
		    local uint existsInMod <hidden=false> = 1;
		    fullPath = Local_Directory + localPath;
	    }
	    if (extractedDir != "" && FileExists((extractedDir + localPath))) {
		    if (exists(existsInMod)) {
			    local uint existsInPak <hidden=false> = 1;
		    } else { 
			    local uint existsInPak <hidden=true> = 1; 
			    fullPath = extractedDir + localPath;
		    }
	    }
	    if (fullPath != "" && FileExists(fullPath)) {
		    FSkip(-1);
		    ubyte OpenFile <name="OpenFile", write=WriteOpenFile, read=ReadOpenFile, open=false>;
	    }
    }
}

    string ReadOpenFile (ubyte &in) { return "Input here to open File"; }
    
    void WriteOpenFile(ubyte &in, wstring s) { FileOpener(parentof(in).fullPath); }

int detectedGuid(uint tell) {
    local int zerosCount;
    for (o=0; o<16; o++) 
        zerosCount += (ReadUByte(FTell()+o) == 0);
    return zerosCount;
}

int detectedObject(uint tell) {
    local int test = ReadInt(tell);
    if (detectedString(tell))
        setAsBroken();
    if (tell+4 <= FileSize() && test < idx && test > 0 && (test > idx - 100 || exists(userDataPath)))
        return true;
    return false;
}

void redetectObject() {
    if (!finished && broken ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4) {
            if (detectedObject(FTell())) {
                SetForeColor(cYellow);
                Printf("Redetected object from %u to %u\n",  pos, FTell()); 
                break;
            } else FSkip(4);
        }
    }
}

void setAsBroken() {
    FSkip(-1);
    broken = true;
    SetForeColor(cNone);
    ubyte blank <hidden=true, bgcolor=cRed>;
}

void redetectFloat() {
    if (broken && FTell() + 4 <= FileSize() && (broken && !finished)) { 
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && detectedFloat(FTell()))
            FSkip(4);
        
        if (FTell() != pos && FTell() < pos + 16) {
            broken = FALSE;
            SetForeColor(cYellow);
            Printf("Redetected float from %u to %u\n",  pos, FTell()); 
        } else FSeek(pos);
    }
    if (!detectedFloat(FTell()) && ReadFloat(FTell()) != 0) {
        broken = TRUE;
        SetForeColor(cNone);
    }
}

void redetectGuid() {
    if (FTell() + 16 <= FileSize() && !finished && (detectedGuid(FTell()) >= 4)) { // && broken
        local int pos = FTell();
        //if (broken) 
        //    FSkip(-12);
        while(FTell() <= FileSize() - 16) {
            if (detectedGuid(FTell()) == 16 || (detectedGuid(FTell()) < 4 && (detectedGuid(FTell()) <= detectedGuid(FTell() + 8)))) {
                if (pos != FTell()) {
                    broken = FALSE;
                    SetForeColor(cYellow);
                    Printf("Redetected GUID from %u to %u\n",  pos, FTell()); 
                }
                break;
            } else FSkip(8);
        }
    }
}

int isValidString(uint tell) {
    local int alignedOffs = getAlignedOffset(tell, 4);
    if (alignedOffs + 4 >= FileSize())
        return false;
    local uint size = ReadUInt(alignedOffs);
    if (sizeof(ReadWString(alignedOffs+4)) == 0)
        return false;
    local wstring String = ReadWString(alignedOffs+4);
    return (alignedOffs+8 <= FileSize() && ReadUInt64(alignedOffs) == 1 || size == 0 || (size == sizeof(String)/2 && ReadUByte(alignedOffs+7 != 0)) );
}

void redetectStringBehind() {
    local int pos = FTell();
    if (detectedString(FTell())) {
        while (detectedString(FTell()) && ReadUInt(FTell()-4) != sizeof(ReadWString(FTell())) / 2) 
            FSkip(-2);
        FSkip(-4);
        if (pos == FTell() || !isValidString(FTell()) || (sizeof( ReadWString(FTell()+4)) + FTell() <= pos) ) {
            //Printf("Aborting string redetection from %u to %u\n",  pos, FTell()); 
            FSeek(pos);
            setAsBroken();
        } else if (FTell() < pos) {
            SetForeColor(cYellow);
            broken = FALSE;
            Printf("Redetected string from %u back to %u\n",  pos, FTell()); 
        }
    } 
}

void redetectString() {
    if (!broken && !isValidString(FTell()+4)) 
        return;
    if  (FTell() + 4 <= FileSize() && ( !finished && (broken || !isValidString(FTell()) ) ) ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && FTell() - 24 < pos) {
            if (((detectedString(FTell()) && isValidString(FTell()-4)))) {
                FSkip(-4);
                break;
            } else uint skip <hidden=true>; //fgcolor=cRed,
        }
        if (FTell() - pos > 16 && broken) {
            FSeek(pos); //abort
        } else if (FTell() - pos > 8 && !broken) {
            FSeek(pos); //abort
        } else {
            SetForeColor(cYellow);
            broken = FALSE;
            Printf("Redetected string from %u to %u\n",  pos, FTell()); 
        }
    }
}

void ForceWriteString(uint tell, uint maxSize, wstring str) {
    OverwriteBytes(tell, maxSize, 0); 
    if (str != " " && str != "")
        WriteWString(tell, str); 
}

typedef ubyte Bool <read=ReadBOOL, write=WriteBOOL>;

    wstring ReadBOOL(Bool &b) {
        if (b)
            return "True";
        return "False";
    }
    
    void WriteBOOL(Bool &b, wstring s) {
        if (find(Lower(s), "true") != -1 || Atoi(s) >= 1)
            b = 1;
        else b = 0;
    }
    
    /*void WriteCount(uint &count, wstring s) { //changes lists
        if (!broken && Atoi(s) >= 0) { 
            local int newCount = Atoi(s);
            local int itemDiff = newCount - count.data;
            local int diff = count.itemSz * itemDiff;
            
            if (exists(parentof(count).item)) {
                if (!exists(parentof(count).item[0].isString) || itemDiff < 0)
                    diff = parentof(count).item[0].Alignment.varSz * itemDiff; 
                if (diff > 0) {
                    InsertBytes(parentof(count).item[count.data-1].Alignment.offset + parentof(count).item[count.data-1].Alignment.varSz, diff, 0);
                    fixAlignment(parentof(count).item[count.data-1].Alignment.varIdx, diff + parentof(count).item[count.data-1].Alignment.offset + parentof(count).item[count.data-1].Alignment.varSz, diff);
                } else if (diff < 0 && newCount >= 0) {
                    if (exists(parentof(count).item[0].isString))
                        diff = (parentof(count).item[newCount].Alignment.offset) - (parentof(count).item[count.data-1].Alignment.offset + parentof(count).item[count.data-1].Alignment.varSz);
                    DeleteBytes(parentof(count).item[newCount].Alignment.offset, Abs(diff));
                    if (newCount)
                        fixAlignment(parentof(count).item[newCount].Alignment.varIdx, parentof(count).item[newCount].Alignment.offset, diff);
                    else
                        fixAlignment(count.Alignment.varIdx + count.data, count.Alignment.offset + 4, diff);
                }
            } else if (diff > 0) {
                InsertBytes(count.Alignment.offset+4, diff, 0);
                fixAlignment(count.Alignment.varIdx, count.Alignment.offset + diff + 4, diff);
            }
            count.data = newCount;
        }
    }*/

//main typedef for RSZ chunks:

typedef struct Variable(uint32 classHash, ubyte fieldIndex) {
    local uint32 classHash <hidden=true> = classHash;
    local ubyte fieldIndex <hidden=true> = fieldIndex;
    local string fieldName <hidden=true> = GetFieldName(classHash, fieldIndex);
    local string fieldDataType <hidden=true> = GetFieldTypeName(classHash, fieldIndex);
    local TypeIDs fieldType <hidden=true> = GetFieldType(classHash, fieldIndex);
    local ushort elementSize <hidden=true> = GetFieldSize(classHash, fieldIndex);
    local ubyte align <hidden=true> = GetFieldAlignment(classHash, fieldIndex);
    local ubyte isList <hidden=true> = GetFieldArrayState(classHash, fieldIndex);
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());

    if ((isList) && !exists(parentof(this).Count)) {
		setAlignment(4);
        if (FTell()+4 <= FileSize()) {
            //if (!ShowChildRSZs)
            //    uint Count <hidden=true>;
            //else 
                uint Count;
		    setSize();
            if (Count && Count * elementSize <= FileSize() - FTell() && !detectedString(FTell())) {
                local uint c <hidden=true>;
                for (c=0; c<Count; c++) {
                    if (FTell()+4 <= FileSize() && (fieldType != Object_tid || ReadInt(FTell()) < idx && ReadInt(FTell()) > 0 ) )
			            struct RSZVariable var(classHash, fieldIndex);
                    else if ((FTell()+4 != FileSize())) {
                        setAsBroken();
                        break;    
                    }
                }
            }
        }
	} else {
        setAlignment(align);
		switch (fieldType) {
			case Bool_tid:
				if (FTell()+1 <= FileSize())
				    Bool data;
				break;
			case Color_tid:
                if (FTell()+4 <= FileSize())
				    ubyte R, G, B, A;
				break;
			case F32_tid:
				fieldDataType = "Float";
				if (FTell()+4 <= FileSize())
				    float data;
				break;
			case F64_tid:
				fieldDataType = "Double";
				if (FTell()+8 <= FileSize())
				    double data;
				break;
			case Float2_tid:
			case Point_tid:
            case Segment_tid:
				if (FTell()+8 <= FileSize())
				    float data <name="float x">, data <name="float y">;
				break;
			case Float3_tid:
				if (FTell()+12 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				break;
			case Quaternion_tid:
			case Float4_tid:
				if (FTell()+16 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				break;
			case GameObjectRef_tid:
            case Guid_tid:
            case Uri_tid:
				if (FTell()+16 <= FileSize())
				    rGUID Guid;
                break;
            case OBB_tid:
            case AABB_tid:
            case Capsule_tid:
            case LineSegment_tid:
			case Mat4_tid:
				if (FTell()+32 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                    if (fieldType == Capsule_tid) {
                        if (FTell()+4 <= FileSize())
				            float data <name="float r">;
                    } else if (fieldType != AABB_tid) {
					    if (FTell()+32 <= FileSize()) {
				            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
					        float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (fieldType == OBB_tid && FTell()+16 <= FileSize())
                                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        } 
                    }
                }
				break;
			case UserData_tid:
            case Object_tid:
                if (FTell()+4 <= FileSize())
                    if (!ShowChildRSZs)
                        uint ObjectIndex <hidden=true>;
                    else
			            uint ObjectIndex;
                if (fieldType == UserData_tid && exists(ObjectIndex) && ObjectIndex > -1) {
                    if ((RSZVersion == "DMC5" || RSZVersion == "RE2") && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx) 
                    && exists(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].dataOffs)) {
                        FSeek(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].dataOffs);
                        struct RSZMagic UserData <open=true, size=52>;
                        FSeek(startof(ObjectIndex)+4);
                        checkUseSpacers();
                        break;
                    } else if (exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx)) {
                        FSkip(-1);
                        struct StringRead path ( (startof(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx])+8), startof(RSZFile[lvl].RSZHeader), 0);
                        break;
                    } 
                } else if (fieldType == Object_tid &&  exists(ObjectIndex) &&ObjectIndex > -1 && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) {
					FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])); 
					struct RSZInstance RSZ <open=true, size=SizeRSZInstance>;
					FSeek(startof(ObjectIndex)+4);
                    checkUseSpacers();
				}
				break;
			case Range_tid:
                if (FTell()+8 <= FileSize())
				    float data <name="float R">, data <name="float S">;
				break;
			case RangeI_tid:
                if (FTell()+8 <= FileSize())
				    int data <name="int R">, data <name="int S">;
				break;
			case RuntimeType_tid:
                if (FTell()+4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size <= FileSize())
					    char data[size];
                }
				break;
			case S16_tid:
                if (FTell()+2 <= FileSize())
				    short data;
				break;
			case S32_tid:
				fieldDataType = "Int";
				if (FTell()+4 <= FileSize())
				    int data;
				break;
			case S64_tid:
				fieldDataType = "Int64";
				if (FTell()+8 <= FileSize())
				    int64 data;
				break;
			case S8_tid:
				fieldDataType = "Byte";
				if (FTell()+1 <= FileSize())
				    byte data;
				break;
			case Size_tid:
				fieldDataType = "Size";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U16_tid:
				fieldDataType = "UShort";
				if (FTell()+2 <= FileSize())
				    ushort data;
				break;
			case U32_tid:
				fieldDataType = "UInt";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U64_tid:
				fieldDataType = "UInt64";
				if (FTell()+8 <= FileSize())
				    uint64 data;
				break;
			case U8_tid:
				fieldDataType = "UByte";
				if (FTell()+1 <= FileSize())
				    ubyte data;
				break;
			case Vec2_tid:
				if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">;
				    float data <hidden=true>, data <hidden=true>; //FSkip(8);
                }
				break;
			case Vec3_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				    float data <hidden=true>; //FSkip(4);
                }
				break;
			case Vec4_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                }
				break;
			case Int2_tid:
                if (FTell()+8 <= FileSize())
				    int32 data <name="int x">, data <name="int y">;
                break;
            case Int3_tid:
                if (FTell()+12 <= FileSize())
				    int32 data <name="int x">, data <name="int y">, data <name="int z">;
                break;  
            case Uint3_tid:
                if (FTell()+12 <= FileSize())
				    uint32 data <name="uint x">, data <name="uint y">, data <name="uint z">;
                break;
            case Data_tid:
            case ukn_type: 
                if (find((wstring)fieldDataType, "tring") == -1) { //if NOT a string:
                    if (elementSize == 1 ) { 
                        fieldDataType = "Byte";
                        if (FTell()+1 <= FileSize())
				            byte data;
                    } else if (elementSize == 2) {
                        fieldDataType = "Int16";
                        if (FTell()+2 <= FileSize())
				            short data;
                    } else if (elementSize == 4) {
                        fieldDataType = "Data";
                        if (FTell()+4 <= FileSize())
                            if (ReadUInt(FTell()) != 0 && detectedFloat(FTell()) && ReadUByte(FTell()+3) != 255) {
                                if (FTell()+4 <= FileSize()) {
				                    float data;
                                    FSkip(-4);
                                    int data_As_Int;
                                }
                            } else if (detectedObject(FTell())){
                                fieldDataType = "Data (Object?)";
                                if (FTell()+4 <= FileSize()) {
				                    int ObjectIndex <name="int data (ObjectIndex?)">;
					                if (exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) {
						                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]));
						                struct RSZInstance RSZ <open=true, size=SizeRSZInstance>;
						                FSeek(startof(ObjectIndex)+4);
						                FSkip(-1);
						                BLANK blank;
                                        //checkUseSpacers();
					                }
                                }
                            } else {
                                if (FTell()+4 <= FileSize()) {
				                    int data;
                                    FSkip(-4);
                                    float data_As_Float;
                                }
                            }
                    } else if (elementSize == 8) {
                        if (detectedFloat(FTell()) && detectedFloat(FTell()+4)) {
                            if (FTell()+8 <= FileSize())
				                float data <name="float x">, data <name="float y">;
                        } else {
                            fieldDataType = "Int64";
                            if (FTell()+8 <= FileSize())
				                int64 data;
                        }
                    } else if (elementSize == 16) {
                        if (align == 8) {
                            fieldDataType = "Guid";
                            //redetectGuid();
                            if (FTell()+16 <= FileSize())
				                rGUID Guid;
                        } else {
                            fieldDataType = "Vec4";
                            if (FTell()+16 <= FileSize())
				                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        }
                    } else if (elementSize == 64 || elementSize == 80) {
                        fieldDataType = "Mat4";
                        if (FTell()+4 <= FileSize()) {
                            float data <name="float x1">, data <name="float y1">, data <name="float z1">, data <name="float w1">;
                            float data <name="float x2">, data <name="float y2">, data <name="float z2">, data <name="float w2">;
                            float data <name="float x3">, data <name="float y3">, data <name="float z3">, data <name="float w3">;
                            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (elementSize == 80) {
                                fieldDataType = "OBB";
                                if (FTell()+16 <= FileSize())
				                    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            }
                        }
                    } else {
                        if (FTell()+elementSize <= FileSize())
				            ubyte data[elementSize];
                    }
                    break;
                } //if it IS a string, don't break and continue on:
            
			case Resource_tid:
			case String_tid:
                fieldType = String_tid;
				fieldDataType = "String";
                FSeek(getAlignedOffset(FTell(), 4));
                redetectStringBehind();
				FSeek(getAlignedOffset(FTell(), 4)); 
                if (isValidString(FTell()) && ReadUInt(FTell()) != 0)
                    broken=false;
                else redetectString();
                if (FTell() + 4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size * 2 <= FileSize() )
					    wchar_t data[size];
                    if (size > 0 && !exists(data) && !detectedFloat(FTell()-4)) 
                        setAsBroken();
                    local ubyte isString <hidden=true> = TRUE;
                    if (!isValidString(startof(size)) && size > 64)
                        FSeek(startof(size)+1);
                } else FSeek(startof(this));
				break;
			default:
				Printf("%u Unknown type in class \"%s\" (Hash: 0x%08X) field number %d returned TypeID = \"%d\" ListFlag = \"%d\"\r\n", FTell(), GetRSZClassName(classHash), classHash, fieldIndex, fieldType, isList);
                if (elementSize % 4 == 0)
                    float data[elementSize/4];
                else
                    ubyte data[elementSize];
				break;
		}
        
        if (elementSize > 16)
            FSeek(startof(Alignment.varStart) + elementSize);
    }
    //Printf("%s %i %i\n", fieldName, startof(Alignment.varStart),  startof(Alignment.varStart) + elementSize);
    setSize();
    
    if (title == "") {
        if (exists(size) && exists(data) && size > 1) {
            title = (wstring)data;
        } else if (exists(this.UserData) && secondTitle == "") { //&& sizeof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].title) > sizeof(title)
            secondTitle = ReadRSZMagic(this.UserData);
        } else if (fieldIndex == 0 && secondTitle == "" && exists(ObjectIndex) && ObjectIndex > -1 && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]) && RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].title != "") {
            secondTitle = RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].title;
            //if (fieldIndex == 0)
            //    title = secondTitle;
        } else if (secondTitle == "" && exists(this.Guid) && ReadUInt64(startof(Guid)) != 0) {
            secondTitle = ReadrGUID(Guid);
        }
    }
    
    if (fieldDataType == "String" && exists(data) && find((wstring)data, "/") != -1 && FileNameGetExtension((wstring)data) != ".json") {
        local wstring fullPath <hidden=true>;
        ReadRSZPath((wstring)data);
    }
    if (FTell() < startof(this))
        FSeek(startof(this));
};

typedef Variable RSZVariable <optimize=false, name=ReadRSZVariableName, read=ReadRSZVariable, write=WriteRSZVariable>; //, comment=ReadRSZVariableComment

    string ReadRSZVariableName(RSZVariable &r) { 
        if (r.isList) {
            if ((exists(r.var[0]) && exists(r.var[0].ObjectIndex) && r.var[0].ObjectIndex != 0) || exists(r.var[0].UserData) )
                return "List" + " (" + r.fieldDataType + ") *" + r.fieldName;
            return "List" + " (" + r.fieldDataType + ") " + r.fieldName;
        } else if (exists(r.ObjectIndex) && exists(parentof(r).fieldDataType) && parentof(r).fieldDataType == "List") {
            string s; 
            SPrintf(s, "%s[%u]", RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].name, r.ObjectIndex);
            return s;
        } else if (r.fieldDataType != "") {
            if ((exists(r.RSZ) && r.ObjectIndex != 0) || exists(r.UserData) )
                return r.fieldDataType + " *" + r.fieldName; 
            else if (r.fieldDataType + " " + r.fieldName == "Byte v0")
                return "Byte v0 (isEnabled)";
            return r.fieldDataType + " " + r.fieldName;  
        } else return r.fieldName; 
    }
    
    void WriteRSZString(RSZVariable &r, wstring s) { 
        local int oldDataSz;
        if (exists(r.data)) 
            wstring oldData = r.data;
        else
            wstring oldData = "";
        if (exists(r.data)) {
            oldDataSz = sizeof(r.data); //sizeof(ReadWString(startof(r.data))); //
            local int temp;
            for (o=0; o<Header.resourceCount; o++) {
                if (exists(ResourceInfos.ResourceInfo[o].pathStr) && ResourceInfos.ResourceInfo[o].pathStr.String == oldData) {
                    while (ReadByte(startof(ResourceInfos.ResourceInfo[o].pathStr.String)+oldDataSz+temp) == 0)
                        temp++;
                    oldDataSz += temp;
                } else if (exists(ResourceInfos.ResourceInfo[o].path) && ResourceInfos.ResourceInfo[o].path == oldData) {
                    while (ReadByte(startof(ResourceInfos.ResourceInfo[o].path)+oldDataSz+temp) == 0)
                        temp++;
                    oldDataSz += temp;
                }
            }
                    
            Printf("Sizeof(s)=%i, sizeof(r.data)=%i \n", sizeof(s)-2, oldDataSz);
        }
        local int sizeToInsert = (sizeof(s)-2) - oldDataSz;
        if (exists(r.data))
            Printf("%i\nr.data: %s\ns.data: %s\n", sizeToInsert, r.data, s);
        if (sizeToInsert > 0) {
            while (sizeToInsert % 16 != 0)
                sizeToInsert++;
            Printf("%i\n", sizeToInsert);
            if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
                local int ii, jj;
                while (exists(RSZFile[ii])) {
                    if (startof(r.size)+4 > startof(RSZFile[ii]) && startof(r.size)+4 < startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) && startof(RSZFile[r.lvl]) != startof(RSZFile[ii])) {
                        Printf("%i %i %i\n", startof(r.size)+4, startof(RSZFile[ii]), startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) );
                        RSZFile[ii].RSZHeader.dataOffset += sizeToInsert;
                    }
                    jj=0;
                    while (exists(RSZFile[ii].RSZUserDataInfos.userDataInfo[jj])) {
                        if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs + startof(RSZFile[ii]) > startof(r.size)+4)
                            RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs += sizeToInsert;
                        if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs + startof(RSZFile[ii]) > startof(r.size)+4)
                            RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs += sizeToInsert;
                        
                        jj++;
                    }
                    ii++;
                }
            }
            InsertBytes(startof(r.size)+4, sizeToInsert, 0); 
        } else 
            sizeToInsert = 0;
        ForceWriteString(startof(r.size)+4, sizeToInsert+oldDataSz, s); 
        r.size = (sizeToInsert+oldDataSz)/2;
        if (find(oldData, "/") != -1) { //sizeToInsert > 0 && 
            //Printf("Part2:\n%i\nr.data: %s\ns.data: %s\n", sizeToInsert, r.data, s);
            
            Header.dataOffset += sizeToInsert;
            local int h;
            if (exists(Header.userdataCount)) {
                for (h=0; h<Header.userdataCount; h++)
                    userDataInfos.userDataInfo[h].pathOffset.strOffset += sizeToInsert;
                for (h=0; h<Header.prefabCount; h++)
                    PrefabInfos.PrefabInfo[h].id += sizeToInsert;
            }
                
            local int paddingBytes;
            while((RSZFile[r.lvl].RSZHeader.dataOffset + sizeToInsert + paddingBytes) % 16 != RSZFile[r.lvl].RSZHeader.dataOffset % 16)
                paddingBytes++;
            //Printf("PaddingBytes:%i\n", paddingBytes);
            if (paddingBytes)
                InsertBytes(RSZFile[r.lvl].RSZHeader.dataOffset + startof(RSZFile[r.lvl].RSZHeader), paddingBytes, 0);
            RSZFile[r.lvl].RSZHeader.dataOffset += paddingBytes;
            local int changeOffs;
            if (exists(Header.userdataCount)) // if not PFB
                for (h=0; h<Header.resourceCount; h++) {
                    if (ResourceInfos.ResourceInfo[h].pathStr.String == oldData) {
                        changeOffs = startof(ResourceInfos.ResourceInfo[h].pathStr.String);
                        //DeleteBytes(startof(ResourceInfos.ResourceInfo[h].pathStr.String), sizeof(ResourceInfos.ResourceInfo[h].pathStr.String));
                        if (sizeToInsert > 0)
                            InsertBytes(startof(ResourceInfos.ResourceInfo[h].pathStr.String) + sizeof(ResourceInfos.ResourceInfo[h].pathStr.String), sizeToInsert);
                        ForceWriteString(startof(ResourceInfos.ResourceInfo[h].pathStr.String), oldDataSz, s);
                    }
                    if (changeOffs > 0 && changeOffs < startof(ResourceInfos.ResourceInfo[h].pathStr.String))
                        ResourceInfos.ResourceInfo[h].pathStr.strOffset += sizeToInsert;
                }
            if (sizeToInsert > 0)
                MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
        }
    }

    wstring ReadRSZVariable(RSZVariable &r) {
        local string s;
        if (exists(r.UserData)) {
            return ReadRSZMagic(r.UserData);
        } else if (exists(r.var)) {
            if (exists(r.var.ObjectIndex)) {
                SPrintf(s, "%s[%u]", RSZFile[r.lvl].Data.RawData.RSZ[r.var[0].ObjectIndex].name, r.var[0].ObjectIndex);
                if (r.var[0].ObjectIndex != r.var.ObjectIndex)
                    SPrintf(s, "%s - [%u]", s, r.var.ObjectIndex);
            } else 
                return ReadRSZVariable(r.var[0]);
        } else if (exists(r.ObjectIndex) && r.ObjectIndex > -1 && exists(RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex])) {
            if (exists(RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].title) && RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].title != "")
                return RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].title;
        } else 
            switch (r.fieldType) {
                case Bool_tid:
                    if (exists(r.data))
                        s = ReadBOOL(r.data);
                    break;
		        case S16_tid:
		        case S32_tid:
		        case S64_tid:
		        case Size_tid:
		        case S8_tid:
		        case U16_tid:
		        case U32_tid:
		        case U64_tid:
                    if (exists(r.data))
                        SPrintf(s, "%Li", r.data);
                    break;
                case F32_tid:
                    if (exists(r.data))
                        SPrintf(s, "%f", r.data);
                    break;
		        case Resource_tid:
                case String_tid:
                    if (exists(r.data))
                        return r.data;
                    break;
                case Float2_tid:
                case Vec2_tid:
                case Point_tid:
                case Range_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                    break;
                case Vec3_tid:
                case Float3_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g]", r.data[0], r.data[1], r.data[2]);
                    break;
                case Vec4_tid:
                case Mat4_tid:
                case Float4_tid:
				case Quaternion_tid:
                case Int3_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                    break;
                case Guid_tid:
                case GameObjectRef_tid:
                case Uri_tid:
                    if (exists(r.Guid))
                        s = ReadrGUID(r.Guid);
                    break;
                case AABB_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g]  [%g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[4],  r.data[5],  r.data[6]);
                    break;
                case Mat4_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g %g]  [%g, %g, %g %g]  [%g, %g, %g %g]  [%g, %g, %g %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                    break;
                case ukn_type:
                case Data_tid:
                    if (exists(r.data) && r.elementSize == 1 ) { //|| r.fieldOrgTypeName == "Data1A1"
                        if (r.data == 1) {
                            s = "True";
                        } else if (r.data == 0) {
                            s = "False";
                        } else 
                            SPrintf(s, "%i", r.data);
                    } else if (exists(r.data) && r.elementSize == 4) {
                        if (exists(r.data_As_Int))
                            SPrintf(s, "%f", r.data);
                        else if (Abs(r.data) > 1000000) 
                            SPrintf(s, "%X", r.data);    
                        else 
                            SPrintf(s, "%i", r.data);
                    } else if (exists(r.data) && r.elementSize == 8) {
                        if (exists(r.data[1]) && (detectedFloat(FTell()) || detectedFloat(FTell()+4)))
                            SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                        else
                            SPrintf(s, "%Li", r.data);
                    } else if (r.elementSize == 16) {
                        if (exists(r.Guid))
                            s = ReadrGUID(r.Guid);
                        else if (exists(r.data[3]))
                            SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                    } else if (exists(r.data) && r.elementSize == 64) {
                        SPrintf(s, "[%g, %g, %g %g]  [%g, %g, %g %g]  [%g, %g, %g %g]  [%g, %g, %g %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], 
                            r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                    }
                    break;
                default:
                    break;
            }
        return s;
    }

    //wstring ReadRSZVariableComment(RSZVariable &r) {
    //    return r.fieldOrgTypeName;
    //}

    void WriteRSZVariable(RSZVariable &r, wstring s) {
        if (exists(r.fullPath) && r.fullPath != "" && sizeof(s) <= 6) {
            FileOpener(r.fullPath);
        } else {
            local int pos = startof(r.Alignment.varStart);
            switch (r.fieldType) {
                case Bool_tid:
                    WriteBOOL(r.data, s); break;
		        case S16_tid:
                    WriteShort(pos, Atoi(s)); break;
		        case Object_tid:
		        case UserData_tid:
                case Size_tid:
		        case S32_tid:
                    WriteInt(pos, Atoi(s)); break;
		        case S64_tid:
                    WriteInt64(pos, Atoi(s)); break;
		        case S8_tid:
                    WriteByte(pos, Atoi(s)); break;
		        case U16_tid:
                    WriteUShort(pos, Atoi(s)); break;
		        case U32_tid:
                    WriteUInt(pos, Atoi(s)); break;
		        case U64_tid:
                    WriteUInt64(pos, Atoi(s)); break;
                case F32_tid:
                    WriteFloat(pos, Atof(s)); break;
                case String_tid:
                case Resource_tid:
                    WriteRSZString(r, s);
                    break;
                case Vec2_tid:
                case Range_tid:
                case Float2_tid:
                case Point_tid:
                    writeRSZArray(r, s, 2, 4);
                    break;
                case Vec3_tid:
                case Float3_tid:
                    writeRSZArray(r, s, 3, 4);
                    break;
                case Vec4_tid:
                case Float4_tid:
                case Quaternion_tid:
                    writeRSZArray(r, s, 4, 4);
                    break;
                case AABB_tid:
                    writeRSZArray(r, s, 8, 4);
                    break;
                case Mat4_tid:
                    writeRSZArray(r, s, 16, 4);
                    break;
                case Data_tid:
                case ukn_type:
                    s = Lower(s);
                    if (exists(r.data) && r.elementSize == 1) {
                        if (s == "true") {
                            r.data = 1;
                        } else if (s == "false") {
                            r.data = 0;
                        } else r.data = Atoi(s);
                    } else if (exists(r.ObjectIndex) || exists(r.data_As_Int) || exists(r.data_As_Float)) {
                        if (exists(r.data_As_Int)) {
                            WriteFloat(startof(r.Alignment.varStart), Atof(s));
                        } else {
                            WriteInt(startof(r.Alignment.varStart), Atoi(s));
                        }
                    } else if (exists(r.size) || find((wstring)r.fieldDataType, "tring") != -1) {
        	            WriteRSZString(r, s);
                    } else if (r.fieldDataType == "Vec4") {
                        writeRSZArray(r, s, 4, 4);
                    }
                    break;
                default:
                    break;
            }
        }
    }

    void writeRSZArray(RSZVariable &r, wstring array, uint count, uint elementSize) {
        local uint q; 
        local float outArr[count];
        local string fmtString;
        if (array[0] == 91)
            fmtString += "[";
        if (find(array, ",") == -1) {
            for (q=0; q<count-1; q++)
                fmtString += "%g ";
            fmtString += "%g";
        } else {
            for (q=0; q<count-1; q++)
                fmtString += "%g,";
            fmtString += "%g";
        }
        if (count == 2)
            SScanf(array, fmtString, r.data[0], r.data[1]);
        else if (count == 3)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2]);
        else if (count == 4)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2], r.data[3]);
        else if (count == 8)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7]);
        else if (count == 16)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10],  r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
    }

typedef struct {
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else lvl = getLevel(FTell()); //doesnt work with on-demand structs
    
    local int idx <hidden=true> = i; //doesnt work with on-demand structs
    if (!exists(parentof(parentof(this)).rawData) && idx >= RSZFile[lvl].RSZHeader.instanceCount)
        for (o=1;o<RSZFile[lvl].RSZHeader.instanceCount;o++)
            if (startof(RSZFile[lvl].Data.RawData.RSZ[o]) == startof(this)) 
                { idx = o; break; }
    
    if (exists(parentof(this).ObjectIndex) ) {
        idx = parentof(this).ObjectIndex;  
    } else if (exists(parentof(this).RSZIdx) )
        idx = parentof(this).RSZIdx;
    if (!IsInitialized() ) { //|| GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF
        Printf("Not initialized at %u", FTell());
        ParseJson(JsonPath);  Printf("\nParsing JSON %s\n", JsonPath);
    }
    
    local string name <hidden=true> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.HashName;
    local wstring title <hidden=true>; 
    local wstring secondTitle <hidden=true>;
    local uint hash <hidden=true, format=hex> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash;
    local ubyte isUserData <hidden=true>;

    if (exists(RSZFile[lvl].RSZUserDataInfos))
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].typeId == hash) 
                { isUserData = TRUE; break; }

    if (name == "Unknown Class!"){
        Printf("Hash %X not found in ClassHashDecoder!\n", hash);
        byte skip <hidden=true>;
    } else if (hash == 0xF767C93F) { //"via.physics.UserData"
        for (j=idx+1; j<RSZFile[lvl].RSZHeader.instanceCount; j++) {
            if (finished && RSZFile[lvl].InstanceInfos.instanceInfo[j].typeId.Hash == 0xF767C93F ) {
                local uint ObjectIndex <hidden=true> = j - 1;
                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]));
                if (!exists(parentof(parentof(this)).idx) || (parentof(parentof(this)).idx != j - 1)) {
                    struct RSZInstance RSZ <size=SizeRSZInstance>;
                    checkUseSpacers();
                }
                FSeek(startof(this));
                break;
            }
            if (j > 100)
                break;
        }
    } else if (GetFieldCount(hash) == 0xFFFFFFFF && idx) { 
        Printf("Class %u %s not detected in JSON!\n", hash, name);
        byte skip <hidden=true>;
    } else if (isUserData) {
        byte skipFileData <hidden=true>;
        local short userDataIdx <hidden=true> = -1;
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == RSZ.idx) { 
                userDataIdx = j;
                if (RSZVersion != "RE2" && RSZVersion != "DMC5") {
                    local wstring userDataPath <hidden=true> = RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String; 
                    local wstring fullPath <hidden=true>;
                    ReadRSZPath(userDataPath);
                    if (title == "")
                        title = userDataPath;
                }
                break; 
            }
    } else if (idx && !FEof()) {
        local int z <hidden=true>;
        for (z = 0; z < GetFieldCount(hash); z++)
            struct RSZVariable var(hash, z);
    } 
    if (FEof())
        i = RSZHeader.instanceCount;   
    
    if (title == "") 
        if (secondTitle != "")
            title = secondTitle;
        else if (exists(var[0]))
            title = ReadRSZVariable(var[0]);
    
    if (FTell() - startof(this)  == 0) { 
        ubyte skipFileData <hidden=true>;
    }
    if (FTell()==startof(this))
        Printf(name + "\n");
} Instance;

typedef Instance RSZInstance <name=ReadRSZInstanceName, read=ReadRSZInstance, write=WriteRSZInstance>;

    wstring ReadRSZInstanceName(RSZInstance &r) { 
        local ushort lvl <hidden=true>;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else lvl = getLevel(startof(r));
        string s;
        
        if (exists(r.skip) || exists(parentof(r).ObjectIndex) && exists(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex].skip))
            s = "*";

        if (exists(parentof(r).ObjectIndex)) {
            lvl = parentof(r).lvl;
            SPrintf(s, "%s[%u] ", RSZFile[lvl].InstanceInfos.instanceInfo[parentof(r).ObjectIndex].typeId.HashName, parentof(r).ObjectIndex);
        } else if (exists(r.idx)) {
            if (exists(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx]))
                s += RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.HashName;
            else if (exists(r.name))
                s += r.name;
            if (!exists(parentof(r).rawData))
                SPrintf(s, "%s[%u] ", s, r.idx);
        } else if (exists(RSZFile[lvl].RSZHeader)) {
            for (o=1;o<RSZFile[lvl].RSZHeader.instanceCount;o++) {
                if (startof(RSZFile[lvl].Data.RawData.RSZ[o]) == startof(r) && !exists(RSZFile[lvl].Data.RawData.RSZ[o].skipFileData) ) {  //
                    SPrintf(s, "%s[%u] ", RSZFile[lvl].Data.RawData.RSZ[o].name, o);
                    break; 
                }
            }
        }
        return s;
    }

    int SizeRSZInstance(RSZInstance &r) { 
        local ushort lvl;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else 
            lvl = getLevel(startof(r));
        
        if (exists(parentof(r).ObjectIndex))
            return sizeof(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex]); 

        for (k=0; k<RSZFile[lvl].RSZHeader.instanceCount; k++)
            if (exists(RSZFile[lvl].Data.RawData.RSZ[k]) && startof(RSZFile[lvl].Data.RawData.RSZ[k]) == startof(r) 
            && (!exists(RSZFile[lvl].Data.RawData.RSZ[k+1]) || startof(RSZFile[lvl].Data.RawData.RSZ[k+1]) != startof(r)) ) //WTF
                if (sizeof(RSZFile[lvl].Data.RawData.RSZ[k]) != 0)
                    return sizeof(RSZFile[lvl].Data.RawData.RSZ[k]); 

        if (exists(parentof(r).tempN))
            return (sizeof(RSZFile[lvl].Data.RawData.RSZ[i]));
    
        return 1;
    }

    wstring ReadRSZInstance(RSZInstance &r) {
        local ushort lvl;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else lvl = getLevel(startof(r));
        if (exists(r.skip) || (exists(parentof(r).ObjectIndex) && exists(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex].skip))) {
            return ReadHash(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.Hash);
        } else if (exists(r.skipFileData)) {
            for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
                if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == r.idx)
                    return RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String;
        } else if (exists(r.title) ) {
            return r.title;
        } else if (exists(parentof(r).ObjectIndex) ) {
            return RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex].title;
        } else {
            for (o=1;o<RSZFile[lvl].RSZHeader.instanceCount;o++) 
                if (startof(RSZFile[lvl].Data.RawData.RSZ[o]) == startof(r) && !exists(RSZFile[lvl].Data.RawData.RSZ[o].skipFileData))
                    return RSZFile[lvl].Data.RawData.RSZ[o].title;
        } return "";
    }

    void WriteRSZInstance(RSZInstance &r, string s) { 
        if (exists(r.fullPath) && sizeof(s) <= 6)
            FileOpener(r.title);
    }

//Other typedefs:

typedef struct(int64 atAddress, int64 addOffset, ubyte isAbsolute) {
    if (!isAbsolute) {
        if (atAddress > -1)
            FSeek(atAddress);
        uint64 strOffset;
        FSeek(strOffset + addOffset);
    } else 
        FSeek(atAddress + addOffset);
    wstring String;
    if (find(String, "/") != -1 && FileNameGetExtension(String) != ".json") {
        local wstring fullPath <hidden=true>;
        ReadRSZPath(String);
    }
    if (exists(strOffset)) {
        if (atAddress == -1 || startof(this) == atAddress)
            FSeek(startof(strOffset)+8);
        else 
            FSeek(startof(this)+1);
    }
    
} StringRead <fgcolor=cNone, read=ReadStringRead, write=WriteStringRead>;

    wstring ReadStringRead(StringRead &st) { return st.String; }
    
    void WriteStringRead(StringRead &st, string s) { 
        if (exists(st.fullPath) && st.fullPath != "" && sizeof(s) <= 6)
            FileOpener(st.fullPath);
        else
            st.String = s; 
    }
    
    string PrefabName(StringRead &p) {
        if (exists(p.OpenFile))
            return "Prefab (Exists)";
        return "Prefab";
    }

typedef struct {
	uint32 Hash;
	local string HashName = ReadHashName(Hash);
} HASH <read=ReadHASH>;

    string ReadHASH (HASH &h) {
	    return ReadHash(h.Hash);
    }
    
    string ReadHash(uint32 &input) {
	    string s;
	    SPrintf(s, "%X", input);
	    return s;
    }
    
    string ReadHashName(uint32 &input) {
        if (!IsInitialized())
            ParseJson(JsonPath);
        return GetRSZClassName(input);
    }

typedef struct {
    wstring str;
} WSTRING <optimize=false, read=ReadWSTRING, write=WriteWSTRING>;
    wstring ReadWSTRING(WSTRING &input) { return input.str; }
    void WriteWSTRING(WSTRING &input, wstring s) {
        for (k = 0; k < sizeof(input.str)/2; k++)
            input.str[k] = 0;
        input.str = s;
    }

typedef struct {
    FSkip(16);
} SUBPROP4 <optimize=false>;

typedef struct {
    uint32 nameHash, ukn;
    local uint64 test <hidden=true> = ReadUInt64(FTell());
    if (test > 0 && start + test <= FileSize() && start + test > FTell()) {
        uint64 hashOffs; 
        FSeek(start + hashOffs);
        rGUID Guid;
    } else if (detectedFloat(FTell())) {
        float value;
    } else { uint value; }
    if (exists(value))
        local float hiddenValue <hidden=true> = value;
    FSeek(startof(nameHash) + 16);
} HASHPROP <read=ReadHASHPROP, optimize=false>;

    string ReadHASHPROP (HASHPROP &input) {
        string s = "";
        if (exists(input.hiddenValue))
            SPrintf(s, "%g", input.hiddenValue);
        return s;
    }

typedef struct {
    ushort propCount, B, C; //skipToNextLine();
    skipToNextLine();
    uint64 offs1, offs2;
    if (propCount > 0) {
        if (offs1 <= FileSize()) {
            FSeek(start + offs1);
            string name; //SUBPROP3 SubProp3;
        }
        if (offs2 <= FileSize()) {
            FSeek(start + offs2);
            if (ReadUShort(FTell()+2) != 0)
                HASHPROP Value;
            else
                SUBPROP4 SubProp4;
        }
    }
    FSeek(startof(this)+32);
} SUBPROP2 <optimize=false>;

typedef struct {
    uint64 nameOffset;
    uint64 dataOffset;
    local int pos <hidden=true> = FTell();
    FSeek(start + nameOffset);
    if (nameOffset > 0 && nameOffset <= FileSize())
        string name <open=suppress>;
    FSeek(start + dataOffset);
    if (dataOffset > 0 && dataOffset <= FileSize())
        HASHPROP Hashed_Value;
    if (exists(Hashed_Value.hiddenValue))
        local float hiddenValue <hidden=true> = Hashed_Value.hiddenValue;
    FSeek(pos);
    FSkip(16);
} NODE <name=ReadNODENAME, read=ReadNODE, optimize=false>;

    string ReadNODENAME (NODE &input) {
        if (exists(input.name))
            return input.name;
        return "";
    }

    string ReadNODE (NODE &input) {
        string s = "";
        if (exists(input.hiddenValue))
            SPrintf(s, "%g", input.hiddenValue);
        return s;
    }
typedef struct {
    uint64 countA;
    ushort countB, countC;
    uint D;
    for (k=0; k<countA; k++) {
        if (ReadUInt64(FTell()) > FileSize()) {
            //
        } else {
            NODE Node;
        }
    }
    if (countC > 1)
        struct {
            FSkip(16);
        } ukn[countC-1] <optimize=true>;
} OFFSET2_DATA;

typedef struct {
    uint64 nodesOffset;
    uint64 offset2;
    ushort propCount, B, C; //skipToNextLine();
    if (propCount > 0) {
        if (nodesOffset > 0) {
            FSeek(start + nodesOffset);
            if (ReadUInt(FTell()) <= FileSize())
                struct NODE Node[propCount];
            else 
                string name <open=suppress>;
        }
        if (offset2 > 0) {
            FSeek(start + offset2);
            if (ReadUInt64(FTell()) > FileSize()) {
                //SUBPROP2 Prop2;
                struct {
                    FSkip(16);
                } Beginning_Of_Offset2_Data;
            } else {
                OFFSET2_DATA Offset2_Data;
            }
        }
    }
} PROP <read=ReadProp, optimize=false>;  
    
    string ReadProp (PROP &input) {
        if (exists(input.name))
            return input.name;
        return "";
    }


typedef struct {
    rGUID Guid;
    uint64 nameOffset;
    FSeek(start + nameOffset);
    wstring name <open=suppress>;
    FSeek(startof(nameOffset) + 8);
    uint64 floatOffset, uknOffset;
    uint type : 24;
    uint numBits : 8;
    uint nameHash;

    if (floatOffset > 0) { //!didSeek && 
        FSeek(start + floatOffset);
        
        if ((numBits / 32) <= 1) {
            float Value_As_Float;
            FSeek(startof(Value_As_Float));
            int Value_As_Int;
        } else {
            float Value_As_Float[(numBits / 32)];
            FSeek(startof(Value_As_Float[0]));
            int Value_As_Int[(numBits / 32)];
        }
    }
    if (uknOffset > 0) {
        FSeek(start + uknOffset);
        PROP VarData;           
    }
    FSeek(startof(nameHash) + 4);
} UVARIABLE <optimize=false, name=ReadUVariableName, read=ReadUVariable, write=WriteUVariable>;

    wstring ReadUVariableName(UVARIABLE &input) { if (exists(input.VarData)) return (input.name + "*"); return input.name; }

    void WriteUVariable(UVARIABLE &input, string s) { WriteUInt(startof(input.Value_As_Int), Atoi(s)); }

    wstring ReadUVariable(UVARIABLE &input) {
        string s = "";
        if (exists(input.Value_As_Float)) {
            if (detectedFloat(startof(input.Value_As_Float)))
                SPrintf(s, "%g", input.Value_As_Float[0]);
            else
                SPrintf(s, "%u", input.Value_As_Int[0]); 
        }
        return (s);
    }

local int start <hidden=true>;
typedef struct {
    start = startof(parentof(this));
    struct {
        uint version;
        uint magic;
        uint64 stringsOffset;
        uint64 dataOffset;
        uint64 embedsInfoOffset;
        uint64 hashInfoOffset;
        uint64 ukn;
        uint UVARhash;
        ushort variableCount;
        ushort embedCount;
        //if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
        //    FSeek(getAlignedOffset(FTell(),16));
        //    uint64 uknOffs, uknOffs, uknOffs, uknOffs;
        //}
    } Header;

    if (Header.variableCount && Header.dataOffset+start > startof(this)) { 
        FSeek(start + Header.dataOffset);
        struct {
            for (j=0;j<Header.variableCount;j++) {
                struct UVARIABLE Var;
            }
        } Data;
    }
    if (Header.stringsOffset) { 
        FSeek(start + Header.stringsOffset);
        struct {
            if (Header.variableCount)
                WSTRING str[Header.variableCount] <open=suppress>;
            else while (detectedString(FTell()))
                WSTRING str <open=suppress>;
        } Strings;
    }
    if (Header.embedCount && Header.embedsInfoOffset) {
        FSeek(start + Header.embedsInfoOffset);
        uint64 embedOffsets[Header.embedCount];
        for (i=0; i<Header.embedCount; i++) {
            FSeek(start + embedOffsets[i]);
            struct UVAR UVAR_File;
            start = startof(parentof(this));
        }
    }
    
    if (Header.variableCount && Header.hashInfoOffset+start > startof(this)) {
        struct {
            FSeek(start + Header.hashInfoOffset);
            uint64 HashDataOffsets[4];
            FSeek(start + HashDataOffsets[0]);
            struct {
                struct {
                    uint64 dataHash, dataHash;
                } Hash[Header.variableCount];
            } dataHashes;
            FSeek(start + HashDataOffsets[1]);
            struct {
                uint index[Header.variableCount];
            } dataHashMap;
            FSeek(start + HashDataOffsets[2]);
            struct {
                uint nameHash[Header.variableCount];
            } nameHashes;
            FSeek(start + HashDataOffsets[3]);
            struct {
                uint index[Header.variableCount];
            } nameHashMap;
        } HashData;
    }

} UVAR <read=ReadUVAR>;

    wstring ReadUVAR (UVAR &input) {
        if (exists(input.Data.Var[0]))
            return input.Data.Var[0].name;
        return "";
    }

struct OBJECTID(int lv) {
    int id;
    local int level <hidden=true> = lv;
};

typedef OBJECTID ObjectId <read=ReadObjectIdTitle, write=WriteObjectId>;

    wstring ReadObjectIdName(ObjectId &o) {
        local string s;
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) && exists(RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]])) {
            s = RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]].typeId.HashName;
            if (s != "")
                SPrintf(s, "%s[%i]", s, RSZFile[o.level].ObjectTable[o.id]);
        }
        return s;
    }

    wstring ReadObjectId(ObjectId &o) {
        local string s;
        SPrintf(s, "%i", o.id);
        return s;
    }

    void WriteObjectId(ObjectId &o, string s) {
        o.id = Atoi(s);
    } 

    wstring ReadObjectIdTitle(ObjectId &o) {
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) 
        && exists(RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]])) {
            local string s = ReadObjectId(o) + " -- " + RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]].title;
            return s;
        }
        return "";
    }

struct fakeGameObject {
    FSeek(getAlignedOffset(FTell(), 4));
    uint size0;
    if (size0 && FTell()+size0*2 <= FileSize())
        wchar_t name[size0];
    FSeek(getAlignedOffset(FTell(), 4));
    uint size1;
    if (size1 && FTell()+size1*2 <= FileSize())
        wchar_t tag[size1];
    FSeek(getAlignedOffset(FTell()+2, 4));
    uint timeScale;
};

struct {
    local uint magic <hidden=true> = ReadUInt(FTell());
    if (ReadUShort(2) == 0)
        magic = ReadUInt(FTell()+4);
	
    if (magic == 4343376) {//50 46 42 00 PFB 
        uint signature;
	    int infoCount;
        int resourceCount;
        int grefInfoCount;
        
        if (RSZVersion != "DMC5" && RSZVersion != "RE2") {
            int userdataCount;
            int grefInfoTbl;
            int grefInfoTbl2;
            FSkip(4);
        }

	    uint64 resourceInfoTbl;
	    uint64 userdataInfoTbl;
	    uint64 dataOffset;
    }

    if (magic == 5395285) { //USR 
        uint signature;
        int resourceCount;
	    int infoCount;
        int userdataCount;
	    uint64 resourceInfoTbl;
	    uint64 userdataInfoTbl;
	    uint64 dataOffset;
    }
    if (magic == 1280262994) {//52 43 4F 4C RCOL
        uint signature;
        int numGroups;
        int numShapes;
        int numUserData;
        int numRequestSets;
        uint maxRequestSetId;
        if (RSZVersion == "RE8") {
            int numIgnoreTags;
            int numAutoGenerateJoints;
        }
        uint userDataSize;
        uint status;
        if (RSZVersion == "RE3") {
            uint64 uknA; 
            uint64 uknB; 
        }
        uint64 groupsPtrTbl;
        uint64 dataOffset <name="userDataStreamPtr">;
        uint64 requestSetTbl; 
        if (RSZVersion == "RE8") {
            uint64 ignoreTagTbl;
            uint64 autoGenerateJointDescTbl;
        }
    }
    if (magic == 5129043) { // 53 43 4E 00 SCN
        uint signature;
        int infoCount;
        int resourceCount;
        int folderCount;
        if (RSZVersion == "DMC5" && RSZVersion != "RE2") {
            int userdataCount;
            int prefabCount;
        } else {
            int prefabCount;
            int userdataCount;
        }

        uint64 folderInfoTbl;
        uint64 resourceInfoTbl;
        uint64 prefabInfoTbl;
        uint64 userdataInfoTbl;
        uint64 dataOffset;
    }
    
    if (ReadUInt(0) == 1414940738 || magic == 846423661) { //BHVT or mfs2
        if (magic == 846423661) { //mfs2
            uint version;
            uint signature;
            FSkip(8);
            uint64 treeData;
            uint64 transitionMapTbl;
            uint64 transitionDataTbl;
            uint64 treeInfoPtr;
            uint transitionMapCount;
            uint transitionDataCount;
            uint startTransitionDataIndex;

            FSeek(treeInfoPtr);
            uint treeDataSize;

            FSeek(transitionMapTbl);
            if (transitionMapCount) 
                struct TRANSITIONMAP {
                    uint transitionId;
                    int dataIndex;
                } TransitionMap[transitionMapCount];

            FSeek(transitionDataTbl);
            if (transitionDataCount) 
                struct TRANSITIONDATA {
                    int id;
                    uint32 endType : 4;
                    uint32 interpolationMode : 4;
                    uint32 interpolationCurve : 4;
                    uint32 prevMoveToEnd : 1;
                    uint32 startType : 4;
                    uint32 elapsedTimeZero : 1;
                    uint32 contOnLayer : 1;
                    uint32 contOnLayerInterpCurve : 4;
                    uint32 emptyBits : 9;
                    float exitFrame;
                    float startFrame;
                    float interpolationFrame;
                    if (RSZVersion != "RE2" && RSZVersion != "DMC5" ) {
                        float contOnLayerSpeed;
                        float contOnLayerTimeout;
                        uint16 contOnLayerNo;
                        uint16 contOnLayerJointMaskId;
                    }
                    FSkip(4);
                } TransitionData[transitionDataCount] <optimize=true>;

            FSeek(treeData);
        }
        struct {
            uint BHVT;
            FSkip(4);
            uint64 mSourceTreePtr;
            uint64 mNodes;
            uint64 mSelectors;
            uint64 mSelectorCallers;
            uint64 mActions;
            uint64 mConditions;
            uint64 mTransitionEvents;
            uint64 mExpressionTreeConditions;
            uint64 mSelectorValidNodeBuffer;
            uint64 mDelayedActions;
            uint64 mDelayedConditions;
            uint64 mDelayedTransitionEvents;
            uint64 mNamePoolOffs;
            uint64 mPathNamePoolOffs;
            if (RSZVersion != "RE2" && RSZVersion != "DMC5")
                uint64 mUserDataPathNamePoolOffs;
            uint64 mUserVariableDataPtr;//uint64 mRootNodeIndexOffs;
            uint64 mReferenceTreeCountOffs;
            uint64 mTreeIDOffs;
            FSeek(mTreeIDOffs+startof(this));
            unsigned int mTreeID;
            FSeek(mNamePoolOffs+startof(this));
            struct BHVTStringPool{
                uint poolSize;
                while (FTell() < startof(this)+(poolSize*2))
                    struct StringRead String(FTell(), 0, true) <read=ReadBHVTStringName>;
            } mNamePool;
            FSeek(mPathNamePoolOffs+startof(this));
            struct BHVTStringPool mPathNamePool;
            if (exists(mUserDataPathNamePoolOffs)) {
                FSeek(mUserDataPathNamePoolOffs+startof(this));
                struct BHVTStringPool mUserDataPathNamePool;
            }
            if (ReadBHVTHeader) {
                FSeek(mUserVariableDataPtr+startof(this));
                struct UVAR Uvar;
                FSeek(mReferenceTreeCountOffs+startof(this));
    
                unsigned int mReferenceTreeCount;
                if (FTell()+16 <= FileSize())
                    if (ReadUInt(FTell()+16) == 1918989941) {
                        uint64 Uvar2Offset;
                        FSeek(Uvar2Offset+startof(this));
                        struct UVAR Uvar2;
                    } else {
                        uint64 thisOffset;
                    }
            }
            FSeek(mSourceTreePtr+startof(this));
            struct {
                uint itemCount;
                uint A, B, C;
                int neg;
                uint D;
                uint NodeCount;

                local uint z <hidden=true>;
                
                struct {
                    for (o=0; o<NodeCount; o++) {
                        int hash <format=hex>;
                    }
                } NodeHashes;
                struct {
                    for (o=0; o<NodeCount; o++) {
                        int32 hash <format=hex>;
                    }
                } NodeInts;
                struct {
                    for (o=0; o<NodeCount; o++) {
                        int32 flag <format=hex>;
                    }
                } NodeFlags;
                //if (RSZVersion == "DMC5")
                //    int unknown[2];
                //else {
                    int unknown[5];
                    int thirtyFive;
                    int NameHash, NameHash <format=hex>;
                    int ukn, ukn;
                    ushort ukn;
                //}
            } TreeNodeDataStart;
            if (ReadBHVTHeader)
                struct BHVTNODES {
                    for (o=0; o<TreeNodeDataStart.itemCount; o++) {
                        if (FTell()+4 <= FileSize()) {
                            struct BHVTNode {                                
                                int ID : 16;
                                int ukn : 16;
                                struct BHVTHash ConditionID;
                                struct BHVTHash NodeID;
                                if (RSZVersion == "RE8" || RSZVersion == "DMC5") {
                                    int hash3;
                                    int hash4;
                                    int hash5;
                                    int hash6;
                                    struct BHVTHash NodeID_2;
                                    int hash8;
                                    int StringID;
                                    int hash10;
                                    int hash11;
                                    struct TripleHashList HashList3x;
                                    if (RSZVersion != "DMC5") {
                                        int hash13;
                                        int hash14;
                                        int hash15;
                                        struct DoubleHashList HashList2x;
                                        int ukn1;
                                        int thirtyFive;
                                        uint InstanceID, InstanceID <format=hex>;
                                        int ukn2;
                                        short uknShort;
                                        struct DoubleHashList HashList2x_2;
                                        if (ReadUInt(FTell()) == 0) 
                                            FSkip(-16);
                                    }
                                    local wstring name <hidden=true> = ReadWString(startof(mNamePool)+4+(StringID*2));
                                    //struct {
                                    //    for (o=0; o<TreeNodeDataStart.itemCount; o++)
                                    //        for (n=0; n<HashList3x.count; n++)
                                    //            if (TreeNodeDataStart. == HashList3x.Hash[n].Hash)
                                    //            
                                    //} ChildNodes <size=1>;
                                    //FSkip(-1);
                                }
                                
                            } Node <read=ReadBHVTNode, optimize=false>;
                        }
                    }
                } Nodes <size=SizeNodes>; //open=false, 
            FSeek(startof(mTreeIDOffs)+8);
        } BHVT;
    }
}Header;

    int SizeNodes (BHVTNODES &b) { return RSZOffset - startof(b); }

    wstring ReadBHVTNode(BHVTNode &u) { if (exists(u.name)) return u.name; return ""; }

    wstring ReadBHVTStringName(StringRead &str) { 
        string s; 
        SPrintf(s, "%X -- ", ((startof(str) - startof(parentof(str))) - 4) / 2); 
        return s + ReadStringRead(str); 
    }

struct DoubleHashList { 
    uint count; 
    if (count && FTell() + count * 4 <= FileSize()) {
        struct BHVTHash Hash[count]; 
        struct BHVTHash HashTwo[count]; 
    }
}; 
struct TripleHashList { 
    uint count; 
    if (count && FTell() + count * 4 <= FileSize()) {
        struct BHVTHash Hash[count]; 
        struct BHVTHash HashTwo[count]; 
        struct BHVTHash HashThree[count]; 
    }
}; 

typedef struct {
    local uint hash <hidden=true> = ReadUInt(FTell());
    local byte doExit <hidden=true>;

    if (ReadInt(FTell()) > 0) {
        for (o=0; o<Header.BHVT.TreeNodeDataStart.itemCount; o++) {
            if (hash == ReadUInt(startof(Header.BHVT.Nodes.Node[o].NodeID_2)) && startof(this) != startof(Header.BHVT.Nodes.Node[o].NodeID_2) ) { //
                FSeek(startof(Header.BHVT.Nodes.Node[o]));
                struct BHVTNode ChildNode <read=ReadBHVTNode>;
                doExit = true;
                break;
            }
        }
        if (!doExit) {
            for (j=0; j<level; j++) {
                i = 0;
                while (exists(RSZFile[j].Data.RawData.RSZ[i])) {
                    k = 0;
                    while(exists(RSZFile[j].Data.RawData.RSZ[i].var[k])) {
                        if (exists(RSZFile[j].Data.RawData.RSZ[i].var[k].data) 
                        && (ReadInt(startof(RSZFile[j].Data.RawData.RSZ[i].var[k].data)) > 0 && ReadUInt(startof(RSZFile[j].Data.RawData.RSZ[i].var[k].data)) == hash)) { //
                            FSeek(startof(RSZFile[j].Data.RawData.RSZ[i]));
                            RSZInstance RSZ <open=true>;
                            doExit = true;
                            break;
                        }
                        k++;
                    }
                    i++;
                    if (doExit) break;
                }
                if (doExit) break;
            }
        }
    }
    FSeek(startof(this));
    uint Hash;
} BHVTHash <size=4, optimize=false, read=ReadBHVTHash>; //, name=ReadBHVTHashName

    wstring ReadBHVTHash(BHVTHash &h) { string s; if (exists(h.RSZ)) return h.RSZ.name; SPrintf(s, "%X\n", h.Hash); return s; } 

    void WriteBHVTHash(BHVTHash &h, string s) { h.hash = Atoi(s); } 

    //wstring ReadBHVTHashName(BHVTHash &h) { if (exists(h.RSZ)) return h.RSZ.name; return ""; } 

typedef struct {
    HASH hash;
    uint32 CRC;
    StringRead pathOffset(-1, 0, 0);
} UserDataInfo <name=ReadUserDataInfoName, read=ReadUserDataInfo>;

    string ReadUserDataInfo (UserDataInfo &u) { return u.pathOffset.String; }
    
    string ReadUserDataInfoName(UserDataInfo &u) { return u.hash.HashName; }

typedef struct {
    if (ReadInt(FTell()+4) != 0)
        wstring path; 
    else
        StringRead pathStr(-1, 0, 0);
} Resource_Info <name=ReadResourceInfoName, read=ReadResourceInfo>;

    string ReadResourceInfo(Resource_Info &r) { if (exists(r.path)) return r.path; return r.pathStr.String; }

    string ReadResourceInfoName(Resource_Info &r) { if (!exists(r.pathStr.OpenFile) && !exists(r.OpenFile)) return "*ResourceInfo"; return ""; }

if (Header.magic != 1280262994) { //no RCOL

    if (exists(Header.infoCount) && Header.infoCount) {
        if (Header.magic == 4343376)
	        struct GameObjectInfoPFB {
		        ObjectId id(0);
		        ObjectId parentId(0);
		        int componentCount;
	        } GameObjectInfos[Header.infoCount] <optimize=true, name=ReadGRefInfoPFBName, read=ReadGRefInfoPFB>;
        else 
            struct GameObjectInfo {
                rGUID Guid;
                ObjectId id(0);
                ObjectId parentId(0);
                ushort componentCount;
                short ukn;
                int prefabId;
            } GameObjectInfos [Header.infoCount] <optimize=true, name=ReadGRefInfoName, read=ReadGRefInfo>; 
    }

    if (exists(Header.folderCount) && Header.folderCount) {
        FSeek(Header.folderInfoTbl);
        struct {
            for (i=0; i<Header.folderCount; i++)
                struct FOLDERINFO {
                    local uint idx <hidden=true> = i;
                    ObjectId id(0);
                    ObjectId parentId(0);
                } FolderInfo <name=ReadFOLDERINFOName, read=ReadFOLDERINFO>;
        } FolderInfos;
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        FSeek(Header.prefabInfoTbl);
        struct {
            for (i=0; i<Header.prefabCount; i++)
                struct PreFab {
                    local uint idx <hidden=true> = i;
                    int id;
                    int parentId;
                    FSeek(id); wstring path;
                    if (parentId) {
                        FSeek(parentId); 
                        wstring path;
                    }
                    FSeek(startof(parentId)+4);
                    
                } PrefabInfo <read=ReadPreFab, write=WritePreFab>;
        } PrefabInfos;
    }

    
    if (exists(Header.userdataCount) && Header.userdataCount) {
        FSeek(Header.userdataInfoTbl);
        struct {
	        UserDataInfo userDataInfo[Header.userdataCount] <optimize=false>;
        } userDataInfos;
    }

    if (exists(Header.resourceCount) && Header.resourceCount) {
	    FSeek(Header.resourceInfoTbl);
	    struct {
            Resource_Info ResourceInfo[Header.resourceCount] <optimize=false>;
	    } ResourceInfos;
    }
}

    wstring ReadGRefInfo(GameObjectInfo &g) { return ReadObjectIdTitle(g.id); }

    wstring ReadGRefInfoPFB(GameObjectInfoPFB &g) { return ReadObjectIdTitle(g.id); }

    wstring ReadGRefInfoName(GameObjectInfo &g) { return ReadObjectIdName(g.id); }

    wstring ReadGRefInfoPFBName(GameObjectInfoPFB &g) { return ReadObjectIdName(g.id); }

    wstring ReadFOLDERINFO(FOLDERINFO &f) { return ReadObjectIdTitle(f.id); }

    wstring ReadFOLDERINFOName(FOLDERINFO &f) { return ReadObjectIdName(f.id); }

    wstring ReadPreFab(PreFab &p) { return p.path; }

    void WritePreFab(PreFab &p, string s) { p.path = s; }

typedef struct {
        local ushort lvl <hidden=true>;
        if (exists(parentof(this).lvl)) 
            lvl = parentof(this).lvl;
        else lvl = getLevel(FTell());
        uint instanceId; 
        uint typeId <format=hex>;   
        if (RSZVersion == "DMC5" || RSZVersion == "RE2") {
            uint uknHash <format=hex>;
            uint uknOffs;
            uint64 pathOffs;
            local uint dataOffs <hidden=true> = pathOffs + startof(RSZHeader);
            FSkip(-1); struct { ubyte a; local wstring String; } path <hidden=true>; //dummy
        } else {
            StringRead path(-1, startof(RSZHeader), 0); 
        }
} RSZUserDataInfo <name=ReadRSZUserDataInfoName, read=ReadRSZUserDataInfo>;

    string ReadRSZUserDataInfoName(RSZUserDataInfo &u) { return RSZFile[u.lvl].InstanceInfos.instanceInfo[u.instanceId].typeId.HashName; }
    
    string ReadRSZUserDataInfo(RSZUserDataInfo &u) { return u.path.String; }

typedef struct OBJECT (ubyte isFolder)
{
    local int tempN <hidden=true>, tempJ <hidden=true>, prefabCount <hidden=true>, gChildCount <hidden=true>, fChildCount <hidden=true>, id <hidden=true>;
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else lvl = getLevel(FTell());
    local wstring title <hidden=true>;
    isFolder == true ? (id = FolderInfos.FolderInfo[n].id.id) : (id = GameObjectInfos[n].id.id);
    
    if (!isFolder && exists(GameObjectInfos[n].prefabId) && GameObjectInfos[n].prefabId != -1) {
        StringRead Prefab(startof(PrefabInfos.PrefabInfo[GameObjectInfos[n].prefabId].id), 0, 0) <name=PrefabName>; 
        FSkip(-1);
        title = Prefab.String;
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        for (j=0; j<Header.prefabCount; j++)
            if (PrefabInfos.PrefabInfo[j].parentId == id)
                prefabCount++;
        if (prefabCount) {
            struct {
                for (j=0; j<Header.prefabCount; j++)
                    if (PrefabInfos.PrefabInfo[j].parentId == id) {
                        StringRead Prefab(startof(PrefabInfos.PrefabInfo[j]), 0, 0) <name="Prefab">;
                        FSkip(-1);
                    }
                FSeek(startof(this) + 1);
            } Prefabs <name="Child Prefabs">;
            FSkip(-1);
        }
    }

    local uint counter <hidden=true>, isObject <hidden=true>;

    while (exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[id] + counter].name)) {
        isObject = FALSE;
        for (j=0; j<RSZHeader.objectCount; j++) 
            if (RSZFile[lvl].ObjectTable[id] + counter == RSZFile[lvl].ObjectTable[j]) { isObject = TRUE; break; }
        if ( counter == 0 || (RSZFile[lvl].InstanceInfos.instanceInfo[RSZFile[lvl].ObjectTable[id] + counter].typeId.HashName != "via.Folder")
            && (RSZFile[lvl].InstanceInfos.instanceInfo[RSZFile[lvl].ObjectTable[id] + counter].typeId.HashName != "via.GameObject") ) 
        {
            
            FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[id] + counter]));
            i = RSZFile[lvl].ObjectTable[id] + counter;
            tempN = n;
            if (isObject)
                RSZInstance RSZ;// <size=SizeRSZInstance>; //cant use Size= if using `i` to index
            n = tempN;
            counter ++;
        } else break;
    }  
    if (title == "" && exists(RSZ[0].title))
        title = RSZ[0].title;
        
    if (exists(Header.folderCount)) {        
        for (j=0; j<Header.folderCount; j++)
            if (FolderInfos.FolderInfo[j].parentId.id == id) {
                if (!fChildCount)
                    FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                fChildCount++;
            }
        
        if (fChildCount) {
            struct {
                for (j=0; j<Header.folderCount; j++) {
                    if (FolderInfos.FolderInfo[j].parentId.id == id) {
                        tempN = n; tempJ = j;
                        FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                        n = j;
                        if (fChildCount == 1)
                            struct GameObject ChildFolder(1) <read=ReadGameObject, open=true>;
                        else
                            struct GameObject ChildFolder(1) <read=ReadGameObject>;
                        n = tempN; j = tempJ;
                    }
                }
                if (startof(this) > FTell())
                    FSeek(startof(this) + sizeof(ChildFolder[0]));
            } Folders <name="Child Folders">;
        }
    }
    
    for (j=0; j<Header.infoCount; j++)
        if (GameObjectInfos[j].parentId.id == id ) {
            if (!gChildCount && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]]))
                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]]));
            gChildCount++;
        }    
    
    if (gChildCount) {
        struct {
            for (j=0; j<Header.infoCount; j++) {
                if (GameObjectInfos[j].parentId.id == id && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]])) {
                    tempN = n; tempJ = j;
                    FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos[j].id.id]]));
                    n = j;
                    if (gChildCount == 1)
                        struct GameObject ChildObject(0) <open=true>;
                    else
                        struct GameObject ChildObject(0);
                    n = tempN; j = tempJ;
                }
            }
            if (startof(this) > FTell())
                FSeek(startof(this) + sizeof(ChildObject[0]));
        } GameObjects <name="Child GameObjects">;
    }
    
    checkUseSpacers();
    
    if (startof(this) > FTell())
        FSeek(startof(this) + sizeof(RSZ[0]));
};

typedef OBJECT GameObject <name=ReadGameObjectName, read=ReadGameObject>;

    wstring ReadGameObjectName(GameObject &g) {         
        if (exists(g.RSZ[0].var[0].data))
            return (wstring)g.RSZ[0].var[0].data;
        return "";
    }

    wstring ReadGameObject(GameObject &g) {
        if (exists(g.RSZ[0].var[5].data ) && g.RSZ[0].name == "via.Folder")
            return g.RSZ[0].var[5].data;
        if (exists(g.RSZ[0].var[1].data ) && g.RSZ[0].name == "via.GameObject")
            return g.RSZ[0].var[1].data;
        if (exists(g.Prefab)) 
            return g.Prefab.String;
        return "";
    }

typedef uint64 InsertKey <read=ReadInsertHashKey, write=InsertHashKey>;
    
    wstring ReadInsertHashKey(InsertKey &k) { return "Input a '*' here to insert an object, or a space to insert a non-object"; }
    
    void InsertHashKey(InsertKey &k, string s) { 
        local int lvl = parentof(parentof(parentof(k))).lvl;
        int64 newValue = Atoi(s);
        local int isObject;
        if (s[0] == 42) {
            isObject = TRUE;
            newValue = Atoi(SubStr(s, 1, sizeof(s)-1));
        }
        Printf("%i\n", (startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos)));
        local int freeSpace = 16 - ((startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos)) % 16);
        local int sizeToInsert = 8 - freeSpace;
        if (isObject)
            sizeToInsert = 12 - freeSpace;
        local int newPadding = (16 - sizeToInsert) % 16;
        local int diff = sizeToInsert + newPadding;
        Printf("%iL %i %i %i %i %i\n", newValue, freeSpace, sizeToInsert, newPadding, diff, parentof(k).index);
        RSZFile[lvl].RSZHeader.dataOffset += diff;
        RSZFile[lvl].RSZHeader.userdataOffset += diff;
        if (isObject) {
            RSZFile[lvl].RSZHeader.instanceOffset += 4;
            RSZFile[lvl].RSZHeader.objectCount += 1;
        }
        RSZFile[lvl].RSZHeader.instanceCount += 1;
        for (o=0; o<RSZFile[lvl].RSZHeader.objectCount-1; o++) 
            if (RSZFile[lvl].ObjectTable[o] > parentof(k).index)
                RSZFile[lvl].ObjectTable[o] += 1;
        if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
            local int ii, jj;
            while (exists(RSZFile[ii])) {
                if (startof(RSZFile[ii]) < startof(RSZFile[lvl]) && RSZFile[ii].RSZHeader.RSZoffs > RSZFile[lvl].RSZHeader.RSZoffs) {
                    //Printf("%i %i %i\n", startof(r.size)+4, startof(RSZFile[ii]), startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) );
                    RSZFile[ii].RSZHeader.dataOffset += diff;
                }
                jj=0;
                while (exists(RSZFile[ii].RSZUserDataInfos.userDataInfo[jj])) {
                    if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs + startof(RSZFile[ii]) > startof(RSZFile[lvl]))
                        RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].pathOffs += diff;
                    if ( RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs + startof(RSZFile[ii]) > startof(RSZFile[lvl]))
                        RSZFile[ii].RSZUserDataInfos.userDataInfo[jj].uknOffs += diff;
                    
                    jj++;
                }
                ii++;
            }
        } else 
            for (o=0; o<RSZFile[lvl].RSZHeader.userdataCount; o++)
                RSZFile[lvl].RSZUserDataInfos.userDataInfo[o].path.strOffset += diff;
        if (freeSpace)
            DeleteBytes(startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos), freeSpace);
        if (newPadding)
            InsertBytes(startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos), newPadding, 0);
        InsertBytes(startof(parentof(k))+8, 8, 0);
        WriteInt64(startof(parentof(k))+8, newValue);
        if (isObject) {
            InsertBytes(startof(RSZFile[lvl].InstanceInfos), 4, 0);
            WriteUInt(startof(RSZFile[lvl].InstanceInfos), parentof(k).index+1);
        }
        MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
    }

typedef struct {
    struct RSZHEADER {
	    unsigned int magic;
	    unsigned int version;
	    int objectCount;
	    int instanceCount;
	    int userdataCount;
	    int reserved;
        int64 instanceOffset;
	    int64 dataOffset;
	    int64 userdataOffset;
        local uint RSZoffs = dataOffset + startof(this);
    };

    if (!ShowChildRSZs && exists(parentof(this)))
        RSZHEADER RSZHeader <hidden=true>;
    else 
        RSZHEADER RSZHeader;

    local ushort lvl <hidden=true> = getLevel(RSZHeader.RSZoffs);

    FSeek(startof(RSZHeader.userdataOffset)+8);
    if (RSZHeader.objectCount && !ShowChildRSZs && exists(parentof(this)))
        uint32 ObjectTable[RSZHeader.objectCount] <hidden=true, name=ReadObjectName, read=ReadObject>;
    else if (RSZHeader.objectCount)
        uint32 ObjectTable[RSZHeader.objectCount] <name=ReadObjectName, read=ReadObject>;
    
    FSeek(startof(RSZHeader) + RSZHeader.instanceOffset);
    struct INSTANCEINFO {
        for (i=0; i< RSZHeader.instanceCount; i++) {
            struct InstanceInfo {
                local uint index <hidden=true> = i;
	            HASH typeId;
                uint CRC;
                FSkip(-8);
                int64 CombinedKey;
                FSkip(-8);
                InsertKey NewKey;
                if (!i)
                    typeId.HashName = "NULL";
            } instanceInfo <name=ReadInstanceInfoName, read=ReadInstanceInfo>;
        }
    };
    
    if (!ShowChildRSZs && exists(parentof(this)))
        INSTANCEINFO InstanceInfos <hidden=true>;
    else
        INSTANCEINFO InstanceInfos;
    
    if (RSZHeader.userdataCount) {
	    FSeek(startof(RSZHeader) + RSZHeader.userdataOffset);
        struct {
            for (i=0; i<RSZHeader.userdataCount; i++)
                RSZUserDataInfo userDataInfo;
        }RSZUserDataInfos;
    }
    
    FSeek(RSZHeader.RSZoffs);
    if (RSZHeader.instanceCount > 1) {
        struct {
            local int isObject <hidden=true>;
            local ushort lvl <hidden=true> = parentof(this).lvl;
            struct DATA {
                if (!IsInitialized())
                    ParseJson(JsonPath);
                
                local int rawData <hidden=true>;
                local int lvl <hidden=true> = getLevel(FTell());
                for (i=0; i<RSZFile[lvl].RSZHeader.instanceCount; i++) {
                    if (!finished && RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.HashName == "via.GameObject") 
                    {
                        if (FTell()+4 <= FileSize())
                            fakeGameObject Test <hidden=true>;
                        if (lastGameObject > 0 && (Test.timeScale != 3212836864 )) { 
                            Printf("Seeking from %u to last GameObject at %u\n",  FTell(), lastGameObject); 
                            FSeek(startof(Test));
                            BLANK blank <read=ReadErrorNotice, bgcolor=cRed>;
                            FSeek(lastGameObject);
                            while (FTell() <= FileSize() - 8) {
                                if (ReadUInt(FTell()) == 3212836864 && detectedBools(FTell()-4) 
                                && (detectedString(FTell()-16) || detectedString(FTell()-20) || detectedString(FTell()-24)) )
                                    break;
                                FSkip(4);
                            }
                            lastGameObject = FTell()+4;
                            Printf("Redetected next GameObject at %u\n",  lastGameObject); 
                            
                            FSkip(-32);
                            //while (FTell() > lastGameObject - 28 && !detectedString(FTell()))
                            //    FSkip(-1);
                            if (detectedString(FTell()))
                                redetectStringBehind();
                            else FSkip(8);
                            //if (detectedString(FTell()-8)) {
                            //    FSkip(-8);
                            //    redetectStringBehind();
                            //}
                            broken = false;
                            SetForeColor(cYellow);
                        } else if (FTell() > lastGameObject) {
                            lastGameObject = FTell();
                            FSeek(startof(Test));
                        }
                    }
                    
                    if (!i)
                        RSZInstance RSZ <hidden=true>;
                    else if (!broken)
                        RSZInstance RSZ <fgcolor=cGreen>;
                    else
                        RSZInstance RSZ;
                    if (sizeof(RSZ) == 0) 
                        Printf("Empty struct: %u\n", FTell()); 
                    if (exists(RSZ.skipFileData)) {
                        FSeek(startof(RSZ));
                    } else if (exists(RSZ.skip)) {
                        if (i)
                            Printf("\nERROR: Missing struct for %X %s [%u]\n", RSZ.hash, RSZ.name, RSZ.idx);
                        FSeek(startof(RSZ));
                    }
                }
            };
            DATA RawData <open=suppress>;
        
            finished = TRUE;
                
            if (Nesting && Header.magic != 1280262994) { //no RCOL
                if (exists(Header.dataOffset) && startof(RSZFile[lvl]) == Header.dataOffset) {
                    if (exists(Header.folderCount))
                        for (n=0; n<Header.folderCount; n++) {
                            if (FolderInfos.FolderInfo[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]]));
                                struct GameObject MainFolder(1)  <name=ReadGameObjectName, read=ReadGameObject>;
                            }
                        }
                    if (exists(Header.infoCount))
                        for (n=0; n<Header.infoCount; n++) {
                            if (GameObjectInfos[n].id.id > -1 && GameObjectInfos[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[GameObjectInfos[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[GameObjectInfos[n].id.id]]));
                                struct GameObject MainObject(0)  <name=ReadGameObjectName, read=ReadGameObject>;
                            } 
                        }
                } else {
                    for (i=0; i<RSZHeader.instanceCount; i++) {
                        isObject = FALSE;
                        for (j=0; j<RSZHeader.objectCount; j++) 
                            if (ObjectTable[j] == i) { isObject = TRUE; break; }
                        if (isObject && exists(RawData.RSZ[i])) {
                            FSeek(startof(RawData.RSZ[i]));
                            RSZInstance RSZ; //size=SizeRSZInstance
                            if (exists(RawData.RSZ[i].skip) || exists(RawData.RSZ[i].skipFileData)) 
                                FSeek(startof(RSZ));
                        }
                    }
                }
            }
        } Data <open=true>;
    } else 
        { FSkip(-1); ubyte Data <hidden=true>; }
    
    if (exists(parentof(this)))
        checkUseSpacers();
    local int f <hidden=true>, ff <hidden=true>;
    if (ShowChildRSZs && (RSZHeader.userdataCount && (RSZVersion == "DMC5" || RSZVersion == "RE2")) ) {
        FSeek(RSZUserDataInfos.userDataInfo[0].dataOffs);
        struct {
            for (f=0; f<RSZHeader.userdataCount; f++) {
                FSeek(RSZUserDataInfos.userDataInfo[f].dataOffs);
                struct RSZMagic UserData <size=52>;
            }
        } UserData;
    }
} RSZMagic <name="RSZ", name=ReadRSZMagicName, read=ReadRSZMagic>;

    wstring ReadRSZMagicName(RSZMagic &m) { 
        if (exists(m.ObjectTable) && exists(m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName)) {
            return m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName; 
        } else {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f]) == startof(m) && exists(RSZFile[f].ObjectTable) && exists(RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName) ) 
                    return RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName;
            }
        }
        return "RSZ"; 
    }

    wstring ReadRSZMagic(RSZMagic &m) { 
        if (exists(m.Data.RSZ[0].title)) 
            return m.Data.RSZ[0].title;
        else if (exists(m.Data.MainObject[0].title))
            return m.Data.MainObject[0].title;
        else if (exists(m.Data.MainFolder[0].title))
            return m.Data.MainFolder[0].title;
        else {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f]) == startof(m) && exists(RSZFile[f].ObjectTable) && exists(RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title) ) 
                    return RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title;
            }
        }
        return ""; 
    }

    string ReadObjectName(uint &o) { 
        local ushort lvl = parentof(o).lvl;
        local uint32 hash = ReadUInt((startof(RSZFile[lvl].RSZHeader) + RSZFile[lvl].RSZHeader.instanceOffset + 8 * o)); 
        return ReadHashName(hash); 
    }

    string ReadObject(uint &o) { 
        local ushort lvl = parentof(o).lvl;
        local string s;
        if (exists(RSZFile[lvl].Data.RawData.RSZ[o]))
            SPrintf(s, "%i -- %s", o, RSZFile[lvl].Data.RawData.RSZ[o].title);
        return s;
    }



    string ReadInstanceInfoName(InstanceInfo &i) { return i.typeId.HashName; }
    
    string ReadInstanceInfo(InstanceInfo &i) { string s; SPrintf(s, "%X", i.typeId.Hash); return s; }


//start of file =====================

FSeek(RSZOffset);
while (FTell()+4 <= FileSize()) {
    if ( ReadUInt(FTell()) == 5919570 ) { //RSZ
        finished = false;
        if (level == 1 && !FEof()) 
            { FSkip(-1); BLANK blank; }
        struct RSZMagic RSZFile;
        level++;
        FSeek(startof(RSZFile) + 4);
    } else 
        FSkip(1);
}
finished = true;
if (sizeof(Header) == 0) { //detect strings in motbank etc files:
    FSeek(0);
    while(FTell() + 6 <= FileSize())
        if (detectedString(FTell()))
            StringRead Detected_String(FTell(), 0, true); //absolute
        else 
            FSkip(2);
}

//RCOL only =========================

if (Header.magic == 1280262994) { 
    FSeek(Header.groupsPtrTbl);
    struct {
        struct RcolGroup {
            rGUID Guid;
            StringRead Name(-1, 0, 0);
            uint NameHash <format=hex>;
            int UserDataIndex;
            int NumShapes;
            int NumMaskGuids;
            uint64 ShapesTbl;
            int LayerIndex;
            uint MaskBits;
            uint64 MaskGuidsOffset;
            
            if (NumMaskGuids) {
                FSeek(MaskGuidsOffset);
                rGUID MaskGuids[NumMaskGuids];
                FSeek(startof(MaskGuidsOffset)+8);
            }
            
            rGUID LayerGuid;
            FSeek(ShapesTbl);
            if (NumShapes)
                struct RcolShape {
                    rGUID Guid;
                    StringRead Name(-1, 0, 0);
                    uint NameHash <format=hex>;
                    int UserDataIndex;
                    int LayerIndex;
                    int Attribute;
                    uint SkipIdBits;
                    uint IgnoreTagBits;
                    StringRead primaryJointNameStr(-1, 0, 0);
                    StringRead secondaryJointNameStr(-1, 0, 0);
                    uint PrimaryJointNameHash <format=hex>;
                    uint SecondaryJointNameHash <format=hex>;
                    enum <uint32> {
                        ShapeType_Aabb = 0x0,
                        ShapeType_Sphere = 0x1,
                        ShapeType_ContinuousSphere = 0x2,
                        ShapeType_Capsule = 0x3,
                        ShapeType_ContinuousCapsule = 0x4,
                        ShapeType_Box = 0x5,
                        ShapeType_Mesh = 0x6,
                        ShapeType_HeightField = 0x7,
                        ShapeType_StaticCompound = 0x8,
                        ShapeType_Area = 0x9,
                        ShapeType_Triangle = 0xA,
                        ShapeType_SkinningMesh = 0xB,
                        ShapeType_Cylinder = 0xC,
                        ShapeType_DeformableMesh = 0xD,
                        ShapeType_Invalid = 0xE,
                        ShapeType_Max = 0xF,
                    } ShapeType;
                    FSkip(4);
                    
                    float Parameters[20];
                    if (UserDataIndex) {
                        local uint RSZIdx <hidden=true> = RSZFile[0].ObjectTable[UserDataIndex];
                        FSeek(startof(RSZFile[0].Data.RawData.RSZ[RSZFile[0].ObjectTable[UserDataIndex]]));
                        RSZInstance RSZ <size=SizeRSZInstance>;
                        FSeek(startof(Parameters)+80);
                    }
                } Shape[NumShapes] <read=ReadShape, optimize=false>;
                
            FSeek(startof(LayerGuid)+16);
            checkUseSpacers();

        } Group[Header.numGroups] <size=80, read=ReadGroup, optimize=false>;
    } Groups;
    
    if (exists(Header.ignoreTagTbl) && Header.numIgnoreTags) {
        FSeek(Header.ignoreTagTbl);
        struct {
            struct RcolIgnoreTag {
                StringRead Name(-1, 0, 0);
                uint nameHash <format=hex>;
                FSkip(4);
            } IgnoreTag[Header.numIgnoreTags] <read=ReadIgnoreTag, optimize=false>; 
        } IgnoreTags;
    }
    
    if (exists(Header.autoGenerateJointDescTbl) && Header.numAutoGenerateJoints) {
        FSeek(Header.autoGenerateJointDescTbl);
        struct {
            uint ukn; //placeholder
        } AutoGenerateJointDescs;
    }

    if (exists(Header.numRequestSets) && Header.numRequestSets) {
        FSeek(Header.requestSetTbl);
        struct {
            for (n=0; n<Header.numRequestSets; n++)
                struct RcolRequestSet {
                    uint ID;
                    int GroupIndex;
                    int ShapeOffset;
                    uint status;
                    StringRead Name(-1, 0, 0);
                    uint NameHash <format=hex>;
                    FSkip(4);
                    StringRead KeyName(-1, 0, 0);
                    uint KeyHash <format=hex>;
                    
                    FSeek(startof(Groups.Group[GroupIndex]));
                    struct RcolGroup Group <read=ReadGroup, size=80>;
                    
                    local uint RSZIdx <hidden=true> = RSZFile.ObjectTable[n];
                    FSeek(startof(RSZFile.Data.RawData.RSZ[RSZIdx]));
                    RSZInstance RSZ <open=true, size=SizeRSZInstance>;

                    SetForeColor(cNone);
                    FSeek(startof(KeyHash)+8);
                } RequestSet <name=ReadRequestSetName, read=ReadRequestSet>;
        } RequestSets;
    }
} 
    wstring ReadGroup(RcolGroup &g) { 
        if (exists(parentof(g).GroupIndex) ) //&& exists(Groups.Group[parentof(g).GroupIndex])
            return Groups.Group[parentof(g).GroupIndex].Name.String; 
        if (exists(g.Name.String))
            return g.Name.String;  
        return ReadWString(ReadUInt64(startof(g)+16));
    }

    wstring ReadShape(RcolShape &s) { return s.Name.String; } 

    wstring ReadRequestSet(RcolRequestSet &a) { return a.Name.String; }

    wstring ReadRequestSetName(RcolRequestSet &a) { string s; SPrintf(s, "RequestSet ID: %u  ", a.ID); return s; }